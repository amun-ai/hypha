"""RPC/WebSocket Exploit Attempts - Critical Attack Vectors.

This test suite attempts to exploit vulnerabilities in:
1. Context forgery via WebSocket messages
2. Redis prefix manipulation
3. Local routing bypass
4. Callback session hijacking
"""
import pytest
import asyncio
import json
import msgpack
import shortuuid
from hypha_rpc import connect_to_server
from . import WS_SERVER_URL


@pytest.mark.asyncio
async def test_context_forgery_attack(fastapi_server, test_user_token, test_user_token_2):
    """CRITICAL: Attempt to forge context fields to impersonate another workspace/user.

    Attack Vector:
    1. Connect as user1 in workspace1
    2. Try to send message with forged context claiming to be from workspace2
    3. See if target service receives forged context

    Expected: Server should reject or override forged context
    Vulnerability ID: V-RPC-CRITICAL-1
    """
    # Setup: Create two separate workspaces with different users
    user1 = await connect_to_server({
        "name": "user1",
        "server_url": WS_SERVER_URL,
        "token": test_user_token
    })

    user2 = await connect_to_server({
        "name": "user2",
        "server_url": WS_SERVER_URL,
        "token": test_user_token_2
    })

    # Create workspaces
    ws1_name = f"workspace-1-{shortuuid.uuid()[:8].lower()}"
    ws2_name = f"workspace-2-{shortuuid.uuid()[:8].lower()}"

    ws1_info = await user1.create_workspace({"name": ws1_name})
    ws2_info = await user2.create_workspace({"name": ws2_name})

    # Register a service in workspace2 that logs received context
    received_contexts = []

    def log_context(data, context=None):
        """Service that logs the context it receives."""
        received_contexts.append({
            "data": data,
            "context": context
        })
        return "logged"

    await user2.register_service({
        "id": "context-logger",
        "type": "test",
        "config": {"require_context": True},
        "log": log_context
    })

    # Get tokens for each workspace
    token1 = await user1.generate_token({"workspace": ws1_name})
    token2 = await user2.generate_token({"workspace": ws2_name})

    # Connect clients to workspaces
    client1 = await connect_to_server({
        "name": "attacker",
        "server_url": WS_SERVER_URL,
        "token": token1,
        "workspace": ws1_name
    })

    client2 = await connect_to_server({
        "name": "victim-client",
        "server_url": WS_SERVER_URL,
        "token": token2,
        "workspace": ws2_name
    })

    # ATTACK 1: Try to call service in ws2 from ws1 with forged context
    # The service ID format is workspace/service:instance
    try:
        # This should be blocked by workspace isolation
        svc = await client1.get_service(f"{ws2_name}/context-logger:default")

        # If we can call it, check what context was received
        await svc.log("test from attacker")

        # VULNERABILITY: If this succeeds, check what workspace was in context
        if len(received_contexts) > 0:
            ctx = received_contexts[-1]["context"]
            if ctx and ctx.get("ws") == ws1_name:
                pytest.fail(
                    f"CRITICAL VULNERABILITY: Attacker from {ws1_name} successfully "
                    f"accessed service in {ws2_name} with their own workspace context!"
                )
            elif ctx and ctx.get("ws") == ws2_name:
                pytest.fail(
                    f"SEVERE VULNERABILITY: Cross-workspace service access allowed! "
                    f"Attacker from {ws1_name} called service in {ws2_name}"
                )
    except Exception as e:
        # Expected: Should fail with permission or not found error
        error_msg = str(e).lower()
        assert "permission" in error_msg or "not found" in error_msg, \
            f"Expected permission/not found error, got: {e}"

    # ATTACK 2: Try to directly manipulate the RPC message with forged context
    # This requires accessing the underlying websocket connection
    # We'll try via the RPC layer's internal methods if accessible

    # Verify no unauthorized access occurred
    # Only user2's legitimate calls should be logged
    for ctx_log in received_contexts:
        ctx = ctx_log.get("context")
        if ctx:
            # All received contexts should be from ws2_name
            assert ctx.get("ws") == ws2_name, \
                f"Context forgery detected! Received context from {ctx.get('ws')}"

    await client1.disconnect()
    await client2.disconnect()
    await user1.disconnect()
    await user2.disconnect()


@pytest.mark.asyncio
async def test_redis_prefix_manipulation(fastapi_server, test_user_token):
    """HIGH: Test if crafted target_ids can bypass workspace isolation via Redis routing.

    Attack Vector:
    1. Try to send messages with target_ids like "other-workspace/client"
    2. Test if the prefix system can be manipulated
    3. Attempt to inject Redis channel patterns

    Expected: Workspace boundaries should be enforced
    Vulnerability ID: V-RPC-HIGH-1
    """
    admin = await connect_to_server({
        "name": "admin",
        "server_url": WS_SERVER_URL,
        "token": test_user_token
    })

    # Create two workspaces
    ws1_name = f"ws-attacker-{shortuuid.uuid()[:8].lower()}"
    ws2_name = f"ws-victim-{shortuuid.uuid()[:8].lower()}"

    await admin.create_workspace({"name": ws1_name})
    await admin.create_workspace({"name": ws2_name})

    token1 = await admin.generate_token({"workspace": ws1_name})
    token2 = await admin.generate_token({"workspace": ws2_name})

    # Setup victim service
    victim_messages = []

    def receive_message(msg):
        victim_messages.append(msg)
        return "received"

    victim = await connect_to_server({
        "name": "victim",
        "server_url": WS_SERVER_URL,
        "token": token2,
        "workspace": ws2_name
    })

    await victim.register_service({
        "id": "victim-service",
        "type": "test",
        "receive": receive_message
    })

    attacker = await connect_to_server({
        "name": "attacker",
        "server_url": WS_SERVER_URL,
        "token": token1,
        "workspace": ws1_name
    })

    # ATTACK 1: Try to access victim service with full workspace path
    try:
        # This attempts: ws-attacker -> ws-victim/victim-service
        victim_svc = await attacker.get_service(f"{ws2_name}/victim-service:default")
        await victim_svc.receive("malicious message")

        # If this succeeds, it's a vulnerability
        if len(victim_messages) > 0:
            pytest.fail(
                f"CRITICAL: Cross-workspace service access succeeded! "
                f"Message from {ws1_name} delivered to {ws2_name}"
            )
    except Exception as e:
        # Expected to fail
        assert "permission" in str(e).lower() or "not found" in str(e).lower()

    # ATTACK 2: Try crafted target_id patterns
    # These might bypass validation if the code has edge cases
    crafted_targets = [
        f"../{ws2_name}/victim-service",  # Path traversal
        f"/{ws2_name}/victim-service",    # Absolute path
        f"{ws2_name}/../{ws2_name}/victim-service",  # Complex traversal
        "broadcast:victim-service",  # Redis prefix injection
        "targeted:victim-service",   # Targeted prefix injection
    ]

    for target in crafted_targets:
        try:
            # Try to get service with crafted ID
            svc = await attacker.get_service(target)
            await svc.receive(f"attack via {target}")

            if len(victim_messages) > 0:
                pytest.fail(
                    f"VULNERABILITY: Crafted target_id '{target}' bypassed "
                    f"workspace isolation!"
                )
        except Exception:
            # Expected to fail - this is good
            pass

    # Verify victim received no unauthorized messages
    assert len(victim_messages) == 0, \
        f"Victim received {len(victim_messages)} unauthorized messages!"

    await attacker.disconnect()
    await victim.disconnect()
    await admin.disconnect()


@pytest.mark.asyncio
async def test_local_routing_bypass(fastapi_server, test_user_token):
    """HIGH: Test if local routing optimization bypasses workspace validation.

    Attack Vector:
    Lines 1374-1382 in core/__init__.py show local optimization
    Test if this bypass correctly validates workspace isolation

    Expected: Local routing should still enforce workspace boundaries
    Vulnerability ID: V-RPC-HIGH-2
    """
    admin = await connect_to_server({
        "name": "admin",
        "server_url": WS_SERVER_URL,
        "token": test_user_token
    })

    # Create two workspaces on the SAME server instance
    # This ensures both clients will be "local" to each other
    ws1_name = f"local-ws1-{shortuuid.uuid()[:8].lower()}"
    ws2_name = f"local-ws2-{shortuuid.uuid()[:8].lower()}"

    await admin.create_workspace({"name": ws1_name})
    await admin.create_workspace({"name": ws2_name})

    token1 = await admin.generate_token({"workspace": ws1_name})
    token2 = await admin.generate_token({"workspace": ws2_name})

    # Register service in ws2
    local_messages = []

    def local_receiver(msg):
        local_messages.append(msg)
        return "received locally"

    client2 = await connect_to_server({
        "name": "local-victim",
        "server_url": WS_SERVER_URL,
        "token": token2,
        "workspace": ws2_name
    })

    await client2.register_service({
        "id": "local-service",
        "type": "test",
        "receive": local_receiver
    })

    client1 = await connect_to_server({
        "name": "local-attacker",
        "server_url": WS_SERVER_URL,
        "token": token1,
        "workspace": ws1_name
    })

    # ATTACK: Try to exploit local routing optimization
    # The code at line 1374-1382 checks if target is local
    # and skips Redis if so - does it validate workspace?

    try:
        # Try to access local service in different workspace
        svc = await client1.get_service(f"{ws2_name}/local-service:default")
        result = await svc.receive("exploit local routing")

        # VULNERABILITY if this succeeds
        if len(local_messages) > 0:
            pytest.fail(
                f"CRITICAL: Local routing bypass! "
                f"Client in {ws1_name} accessed service in {ws2_name} via local optimization"
            )
    except Exception as e:
        # Expected to fail
        error_msg = str(e).lower()
        assert "permission" in error_msg or "not found" in error_msg

    # Verify no messages were delivered
    assert len(local_messages) == 0, \
        "Local routing allowed unauthorized message delivery!"

    await client1.disconnect()
    await client2.disconnect()
    await admin.disconnect()


@pytest.mark.asyncio
async def test_callback_session_hijacking(fastapi_server, test_user_token):
    """MEDIUM: Test if callback sessions can be enumerated or hijacked.

    Attack Vector:
    Sessions use shortuuid - can we predict or enumerate them?
    Can we invoke callbacks belonging to other users?

    Expected: Sessions should be isolated and unpredictable
    Vulnerability ID: V-RPC-MED-1
    """
    client = await connect_to_server({
        "name": "callback-test",
        "server_url": WS_SERVER_URL,
        "token": test_user_token
    })

    # Register a service that accepts callbacks
    callback_results = []

    def service_with_callback(callback, data):
        """Service that executes a user-provided callback."""
        result = callback(data)
        callback_results.append(result)
        return result

    await client.register_service({
        "id": "callback-service",
        "type": "test",
        "execute": service_with_callback
    })

    # Create callbacks and monitor their session IDs
    session_ids_observed = []

    def tracking_callback(data):
        # Try to observe session information if accessible
        return f"callback result: {data}"

    # Get the service
    svc = await client.get_service("callback-service")

    # Execute multiple callbacks to observe session ID pattern
    for i in range(5):
        result = await svc.execute(tracking_callback, f"test-{i}")
        # Session IDs are internal - we can't directly access them
        # but we can test if the system leaks them

    # ATTACK: Try to enumerate session IDs
    # Session IDs use shortuuid which generates 22 character strings
    # Testing all combinations is infeasible, but we can test if:
    # 1. Session IDs are predictable
    # 2. Session validation is weak

    # Try common/predictable session ID patterns
    test_session_ids = [
        "00000000000000000000000",  # All zeros
        "11111111111111111111111",  # All ones
        "aaaaaaaaaaaaaaaaaaaaaaa",  # All a's
        "../session",  # Path traversal
        "session/../admin",  # Complex traversal
    ]

    # We can't directly test session hijacking without access to internals
    # but we can verify that the service correctly isolates callbacks

    # Create a second client to test cross-client callback isolation
    client2 = await connect_to_server({
        "name": "client2",
        "server_url": WS_SERVER_URL,
        "token": test_user_token
    })

    client2_results = []

    def client2_callback(data):
        client2_results.append(data)
        return f"client2: {data}"

    # Client2 calls the service with their callback
    svc2 = await client2.get_service("callback-service")
    await svc2.execute(client2_callback, "client2-data")

    # Verify callbacks are isolated
    # client2's callback should not affect client1's results
    assert len(client2_results) == 1
    assert client2_results[0] == "client2-data"

    # Total callback results should be 6 (5 from client1 + 1 from client2)
    assert len(callback_results) == 6

    await client.disconnect()
    await client2.disconnect()


@pytest.mark.asyncio
async def test_workspace_manager_targeting(fastapi_server, test_user_token):
    """Test if clients can target workspace managers directly.

    Attack Vector:
    Code at line 776-778 prevents targeting "/ws-" patterns
    Test if this validation can be bypassed

    Expected: Workspace manager targeting should be blocked
    Vulnerability ID: V-RPC-MED-2
    """
    client = await connect_to_server({
        "name": "attacker",
        "server_url": WS_SERVER_URL,
        "token": test_user_token
    })

    # Create a workspace
    ws_name = f"test-ws-{shortuuid.uuid()[:8].lower()}"
    await client.create_workspace({"name": ws_name})

    # Try to target the workspace manager
    # The code should reject target_ids containing "/ws-"
    malicious_targets = [
        "*/ws-manager",
        "workspace/ws-admin",
        "test/ws-controller",
        "/ws-user-root/admin",
        "ws-user-test/service",
    ]

    for target in malicious_targets:
        try:
            # Try to get a service with workspace manager pattern
            # This should be blocked by the validation at line 776-778
            svc = await client.get_service(target)

            # If we get here, the validation failed
            pytest.fail(
                f"VULNERABILITY: Workspace manager targeting not blocked! "
                f"Successfully targeted: {target}"
            )
        except Exception as e:
            # Expected: Should fail with validation error or not found
            error_msg = str(e).lower()
            # Should contain "invalid" or similar error
            # Just verify it fails - any failure is good
            pass

    await client.disconnect()


@pytest.mark.asyncio
async def test_broadcast_to_all_workspaces(fastapi_server, test_user_token, test_user_token_2):
    """Test if a client can broadcast to all workspaces (not just their own).

    Attack Vector:
    Broadcasts use "*" which gets converted to "{workspace}/*"
    Can we bypass this to broadcast to all workspaces?

    Expected: Broadcasts should be workspace-scoped
    Vulnerability ID: V-RPC-MED-3
    """
    # Create two workspaces
    user1 = await connect_to_server({
        "name": "user1",
        "server_url": WS_SERVER_URL,
        "token": test_user_token
    })

    user2 = await connect_to_server({
        "name": "user2",
        "server_url": WS_SERVER_URL,
        "token": test_user_token_2
    })

    ws1_name = f"broadcast-ws1-{shortuuid.uuid()[:8].lower()}"
    ws2_name = f"broadcast-ws2-{shortuuid.uuid()[:8].lower()}"

    await user1.create_workspace({"name": ws1_name})
    await user2.create_workspace({"name": ws2_name})

    token1 = await user1.generate_token({"workspace": ws1_name})
    token2 = await user2.generate_token({"workspace": ws2_name})

    # Connect clients
    ws1_events = []
    ws2_events = []

    client1 = await connect_to_server({
        "name": "client1",
        "server_url": WS_SERVER_URL,
        "token": token1,
        "workspace": ws1_name
    })

    client2 = await connect_to_server({
        "name": "client2",
        "server_url": WS_SERVER_URL,
        "token": token2,
        "workspace": ws2_name
    })

    # Register event listeners
    def on_ws1_event(data):
        ws1_events.append(data)

    def on_ws2_event(data):
        ws2_events.append(data)

    client1.on("test-event", on_ws1_event)
    client2.on("test-event", on_ws2_event)

    # ATTACK: Try to broadcast from ws1 to all workspaces
    # The code converts "*" to "{workspace}/*"
    # Can we bypass this with crafted patterns?

    try:
        # Normal broadcast (should only reach ws1)
        await client1.emit("test-event", {"from": "ws1", "attempt": "normal"})

        await asyncio.sleep(0.5)

        # ws1 should receive it, ws2 should not
        assert len(ws1_events) > 0, "Client1 should receive own broadcast"
        assert len(ws2_events) == 0, "Client2 should NOT receive ws1's broadcast"

        # Try crafted broadcast patterns
        crafted_patterns = [
            "*/test-event",  # Try to broadcast to all
            "../*/test-event",  # Path traversal
            f"{ws2_name}/*",  # Try to target other workspace directly
        ]

        for pattern in crafted_patterns:
            ws2_before = len(ws2_events)
            try:
                await client1.emit(pattern, {"attack": pattern})
                await asyncio.sleep(0.3)

                if len(ws2_events) > ws2_before:
                    pytest.fail(
                        f"CRITICAL: Broadcast isolation bypassed! "
                        f"Pattern '{pattern}' delivered to other workspace"
                    )
            except Exception:
                # Expected to fail or be ignored
                pass

    finally:
        await client1.disconnect()
        await client2.disconnect()
        await user1.disconnect()
        await user2.disconnect()

    # Final verification
    assert len(ws2_events) == 0, \
        f"WS2 received {len(ws2_events)} unauthorized broadcasts!"
