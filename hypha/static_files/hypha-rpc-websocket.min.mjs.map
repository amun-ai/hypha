{"version":3,"file":"hypha-rpc-websocket.min.mjs","mappings":"qIAyEO,MAAMA,EAaX,WAAAC,CACEC,EACAC,EACAC,EAAY,KACZC,EAAQ,KACRC,EAAqB,KACrBC,EAAU,GACVC,EAAyB,KACzBC,EAAS,SAET,QAAOP,GAAcC,EAAW,yCAChCO,KAAKC,YAAcT,EAAWU,QAAQ,MAAO,IAC7CF,KAAKG,WAAaV,EAClBO,KAAKI,WAAaV,EAClBM,KAAKK,OAASV,EACdK,KAAKM,oBAAsBV,EAC3BI,KAAKO,SAAWV,EAChBG,KAAKQ,wBAA0BV,EAC/BE,KAAKS,QAAUV,EAEfC,KAAKU,gBAAkB,KACvBV,KAAKW,qBAAuB,KAC5BX,KAAKY,kBAAoB,KAEzBZ,KAAKa,SAAU,EACfb,KAAKc,mBAAoB,EACzBd,KAAKe,gBAAkB,KACvBf,KAAKgB,WAAa,KAElBhB,KAAKiB,eAAiB,KACtBjB,KAAKkB,mBAAqB,IAC5B,CAKA,UAAAC,CAAWC,IACT,QAAOA,EAAS,uBAChBpB,KAAKU,gBAAkBU,CACzB,CAKA,eAAAC,CAAgBD,GACdpB,KAAKW,qBAAuBS,CAC9B,CAKA,YAAAE,CAAaF,GACXpB,KAAKY,kBAAoBQ,CAC3B,CAQA,YAAAG,CAAaC,GAAa,GACxB,MAAMC,EAAU,CACd,eAAgB,uBAYlB,OAVID,IACmB,YAAjBxB,KAAKS,QACPgB,EAAgB,OAAI,+BAEpBA,EAAgB,OAAI,wBAGpBzB,KAAKK,SACPoB,EAAuB,cAAI,UAAUzB,KAAKK,UAErCoB,CACT,CAKA,UAAMC,GACJC,QAAQC,KACN,wCAAwC5B,KAAKC,uBAAuBD,KAAKS,YAI3E,IAAIoB,EAAa,GAAG7B,KAAKC,6BAA6BD,KAAKG,aACvDH,KAAKI,aACPyB,GAAc,cAAc7B,KAAKI,cAEd,YAAjBJ,KAAKS,UACPoB,GAAc,mBAIhB7B,KAAK8B,iBAAiBD,GAGtB,MAAME,EAAQC,KAAKC,MACnB,KAAgC,OAAzBjC,KAAKe,iBAA0B,CAEpC,SADM,IAAImB,SAASC,GAAYC,WAAWD,EAAS,OAC/CH,KAAKC,MAAQF,EAAwB,IAAhB/B,KAAKO,SAC5B,MAAM,IAAI8B,MAAM,uCAElB,GAAIrC,KAAKa,QACP,MAAM,IAAIwB,MAAM,iCAEpB,CAGA,GADArC,KAAKgB,WAAahB,KAAKe,gBAAgBC,WACnChB,KAAKI,WAAY,CACnB,MAAMkC,EAAYtC,KAAKe,gBAAgBrB,UACvC,GAAI4C,IAActC,KAAKI,WACrB,MAAM,IAAIiC,MACR,iCAAiCC,gBAAwBtC,KAAKI,aAGpE,CAOA,OANAJ,KAAKI,WAAaJ,KAAKe,gBAAgBrB,UAEnCM,KAAKY,yBACDZ,KAAKY,oBAGNZ,KAAKe,eACd,CAWA,sBAAMe,CAAiBS,GACrB,IAAIC,EAAQ,EAEZ,MAAQxC,KAAKa,SAAW2B,EAnKV,KAmK6B,CACzC,IAGE,MAAMC,QAAiBC,MAAMH,EAAK,CAChCI,OAAQ,MACRlB,QAASzB,KAAKuB,cAAa,GAE3BqB,WAAW,IAGb,IAAKH,EAASI,GAAI,CAChB,MAAMC,QAAmBL,EAASM,OAClC,MAAM,IAAIV,MACR,6BAA6BI,EAASO,WAAWF,IAErD,CAEAN,EAAQ,EAEa,YAAjBxC,KAAKS,cAEDT,KAAKiD,sBAAsBR,SAG3BzC,KAAKkD,qBAAqBT,EAEpC,CAAE,MAAOU,GACP,GAAInD,KAAKa,QAAS,MAGlB,GAFAc,QAAQwB,MAAM,qBAAqBA,EAAMC,YAEpCpD,KAAKc,kBACR,KAEJ,CAGA,GAAKd,KAAKa,UAAWb,KAAKc,kBAOxB,MAP2C,CAC3C0B,GAAS,EAET,MAAMa,EAAQC,KAAKC,IAAyB,GAArBD,KAAKE,IAAI,EAAGhB,GAAc,IACjDb,QAAQC,KAAK,mBAAmByB,EAAMI,QAAQ,gBAAgBjB,YACxD,IAAIN,SAASC,GAAYC,WAAWD,EAAiB,IAARkB,IACrD,CAGF,EAEKrD,KAAKa,SAAWb,KAAKW,sBACxBX,KAAKW,qBAAqB,eAE9B,CAKA,0BAAMuC,CAAqBT,GACzB,MAAMiB,EAASjB,EAASkB,KAAKC,YACvBC,EAAU,IAAIC,YACpB,IAAIC,EAAS,GAEb,MAAQ/D,KAAKa,SAAS,CACpB,MAAM,KAAEmD,EAAI,MAAEC,SAAgBP,EAAOQ,OAErC,GAAIF,EAAM,MAEVD,GAAUF,EAAQM,OAAOF,EAAO,CAAEG,QAAQ,IAC1C,MAAMC,EAAQN,EAAOO,MAAM,MAC3BP,EAASM,EAAME,OAAS,GAExB,IAAK,MAAMC,KAAQH,EACjB,GAAKG,EAAKC,OAEV,IACE,MAAMrB,EAAUsB,KAAKC,MAAMH,SACrBxE,KAAK4E,qBAAqBxB,EAClC,CAAE,MAAOD,GACPxB,QAAQkD,KAAK,iCAAiC1B,EAAMC,UACtD,CAEJ,CACF,CAeA,wBAAA0B,CAAyBC,GAGvB,GAAIA,EAAWC,OAAS,IACtB,OAAO,KAGT,IAGE,MAAMC,GAAU,QAAcF,GAG9B,MAAuB,iBAAZE,GAAoC,OAAZA,GAAoBA,EAAQC,MACxC,CACnB,kBACA,OACA,OACA,qBACA,SAEeC,SAASF,EAAQC,MACzBD,EAKJ,IACT,CAAE,MAEA,OAAO,IACT,CACF,CAKA,2BAAMhC,CAAsBR,GAC1B,MAAMiB,EAASjB,EAASkB,KAAKC,YAC7B,IAAIG,EAAS,IAAIqB,WAAW,GAE5B,MAAQpF,KAAKa,SAAS,CACpB,MAAM,KAAEmD,EAAI,MAAEC,SAAgBP,EAAOQ,OAErC,GAAIF,EAAM,MAGV,MAAMqB,EAAY,IAAID,WAAWrB,EAAOiB,OAASf,EAAMe,QAMvD,IALAK,EAAUC,IAAIvB,GACdsB,EAAUC,IAAIrB,EAAOF,EAAOiB,QAC5BjB,EAASsB,EAGFtB,EAAOiB,QAAU,GAAG,CAEzB,MAAMA,EACHjB,EAAO,IAAM,GAAOA,EAAO,IAAM,GAAOA,EAAO,IAAM,EAAKA,EAAO,GAEpE,GAAIA,EAAOiB,OAAS,EAAIA,EAEtB,MAIF,MAAMD,EAAahB,EAAOwB,MAAM,EAAG,EAAIP,GACvCjB,EAASA,EAAOwB,MAAM,EAAIP,GAG1B,MAAMQ,EAAaxF,KAAK8E,yBAAyBC,GACjD,GAAIS,EAAY,CACd,MAAMC,EAAWD,EAAWN,KAC5B,GAAiB,oBAAbO,EAAgC,CAClCzF,KAAKe,gBAAkByE,EACvB,QACF,CAAO,GAAiB,SAAbC,GAAoC,SAAbA,EAChC,SACK,GAAiB,uBAAbA,EAAmC,CAC5CzF,KAAKM,oBAAsBkF,EAAW5F,mBACtC,QACF,CAAO,GAAiB,UAAb6F,EAAsB,CAC/B9D,QAAQwB,MAAM,iBAAiBqC,EAAWpC,WAC1C,QACF,CACF,CAGA,GAAIpD,KAAKU,gBACP,UACQV,KAAKU,gBAAgBqE,EAC7B,CAAE,MAAO5B,GACPxB,QAAQwB,MAAM,6BAA6BA,EAAMC,UACnD,CAEJ,CACF,CACF,CAKA,0BAAMwB,CAAqBxB,GAEzB,GAAqB,oBAAjBA,EAAQ8B,MAMZ,GAAqB,SAAjB9B,EAAQ8B,KAKZ,GAAqB,uBAAjB9B,EAAQ8B,KAMZ,GAAqB,UAAjB9B,EAAQ8B,MAMZ,GAAIlF,KAAKU,gBAAiB,CACxB,MAAMgF,GAAO,OAActC,SACrBpD,KAAKU,gBAAgBgF,EAC7B,OARE/D,QAAQwB,MAAM,iBAAiBC,EAAQA,gBANvCpD,KAAKM,oBAAsB8C,EAAQxD,wBAXnCI,KAAKe,gBAAkBqC,CA0B3B,CAWA,kBAAMuC,CAAaD,GACjB,GAAI1F,KAAKa,QACP,MAAM,IAAIwB,MAAM,wBAIlB,IAAIuD,EAAW,GAAG5F,KAAKC,6BAA6BD,KAAKG,aACrDH,KAAKI,aACPwF,GAAY,cAAc5F,KAAKI,cAIjC,MAAMuD,EAAO+B,aAAgBN,WAAaM,EAAO,IAAIN,WAAWM,GAI1DjD,QAAiBC,MAAMkD,EAAU,CACrCjD,OAAQ,OACRlB,QAASzB,KAAKuB,cAAa,GAC3BoC,KAAMA,EACNf,WAAW,IAGb,IAAKH,EAASI,GAAI,CAChB,MAAMC,QAAmBL,EAASM,OAClC,MAAM,IAAIV,MACR,2BAA2BI,EAASO,WAAWF,IAEnD,CAEA,OAAO,CACT,CAKA,gBAAA+C,CAAiB5B,GACfjE,KAAKc,kBAAoBmD,CAC3B,CAKA,gBAAM6B,CAAWC,EAAS,qBACpB/F,KAAKa,UAETb,KAAKa,SAAU,EAEXb,KAAKW,sBACPX,KAAKW,qBAAqBoF,GAE9B,EAMK,SAASC,EAAmBxG,GACjC,IAAKA,EACH,MAAM,IAAI6C,MAAM,0BAelB,OAXI7C,EAAWyG,WAAW,SACxBzG,EAAaA,EAAWU,QAAQ,QAAS,WAChCV,EAAWyG,WAAW,YAC/BzG,EAAaA,EAAWU,QAAQ,SAAU,aAIxCV,EAAW0G,SAAS,SACtB1G,EAAaA,EAAW+F,MAAM,GAAI,IAG7B/F,EAAWU,QAAQ,MAAO,GACnC,CAiHOiG,eAAeC,EAAoBC,EAAS,CAAC,GAClD,aA7GKF,eAAoCE,GACzC,IAAIC,EAAWD,EAAOC,UAAYD,EAAO5G,UACpC6G,IACHA,GAAW,WAGb,MAAM9G,EAAawG,EAAmBK,EAAOE,WAAaF,EAAO7G,YAE3DgH,EAAa,IAAIlH,EACrBE,EACA8G,EACAD,EAAO3G,UACP2G,EAAO1G,MACP0G,EAAOzG,mBACPyG,EAAOI,gBAAkB,GACzBJ,EAAOvG,wBAA0B,KAEjCuG,EAAOtG,QAAU,WAGbgB,QAAwByF,EAAW9E,QACzC,QAAOX,EAAiB,qCAElB,IAAImB,SAASC,GAAYC,WAAWD,EAAS,OAEnD,MAAMzC,EAAYqB,EAAgBrB,UAE5BgH,EAAM,IAAI,IAAIF,EAAY,CAC9B/G,UAAW6G,EACX5G,YACAiH,gBAAiB,CAAEC,gBAAiB,kBACpCC,KAAMR,EAAOQ,KACbJ,eAAgBJ,EAAOI,eACvBK,OAAQT,EAAOS,OACfC,gBAAiBhG,EAAgBiG,wBAG7BN,EAAIO,QAAQ,sBAAuBZ,EAAOI,gBAAkB,KAElE,MAAMS,QAAWR,EAAIS,oBAAoB,CACvCtH,QAASwG,EAAOI,gBAAkB,GAClCW,gBAAiB,UAEnBF,EAAGR,IAAMA,EAGTQ,EAAGpB,YAAa,OAAeY,EAAIZ,WAAWuB,KAAKX,GAAM,CACvDG,KAAM,aACNS,YAAa,yBACbC,WAAY,CAAEC,WAAY,CAAC,EAAGtC,KAAM,YAGtCgC,EAAGO,iBAAkB,OAAef,EAAIgB,iBAAiBL,KAAKX,GAAM,CAClEG,KAAM,kBACNS,YAAa,qBACbC,WAAY,CACVC,WAAY,CACVG,QAAS,CAAEL,YAAa,sBAAuBpC,KAAM,WAEvD0C,SAAU,CAAC,WACX1C,KAAM,YAIV,MAAM2C,EAAcX,EAAGY,WAgCvB,OA/BAZ,EAAGY,WAAa3B,MAAO4B,EAAO1B,EAAS,CAAC,UACzBwB,EAAYE,EAAO1B,GAE9BwB,EAAYG,aACdd,EAAGY,WAAWE,WAAaH,EAAYG,YAOzCd,EAAGe,OAAQ,QAJX9B,uBACQ,IAAIjE,SAAQ,QACpB,GAEiC,CAC/B2E,KAAM,QACNS,YAAa,yBACbC,WAAY,CAAErC,KAAM,SAAUsC,WAAY,CAAC,KAGzCzG,IACFmG,EAAGb,OAAS6B,OAAOC,OAAOjB,EAAGb,QAAU,CAAC,EAAGtF,IAIzCyF,EAAWxF,YACb0F,EAAI0B,GAAG,cAAcjC,MAAO/C,IACtBA,EAAQiF,OAAS,KAAO7B,EAAWxF,aACrCW,QAAQC,KAAK,8BAA8BwB,EAAQ2C,gBAC7CW,EAAIZ,aACZ,IAIGoB,CACT,CAYeoB,CAAqBjC,EACpC,CAKOF,eAAeoC,EAAqBC,EAAYnC,EAAS,CAAC,GAC/D,MAAM,UAAEE,EAAS,UAAE7G,EAAS,SAAE4G,EAAQ,UAAEmC,EAAS,MAAEC,IACjD,QAAgBF,GACZG,EAAgB,GAAGjJ,KAAa4G,KAAYmC,KAAaC,IAE/D,GAAIrC,EAAOE,WACLF,EAAOE,YAAcA,EACvB,MAAM,IAAIlE,MAAM,uBAGpBgE,EAAOE,UAAYA,EAEnB,MAAMqC,QAAexC,EAAoBC,GACzC,aAAauC,EAAOd,WAAWa,EACjC,C,iFC1oBO,MAAME,EAAc,EAIrBC,EAAkBZ,OAAOa,eAC7Bb,OAAOa,eAAe,IAAI3D,aAC1B7F,YAEF,SAASyJ,EAAcC,EAASC,GAC9B,MAAMC,EAAM,IAAI/D,WAAW6D,EAAQG,WAAaF,EAAQE,YAGxD,OAFAD,EAAI7D,IAAI,IAAIF,WAAW6D,GAAU,GACjCE,EAAI7D,IAAI,IAAIF,WAAW8D,GAAUD,EAAQG,YAClCD,EAAIpF,MACb,CASA,SAASsF,EAAYC,EAASC,EAAWnG,EAAU,uBACjD,OAAO,IAAIlB,SAAQ,CAACC,EAASqH,KAC3B,MAAMC,EAAYrH,YAAW,KAC3BoH,EAAO,IAAInH,MAAM,iBAAiBe,KAAW,GAC5CmG,GAEHD,EACGI,MAAMC,IACLC,aAAaH,GACbtH,EAAQwH,EAAO,IAEhBE,OAAO1G,IACNyG,aAAaH,GACbD,EAAOrG,EAAM,GACb,GAER,CAEA,SAAS2G,EAAYC,EAAKC,GACxB,IAAKA,EAAI,MAAM,IAAI3H,MAAM,mBACzB,MAAkB,iBAAP2H,EAAwBF,EAAYC,EAAKC,EAAG1F,MAAM,MACtC,IAAd0F,EAAGhF,OAAqB+E,EACrBD,EAAYC,EAAIC,EAAG,IAAKA,EAAGzE,MAAM,GAC/C,CAIA,SAAS0E,EAAYF,EAAKlD,EAAO,KAAMqD,GAAc,GACnD,GAAIC,MAAMC,QAAQL,GAChB,OAAOA,EAAIM,KAAI,CAACC,EAAGC,IAAMN,EAAYK,EAAG,KAAMJ,KACzC,GAAmB,iBAARH,GAA4B,OAARA,EAAc,CAClD,IAAIS,EAAS,CAAC,EACd,IAAK,IAAIC,KAAKV,EACZS,EAAOC,GAAKR,EAAYF,EAAIU,GAAIA,EAAGP,GAErC,OAAOM,CACT,CAAO,GAAmB,mBAART,EAAoB,CACpC,GAAIA,EAAI/B,WAAY,CAClB,MAAMwC,EAAS9F,KAAKC,MAAMD,KAAKgG,UAAUX,EAAI/B,aAK7C,GAJInB,IACF2D,EAAO3D,KAAOA,EACdkD,EAAI/B,WAAWnB,KAAOA,GAEpBqD,IACEM,EAAOjD,YAAciD,EAAOjD,WAAWC,mBAClCgD,EAAOjD,WAAWC,WAAoB,QAE3CgD,EAAOjD,YAAciD,EAAOjD,WAAWK,UAAU,CACnD,MAAM+C,EAAeH,EAAOjD,WAAWK,SAASgD,QAAQ,WACpDD,GAAgB,GAClBH,EAAOjD,WAAWK,SAASiD,OAAOF,EAAc,EAEpD,CAEF,MAAO,CAAEzF,KAAM,WAAY4F,SAAUN,EACvC,CAGE,MAAO,CACLtF,KAAM,WACN4F,SAAU,CACRjE,KAJaA,GAAQkD,EAAIlD,MAAQ,YAQzC,CAAO,MAAmB,iBAARkD,EACT,CAAE7E,KAAM,UACS,iBAAR6E,EACT,CAAE7E,KAAM,UACS,kBAAR6E,EACT,CAAE7E,KAAM,WACE,OAAR6E,EACF,CAAE7E,KAAM,QAER,CAAC,CAEZ,CAsIA,MAAM6F,EACJ,WAAAxL,CAAYM,EAASmL,EAAUC,EAAMC,GACnClL,KAAKO,SAAWV,EAChBG,KAAKmL,UAAYH,EACjBhL,KAAKoL,MAAQH,EACbjL,KAAKqL,OAASH,GAAS,QACvBlL,KAAKsL,MAAQ,KACbtL,KAAKuL,SAAU,CACjB,CAEA,KAAAxJ,GACM/B,KAAKuL,QACPvL,KAAKwL,SAELxL,KAAKsL,MAAQlJ,YAAW,KACtBpC,KAAKmL,UAAUM,MAAMzL,KAAMA,KAAKoL,MAAM,GACrB,IAAhBpL,KAAKO,UACRP,KAAKuL,SAAU,EAEnB,CAEA,KAAAG,GACM1L,KAAKsL,OAAStL,KAAKuL,SACrB3B,aAAa5J,KAAKsL,OAClBtL,KAAKsL,MAAQ,KACbtL,KAAKuL,SAAU,GAEf5J,QAAQkD,KAAK,qBAAqB7E,KAAKqL,+BAE3C,CAEA,KAAAG,GACMxL,KAAKsL,OACP1B,aAAa5J,KAAKsL,OAEpBtL,KAAKsL,MAAQlJ,YAAW,KACtBpC,KAAKmL,UAAUM,MAAMzL,KAAMA,KAAKoL,MAAM,GACrB,IAAhBpL,KAAKO,UACRP,KAAKuL,SAAU,CACjB,EAGF,MAAMI,UAAsBzD,QAUrB,MAAM0D,UAAY,KACvB,WAAArM,CACEiH,GACA,UACE/G,EAAY,KAAI,gBAChBkH,EAAkB,KAAI,KACtBE,EAAO,KAAI,OACXgF,EAAS,KAAI,eACbpF,EAAiB,KAAI,wBACrBqF,EAA0B,EAAC,MAC3BC,GAAQ,EAAK,UACbrM,EAAY,KAAI,OAChBsM,GAAS,EAAK,OACdlF,EAAS,KAAI,gBACbC,EAAkB,KAAI,wBACtBkF,EAA0B,OAG5BC,MAAMH,GACN/L,KAAKmM,QAAUN,GAAU,CAAC,GAC1B,QAAOpM,GAAkC,iBAAdA,IAC3B,QAAOA,EAAW,yBAClBO,KAAKG,WAAaV,EAClBO,KAAKoM,MAAQvF,EACb7G,KAAKqM,QAAUvF,GAAU,IACzB9G,KAAKsM,iBAAmB5M,EACxBM,KAAKuM,QAAUP,EACfhM,KAAK2G,gBAAkBA,GAAmB,CAAC,EAC3C3G,KAAKwM,oBAAsB,IAAIC,QAC/BzM,KAAK0M,yBAA2BZ,EAChC9L,KAAK2M,aAAe,CAAC,EACrB3M,KAAK4M,gBAAkBnG,GAAkB,GACzCzG,KAAK6M,iBAAmB9F,EACxB/G,KAAK8M,yBAA2Bb,GA5TjB,OA+TfjM,KAAK+M,UAAY,CAAC,EAClB/M,KAAKgN,cAAgB,CACnBC,SAAUjN,KAAK+M,WAIjB/M,KAAKkN,kBAAoB,IAAIC,IAG7B,MAAMC,EAA4BC,IAChC,MAAMtH,EAASsH,EAAMtH,OACrB,GAAIA,GAA4B,iBAAXA,EAAqB,CAExC,MAAMuH,EAAYvH,EAAOwH,WACzB,GACED,EAAUnI,SAAS,qBACnBmI,EAAUnI,SAAS,sBACnBmI,EAAUnI,SAAS,mBACnBmI,EAAUnI,SAAS,qBAOnB,OALAxD,QAAQoK,MACN,oDACAhG,QAEFsH,EAAMG,gBAGV,CACA7L,QAAQkD,KAAK,mCAAoCkB,EAAO,EAiB1D,GAbsB,oBAAX0H,QAA2BA,OAAOC,6BAIxB,oBAAZC,SACNA,QAAQD,+BAETC,QAAQvF,GAAG,sBAAsB,CAACrC,EAAQuD,KACxC8D,EAAyB,CAAErH,SAAQuD,UAASkE,eAAgB,QAAW,IAEzEG,QAAQD,8BAA+B,IATvCD,OAAOG,iBAAiB,qBAAsBR,GAC9CK,OAAOC,8BAA+B,GAWpClH,EAAY,CACdxG,KAAK6N,YAAY,CACfC,GAAI,WACJ5I,KAAM,WACN2B,KAAM,yBAAyB7G,KAAKsM,oBAAoBtM,KAAKG,aAC7DkG,OAAQ,CACN0H,iBAAiB,EACjBC,WAAY,SACZC,YAAapF,GAEfqF,KAAMlO,KAAKmO,MAAM9G,KAAKrH,MACtBoO,YAAapO,KAAKqO,kBAAkBhH,KAAKrH,MACzCsO,cAAe,CACbC,OAAQvO,KAAKwO,gBAAgBnH,KAAKrH,MAClCyO,OAAQzO,KAAK0O,gBAAgBrH,KAAKrH,MAClCsF,IAAKtF,KAAK2O,aAAatH,KAAKrH,MAC5B2N,QAAS3N,KAAK4O,iBAAiBvH,KAAKrH,MACpC6O,OAAQ7O,KAAK8O,gBAAgBzH,KAAKrH,SAGtCA,KAAKoI,GAAG,SAAUpI,KAAK+O,eAAe1H,KAAKrH,OAC3CA,KAAKoI,GAAG,QAASzG,QAAQwB,QAEzB,QAAOqD,EAAWb,cAAgBa,EAAWrF,aAC7C,aAC4B6N,IAA1BxI,EAAWxF,WACX,mCAEFhB,KAAKiP,cAAgBzI,EAAWb,aAAa0B,KAAKb,GAClDA,EAAWrF,WAAWnB,KAAKkP,YAAY7H,KAAKrH,OAC5CA,KAAKmP,YAAc3I,EACnB,MAAM4I,EAAcjJ,MAAOkJ,IACzB,IAAKrP,KAAKuM,SAAWvM,KAAKmP,YAAYnO,WAAY,CAChDW,QAAQoK,MAAM,iDACd,IAEE,MAAMuD,QAAgBtP,KAAKuP,0BACrBtC,EAAW/E,OAAOsH,OAAOxP,KAAK+M,WAC9B0C,EAAgBxC,EAASjI,OAC/B,IAAI0K,EAAkB,EACtB,MAAMC,EAAiB,GAGjBC,EAA6B5P,KAAK4M,iBAAmB,IAE3D,IAAK,IAAIjF,KAAWsF,EAClB,IACE,MAAM4C,EAAc7P,KAAK8P,sBAAsBnI,SACzC0B,EACJiG,EAAQ7H,gBAAgBoI,GACxBD,EACA,+BAA+BjI,EAAQmG,IAAM,aAE/C4B,IACA/N,QAAQoK,MACN,oCAAoCpE,EAAQmG,IAAM,YAEtD,CAAE,MAAOiC,GACPJ,EAAeK,KAAKrI,EAAQmG,IAAM,WAEhCiC,EAAa3M,SACb2M,EAAa3M,QAAQ+B,SAAS,gBAE9BxD,QAAQwB,MACN,+BAA+BwE,EAAQmG,IAAM,aAG/CnM,QAAQwB,MACN,8BAA8BwE,EAAQmG,IAAM,cAAciC,IAGhE,CAGEL,IAAoBD,EACtB9N,QAAQC,KACN,+BAA+B8N,8BAGjC/N,QAAQkD,KACN,mBAAmB6K,YAA0BD,gDAA4DE,EAAeM,KAAK,SAKjIjQ,KAAKkQ,MAAM,sBAAuB,CAChCC,MAAOV,EACPW,WAAYV,EACZW,OAAQV,IAIV,IACE,GACEL,EAAQgB,WACqB,mBAAtBhB,EAAQgB,UACf,CACA3O,QAAQoK,MAAM,6CAEd,MAAMwE,EAA2BpK,MAAOkH,IAEtC,MAAM/G,EAAW+G,EAAM3H,MAAMoI,IAAMT,EAAMmD,OACnC9Q,EAAY2N,EAAM3H,MAAMhG,UAC9B,GAAI4G,GAAY5G,EAAW,CAEzB,MAAM+Q,EAAe,GAAG/Q,KAAa4G,IACrC3E,QAAQoK,MACN,UAAU0E,8CAENzQ,KAAK0Q,0BAA0BD,EACvC,MAAWnK,IACT3E,QAAQoK,MACN,UAAUzF,8CAENtG,KAAK0Q,0BAA0BpK,GACvC,EAIFtG,KAAK2Q,sCAAwCtH,EAC3CiG,EAAQgB,UAAU,CAAC,wBACnBV,EACA,qDAIF5P,KAAKoI,GAAG,sBAAuBmI,GAE/B5O,QAAQoK,MACN,wDAEJ,MACEpK,QAAQoK,MACN,oFAEF/L,KAAK2Q,gCAAkC,IAE3C,CAAE,MAAOC,GACPjP,QAAQkD,KACN,sDAAsD+L,KAExD5Q,KAAK2Q,gCAAkC,IACzC,CACF,CAAE,MAAOE,GACPlP,QAAQwB,MACN,2DAA2D0N,KAG7D7Q,KAAKkQ,MAAM,+BAAgC,CACzC/M,MAAO0N,EAAatD,WACpBuD,eAAgB5I,OAAO6I,KAAK/Q,KAAK+M,WAAW/H,QAEhD,CACF,CAGIqK,IACEA,EAAerI,kBACjBhH,KAAK6M,iBAAmBwC,EAAerI,iBAEzChH,KAAKkQ,MAAM,YAAab,GAC1B,EAEF7I,EAAWlF,aAAa8N,GACxBA,GACF,MACEpP,KAAKiP,cAAgB,WACnBtN,QAAQqP,IAAI,gCACd,CAEJ,CAEA,cAAAC,CAAe5K,GACb,IAAKA,EAAa,OAAOA,EAAgB,UAAMA,EAAgB,QAC7D,MAAM,IAAIhE,MACR,yFAGF,GAAIgE,EAAOnB,KACT,IAAK,IAAIuF,KAAKvC,OAAO6I,KAAK/Q,KAAKmM,SACzBnM,KAAKmM,QAAQ1B,GAAGvF,OAASmB,EAAOnB,MAAQuF,IAAMpE,EAAOQ,cAChD7G,KAAKmM,QAAQ1B,GACpB9I,QAAQkD,KAAK,4BAA8B4F,IAIjDzK,KAAKmM,QAAQ9F,EAAa,MAAKA,CAEnC,CAEA,WAAM8H,CAAM+C,EAAKC,GAEf,OADA,QAAc,QAAPD,GACA,MACT,CAEA,UAAMhD,CAAKzO,EAAWI,GACpB,IAAI8C,EAAS3C,KAAKoR,wBAAwB,CACxCC,SAAUrR,KAAK6M,iBACfyE,SAAU7R,EACV8R,SAAU,yBACVC,WAAW,EACXC,MAAO,0BAET,QAA0C,cAA5B9O,EAAO,OAAQ9C,GAC/B,CAEA,eAAA2O,CAAgBkD,EAAKC,EAAWC,EAAWT,GACzC,GAAIQ,EAAW,CACb,IAAK3R,KAAKgN,cAAc0E,GACtB,MAAM,IAAIrP,MAAM,mCAAmCqP,KAErD1R,KAAKgN,cAAc0E,GAAY,MAAElG,OACnC,CAKA,GAHKxL,KAAKgN,cAA6B,gBACrChN,KAAKgN,cAA6B,cAAI,CAAC,IAEpC4E,GAAa5R,KAAKgN,cAA6B,cAAE0E,GACpD,MAAM,IAAIrP,MACR,8BAA8BqP,uFAGlC1R,KAAKgN,cAA6B,cAAE0E,GAAO,EAC7C,CAEA,eAAAhD,CAAgBgD,EAAKhM,EAAMiM,EAAWR,GACpC,GAAIQ,EAAW,CACb,IAAK3R,KAAKgN,cAAc0E,GACtB,MAAM,IAAIrP,MAAM,mCAAmCqP,KAErD1R,KAAKgN,cAAc0E,GAAY,MAAElG,OACnC,CACA,MAAMqG,EAAQ7R,KAAKgN,cAA6B,cAChD,IAAK6E,EAAMH,GACT,MAAM,IAAIrP,MAAM,oBAAoBqP,uBAEtC,QAAOhM,aAAgBoD,GACvB+I,EAAMH,GAAK1B,KAAKtK,EAClB,CAEA,YAAAiJ,CAAa+C,EAAKI,EAAOpM,EAAMiM,EAAWR,GACxC,GAAIQ,EAAW,CACb,IAAK3R,KAAKgN,cAAc0E,GACtB,MAAM,IAAIrP,MAAM,mCAAmCqP,KAErD1R,KAAKgN,cAAc0E,GAAY,MAAElG,OACnC,CACA,MAAMqG,EAAQ7R,KAAKgN,cAA6B,cAChD,IAAK6E,EAAMH,GACT,MAAM,IAAIrP,MAAM,oBAAoBqP,uBAEtC,QAAOhM,aAAgBoD,GACvB+I,EAAMH,GAAKI,GAASpM,CACtB,CAEA,eAAAoJ,CAAgB4C,EAAKP,GACnB,MAAMU,EAAQ7R,KAAKgN,cAA6B,cAChD,IAAK6E,EAAMH,GACT,MAAM,IAAIrP,MAAM,oBAAoBqP,6BAE/BG,EAAMH,EACf,CAEA,gBAAA9C,CAAiB8C,EAAKC,EAAWR,GAC/B,GAAIQ,EAAW,CACb,IAAK3R,KAAKgN,cAAc0E,GACtB,MAAM,IAAIrP,MAAM,mCAAmCqP,KAErD1R,KAAKgN,cAAc0E,GAAY,MAAElG,OACnC,CACA,MAAMqG,EAAQ7R,KAAKgN,cAA6B,cAEhD,IADA,UAASmE,EAAS,wBACbU,EAAMH,GACT,MAAM,IAAIrP,MAAM,oBAAoBqP,sBAra1C,IAA4BK,EACtBC,EAGFC,EAGAC,EAgaAL,EAAMH,IAnaNO,GAHED,GADsBD,EAuaQF,EAAMH,IAtaXrH,KAAI,SAAU8H,GACvC,OAAOA,EAAE/I,UACX,KACmCgJ,QAAO,SAAUC,EAAGC,GACrD,OAAOD,EAAIC,CACb,GAAG,GACHJ,EAAW,IAAI9M,WAAW6M,GAC5BD,EAAeI,QAAO,SAAUC,EAAGC,EAAG/H,GAEpC,OADA2H,EAAS5M,IAAI,IAAIF,WAAW2M,EAAQxH,IAAK8H,GAClCA,EAAIC,CACb,GAAG,GACIJ,EAASnO,QA6Zd,IAAIwO,GAAW,QAAYV,EAAMH,IACjC,MAAM,KAAE1N,EAAI,MAAEC,GAAUsO,EAASC,OAC3BC,EAAOxO,EAUb,GARAiE,OAAOC,OAAOsK,EAAM,CAClBpK,KAAM8I,EAAQ9I,KACdqK,GAAIvB,EAAQuB,GACZC,GAAIxB,EAAQwB,GACZC,KAAMzB,EAAQyB,OAEhBH,EAAU,IAAI/N,KAAKC,MAAMD,KAAKgG,UAAU+H,IACxCvK,OAAOC,OAAOsK,EAAU,IAAGzS,KAAK2G,kBAC3B3C,EAAM,CACT,IAAI6O,EAAQN,EAASC,OACrBtK,OAAOC,OAAOsK,EAAMI,EAAM5O,MAC5B,CACAjE,KAAKkQ,MAAMuC,EAAW,KAAGA,UAKlBZ,EAAMH,EACf,CAEA,WAAAxC,CAAY9L,GACV,GAAuB,iBAAZA,EAAsB,CAC/B,MAAMqP,EAAO/N,KAAKC,MAAMvB,GAExBqP,EAAU,IAAI/N,KAAKC,MAAMD,KAAKgG,UAAU+H,IACxCvK,OAAOC,OAAOsK,EAAU,IAAGzS,KAAK2G,iBAChC3G,KAAKkQ,MAAMuC,EAAW,KAAGA,EAC3B,MAAO,GAAIrP,aAAmB0P,aAAeA,YAAYC,OAAO3P,GAAU,CAExE,IAAImP,GAAW,QAAYnP,GAC3B,MAAM,KAAEY,EAAI,MAAEC,GAAUsO,EAASC,OAC3BC,EAAOxO,EAIb,GAFAwO,EAAU,IAAI/N,KAAKC,MAAMD,KAAKgG,UAAU+H,IACxCvK,OAAOC,OAAOsK,EAAU,IAAGzS,KAAK2G,kBAC3B3C,EAAM,CACT,IAAI6O,EAAQN,EAASC,OACrBtK,OAAOC,OAAOsK,EAAMI,EAAM5O,MAC5B,CACAjE,KAAKkQ,MAAMuC,EAAW,KAAGA,EAC3B,KAAO,IAAuB,iBAAZrP,EAMhB,MAAM,IAAIf,MAAM,0BAJhBe,EAAa,IAAIsB,KAAKC,MAAMD,KAAKgG,UAAUtH,IAC3C8E,OAAOC,OAAO/E,EAAa,IAAGpD,KAAK2G,iBACnC3G,KAAKkQ,MAAM9M,EAAc,KAAGA,EAG9B,CACF,CAEA,KAAAoI,GACExL,KAAKgT,gBAAkB,CAAC,EACxBhT,KAAK+M,UAAY,CAAC,CACpB,CAEA,KAAAkG,GAEEjT,KAAKkT,uBAGL,IAAK,MAAMC,KAAcnT,KAAKgN,cAC5B,GAAIhN,KAAKgN,cAAcoG,eAAeD,GAAa,CACjD,MAAME,EAAUrT,KAAKgN,cAAcmG,GAC/BE,GAAWA,EAAQC,gBACrBC,cAAcF,EAAQC,gBAEpBD,GAAWA,EAAQG,OACrBH,EAAQG,MAAM9H,OAElB,CAIF,GAAI1L,KAAK2Q,gCACP,IAEM3Q,KAAKmP,aAAenP,KAAKmP,YAAYnO,YACvChB,KAAKyT,mBAAmB,KAAOzT,KAAKmP,YAAYnO,YAC7C0I,MAAM4F,IACL,GACEA,EAAQoE,aACuB,mBAAxBpE,EAAQoE,YAEf,OAAOpE,EAAQoE,YAAY,sBAC7B,IAED7J,OAAO8J,IACNhS,QAAQoK,MACN,iDAAiD4H,IAClD,IAIP3T,KAAK4T,IAAI,sBACX,CAAE,MAAOD,GACPhS,QAAQoK,MAAM,iDAAiD4H,IACjE,CAIF,IAEE,IAAK,MAAME,KAAQ7T,KAAKkN,kBACtB,GAAI2G,GAA+B,mBAAhBA,EAAKC,OACtB,IACED,EAAKC,QACP,CAAE,MAAOH,GACPhS,QAAQoK,MAAM,oCAAoC4H,IACpD,CAGJ3T,KAAKkN,kBAAkBxB,OACzB,CAAE,MAAOiI,GACPhS,QAAQoK,MAAM,uCAAuC4H,IACvD,CAGA,IAEE3T,KAAKmP,YAAc,KAGnBnP,KAAKiP,cAAgB,WAEnB,OADAtN,QAAQoK,MAAM,2CACP7J,QAAQsH,OAAO,IAAInH,MAAM,wBAClC,CACF,CAAE,MAAOsR,GACPhS,QAAQoK,MAAM,oCAAoC4H,IACpD,CAEA3T,KAAKkQ,MAAM,eACb,CAEA,+BAAMQ,CAA0BpK,GAC9B,IACE3E,QAAQoK,MAAM,sCAAsCzF,KAGpD,MAAMyN,EAAkB/T,KAAKgU,0BAA0B1N,GAEnDyN,EAAkB,GACpBpS,QAAQoK,MACN,cAAcgI,uCAAqDzN,KAKvEtG,KAAKkQ,MAAM,6BAA8B,CACvCzQ,UAAW6G,EACX2N,iBAAkBF,GAEtB,CAAE,MAAOJ,GACPhS,QAAQwB,MACN,2CAA2CmD,MAAaqN,IAE5D,CACF,CAEA,yBAAAK,CAA0B1N,GACxB,IAAIyN,EAAkB,EAGtB,IAAK,MAAMG,KAAchM,OAAO6I,KAAK/Q,KAAKgN,eAAgB,CACxD,GAAmB,aAAfkH,GAA4C,kBAAfA,EAC/B,SAGF,MAAMb,EAAUrT,KAAKgN,cAAckH,GACnC,GAAKb,GAA8B,iBAAZA,GAMnBA,EAAQc,YAAc7N,EAAU,CAElC,GAAI+M,EAAQ7J,QAAoC,mBAAnB6J,EAAQ7J,OAAuB,CAC1D7H,QAAQoK,MAAM,qBAAqBmI,KACnC,IACEb,EAAQ7J,OAAO,IAAInH,MAAM,wBAAwBiE,KACnD,CAAE,MAAOqN,GACPhS,QAAQkD,KAAK,2BAA2BqP,MAAeP,IACzD,CACF,CAEA,GAAIN,EAAQlR,SAAsC,mBAApBkR,EAAQlR,QAAwB,CAC5DR,QAAQoK,MAAM,qBAAqBmI,gBACnC,IACEb,EAAQlR,QAAQ,IAAIE,MAAM,wBAAwBiE,KACpD,CAAE,MAAOqN,GACPhS,QAAQkD,KAAK,2BAA2BqP,MAAeP,IACzD,CACF,CAGA,GAAIN,EAAQG,OAAwC,mBAAxBH,EAAQG,MAAM9H,MACxC,IACE2H,EAAQG,MAAM9H,OAChB,CAAE,MAAOiI,GACPhS,QAAQkD,KAAK,4BAA4BqP,MAAeP,IAC1D,CAIF,GAAIN,EAAQC,eACV,IACEC,cAAcF,EAAQC,eACxB,CAAE,MAAOK,GACPhS,QAAQkD,KAAK,gCAAgCqP,MAAeP,IAC9D,QAIK3T,KAAKgN,cAAckH,GAC1BH,IACApS,QAAQoK,MAAM,uBAAuBmI,IACvC,CACF,CAEA,OAAOH,CACT,CAEA,oBAAAb,GACE,IACEvR,QAAQoK,MAAM,2DAGd,MAAMqI,EAAe,GAErB,IAAK,MAAM1C,KAAOxJ,OAAO6I,KAAK/Q,KAAKgN,eAAgB,CACjD,GAAY,aAAR0E,EACF,SAGF,MAAMzN,EAAQjE,KAAKgN,cAAc0E,GAEjC,GAAqB,iBAAVzN,GAAgC,OAAVA,EAAgB,CAE/C,GAAIA,EAAMuF,QAAkC,mBAAjBvF,EAAMuF,OAC/B,IACEvF,EAAMuF,OAAO,IAAInH,MAAM,yBACzB,CAAE,MAAOsR,GACPhS,QAAQoK,MAAM,2CAA2C4H,IAC3D,CAOF,GAHI1P,EAAMqP,gBACRC,cAActP,EAAMqP,gBAElBrP,EAAMuP,OAAsC,mBAAtBvP,EAAMuP,MAAM9H,MACpC,IACEzH,EAAMuP,MAAM9H,OACd,CAAE,MAAOiI,GACPhS,QAAQoK,MAAM,yBAAyB4H,IACzC,CAEJ,CAGAS,EAAapE,KAAK0B,EACpB,CAGA,IAAK,MAAMA,KAAO0C,SACTpU,KAAKgN,cAAc0E,EAE9B,CAAE,MAAOiC,GACPhS,QAAQwB,MAAM,uCAAuCwQ,IACvD,CACF,CAEA,gBAAM7N,GAEJ,MAAMU,EAAaxG,KAAKmP,YAIxB,GAHAnP,KAAKiT,QAGDzM,EACF,UACQA,EAAWV,YACnB,CAAE,MAAO6N,GACPhS,QAAQoK,MAAM,8CAA8C4H,IAC9D,CAEJ,CAEA,6BAAMpE,CAAwB8E,EAAa,IAGzC,IAAIC,EAAY,KAEhB,IAAK,IAAIC,EAAU,EAAGA,EAAUF,EAAYE,IAC1C,IAKE,aAJkBvU,KAAKyT,mBACrB,KAAKzT,KAAKmP,YAAYnO,qBACtB,CAAEnB,QAAS,GAAIuH,gBAAiB,SAGpC,CAAE,MAAOuM,GAKP,GAJAW,EAAYX,EACZhS,QAAQkD,KACN,0CAA0C0P,EAAU,KAAKF,OAAgBV,EAAEvQ,WAEzEmR,EAAUF,EAAa,EAAG,CAE5B,MAAMhR,EAAQC,KAAKC,IAlBP,IAkBuBD,KAAKE,IAAI,EAAG+Q,GAjBpC,WAkBL,IAAIrS,SAASC,GAAYC,WAAWD,EAASkB,IACrD,CACF,CAIF,MAAMiR,CACR,CAEA,yBAAMnN,CAAoBd,GACxBA,EAASA,GAAU,CAAC,EAMpB,IAAK,IAAIkO,EAAU,EAAGA,EAHH,GAGyBA,IAAW,CACrD,IAAKvU,KAAKmP,YAAYnO,WAAY,CAChC,GAAIuT,EAAUF,GAAgB,CAC5B1S,QAAQkD,KACN,kDAA4D0P,EAAU,eAElE,IAAIrS,SAASC,GAAYC,WAAWD,EAR7B,OASb,QACF,CACE,MAAM,IAAIE,MAAM,2CAEpB,CAEA,IAKE,aAJkBrC,KAAKyT,mBACrB,KAAKzT,KAAKmP,YAAYnO,qBACtBqF,EAGJ,CAAE,MAAOsN,GACP,KAAIY,EAAUF,IAMZ,MAAMV,EALNhS,QAAQkD,KACN,qDAA+D8O,EAAEvQ,iBAE7D,IAAIlB,SAASC,GAAYC,WAAWD,EA1B7B,MA8BjB,CACF,CACF,CAEA,sBAAAqS,GACE,OAAOxU,KAAK+M,SACd,CACA,iBAAAsB,CAAkBoG,EAAYtD,IAC5B,QAAOsD,IACP,QAAOtD,EAAS,uBAEhB,MAAOwB,EAAIlT,GAAa0R,EAAY,GAAE7M,MAAM,MAC5C,QACE7E,IAAcO,KAAKG,WACnB,yCAGF,MAAMwH,EAAU3H,KAAK+M,UAAU0H,GAC/B,IAAK9M,EACH,MAAM,IAAItF,MAAM,sBAAwBoS,GAS1C,GAC+B,UAA7B9M,EAAQtB,OAAO2H,YACc,YAA7BrG,EAAQtB,OAAO2H,WAEf,OAAOrG,EAIT,GAAIwJ,EAAY,KAAMwB,EACpB,OAAOhL,EAIT,MAAM+M,EAAwB/M,EAAQtB,OAAOqO,sBAC7C,GACEA,GACAA,EAAsBvP,SAASgM,EAAY,IAE3C,OAAOxJ,EAGT,MAAM,IAAItF,MACR,oDAAoDoS,0BAAmC9B,QAASxB,EAAY,KAEhH,CACA,wBAAMsC,CAAmBkB,EAAatO,GACpC,IAAI,QAAExG,EAAO,gBAAEuH,EAAe,iBAAEwN,GAAqBvO,GAAU,CAAC,EAChExG,OAAsBmP,IAAZnP,EAAwBG,KAAK4M,gBAAkB/M,GACpD8U,GAAe3U,KAAKmP,YAAYnO,WACnC2T,EAAc,KAAO3U,KAAKmP,YAAYnO,WAC5B2T,EAAYxP,SAAS,OAC/BwP,EAAc3U,KAAKG,WAAa,IAAMwU,GAExC,MAAME,EAAWF,EAAYrQ,MAAM,KAAK,GACxC,IAAImQ,EAAaE,EAAYrQ,MAAM,KAAK,GACxC,GAAImQ,EAAWtP,SAAS,KAAM,CAC5BsP,EAAaA,EAAWnQ,MAAM,KAAK,GACnC,MAAMwC,EAAS6N,EAAYrQ,MAAM,KAAK,GAClCtE,KAAKqM,SAA4B,MAAjBrM,KAAKqM,UACvB,QACEvF,IAAW9G,KAAKqM,QAChB,mBAAmBvF,QAAa9G,KAAKqM,UAE3C,EACA,QAAOwI,EAAU,wBAAwBF,KAEzC,IACE,MAAMhS,EAAS3C,KAAKoR,wBAAwB,CAC1CC,SAAUrR,KAAK6M,iBACfyE,SAAUuD,EACVtD,SAAU,gCACVC,WAAW,EACXC,MAAO,yBAET,IAAIqD,QAAY,QACdnS,EAAO8R,GACP5U,EACA,gDAAkD8U,GAMpD,OAJAG,EAAIhH,GAAK,GAAG+G,KAAYJ,IACpBG,IACFE,GAAM,QAAaA,IAEjB1N,EACKc,OAAOC,OACZ,IAAIwD,GACJ,QAAYmJ,EAAK1N,IAETc,OAAOC,OAAO,IAAIwD,EAAiBmJ,EACjD,CAAE,MAAOnB,GAEP,MADAhS,QAAQkD,KAAK,iCAAmC8P,EAAahB,GACvDA,CACR,CACF,CACA,yBAAAoB,CACEC,EACAC,EACAlH,EACAmH,EACAlH,EACA0G,GAEA,GAAuB,mBAAZM,EAAwB,CAEjC,IAAIG,EAAcF,EAAU3Q,MAAM,KAAK,GACvCtE,KAAKwM,oBAAoBlH,IAAI0P,EAAS,CACpCjH,gBAAiB5D,MAAMC,QAAQ2D,GAC3BA,EAAgB5I,SAASgQ,KACvBpH,EACNmH,gBAAiBA,EACjBE,UAAW,YAAcH,EACzBjH,WAAYA,EACZ0G,sBAAuBA,GAE3B,MAAO,GAAIM,aAAmB7K,OAAS6K,aAAmB9M,OACxD,IAAK,IAAIwJ,KAAOxJ,OAAO6I,KAAKiE,GAAU,CACpC,IAAIK,EAAML,EAAQtD,GAClB,GAAmB,mBAAR2D,GAAsBA,EAAIC,eAAgB,CACnD,IAAI7V,EAAY4V,EAAIC,eAAehE,SAInC,GAHI7R,EAAU0F,SAAS,OACrB1F,EAAYA,EAAU6E,MAAM,KAAK,IAE/BtE,KAAKG,aAAeV,EAWtB,MAAM,IAAI4C,MACR,2BAA2BgT,EAAIC,eAAe/D,gCAAgCvR,KAAKG,iBAAiBV,KAXlGuV,aAAmB7K,QACrB6K,EAAUA,EAAQzP,SAGpByP,EAAQtD,GAAO5H,EACb9J,KAAKgN,cACLqI,EAAIC,eAAe/D,UAErB8D,EAAML,EAAQtD,EAMlB,CACA1R,KAAK+U,0BACHM,EACAJ,EAAY,IAAMvD,EAClB3D,EACAmH,EACAlH,EACA0G,EAEJ,CAEJ,CACA,WAAA7G,CAAY0H,EAAK3D,GACf,IAAK2D,GAAOpL,MAAMC,QAAQmL,GAAM,MAAM,IAAIlT,MAAM,0BAChD,GAAIkT,EAAIhW,cAAgB2I,OACtBqN,EAAMrN,OAAOC,OAAO,CAAC,EAAGoN,OACnB,CACL,MAAMC,EAAU,CAAC,EACXC,EAAQvN,OAAOwN,oBAAoBH,GAAKI,OAC5CzN,OAAOwN,oBAAoBxN,OAAOa,eAAewM,KAEnD,IAAK,IAAI9K,KAAKgL,EACF,gBAANhL,IACoB,mBAAX8K,EAAI9K,GAAmB+K,EAAQ/K,GAAK8K,EAAI9K,GAAGpD,KAAKkO,GACtDC,EAAQ/K,GAAK8K,EAAI9K,IAI1B8K,EAAIzH,GAAKyH,EAAIzH,IAAM,UACnByH,EAAMC,CACR,EACA,QACED,EAAIzH,IAAwB,iBAAXyH,EAAIzH,GACrB,yBAAyByH,KAEtBA,EAAI1O,OACP0O,EAAI1O,KAAO0O,EAAIzH,IAEZyH,EAAIlP,SACPkP,EAAIlP,OAAS,CAAC,GAEXkP,EAAIrQ,OACPqQ,EAAIrQ,KAAO,WAGb,IAAI6I,GAAkB,EACpBmH,GAAkB,EAChBK,EAAIlP,OAAO0H,kBACbA,EAAkBwH,EAAIlP,OAAO0H,iBAC3BwH,EAAIlP,OAAO6O,kBAAiBA,GAAkB,GAClD,MAAMlH,EAAauH,EAAIlP,OAAO2H,YAAc,aAC5C,QAAO,CAAC,YAAa,SAAU,YAAY7I,SAAS6I,IAGpD,MAAM0G,EAAwBa,EAAIlP,OAAOqO,sBACzC,QAA8B1F,IAA1B0F,EAAqC,CACvC,GAAmB,cAAf1G,EACF,MAAM,IAAI3L,MACR,yFAAyF2L,MAG7F,IAAK7D,MAAMC,QAAQsK,GACjB,MAAM,IAAIrS,MACR,2DAGJ,IAAK,MAAMuT,KAASlB,EAClB,GAAqB,iBAAVkB,EACT,MAAM,IAAIvT,MACR,2EAA2EuT,EAInF,CAUA,GATA5V,KAAK+U,0BACHQ,EACAA,EAAQ,GACRxH,EACAmH,EACAlH,EACA0G,GAGE1U,KAAK+M,UAAUwI,EAAIzH,IAAK,CAC1B,IAAI8D,EAGF,MAAM,IAAIvP,MACR,2BAA2BkT,EAAIzH,0CAA0CyH,EAAIzH,gCAHxE9N,KAAK+M,UAAUwI,EAAIzH,GAM9B,CAEA,OADA9N,KAAK+M,UAAUwI,EAAIzH,IAAMyH,EAClBA,CACT,CAEA,qBAAAzF,CAAsBnI,GACpB,MAAMtB,EAASsB,EAAQtB,QAAU,CAAC,EAGlC,GAFAA,EAAO3G,UACL2G,EAAO3G,WAAaM,KAAKsM,kBAAoBtM,KAAKmP,YAAYzP,WAC3D2G,EAAO3G,UACV,MAAM,IAAI2C,MACR,8FAGJ,MAAM6H,EAAc7D,EAAO0H,gBACrB8H,EAAc,CAClB,KACA,SACA,OACA,cACA,OACA,OACA,SACA,kBAEIC,EAAkB,CAAC,EACzB,IAAK,MAAMpE,KAAOxJ,OAAO6I,KAAKpJ,GACvBkO,EAAY1Q,SAASuM,KACxBoE,EAAgBpE,GAAO/J,EAAQ+J,IAGnC,MAAMqE,EAAgB9L,EAAY6L,EAAiB,KAAM5L,GAWzD,MAVoB,CAClB7D,OAAQA,EACRyH,GAAI,GAAGzH,EAAO3G,aAAaM,KAAKG,cAAcwH,EAAY,KAC1Dd,KAAMc,EAAQd,MAAQc,EAAY,GAClCL,YAAaK,EAAQL,aAAe,GACpCpC,KAAMyC,EAAQzC,MAAQ,UACtB8Q,KAAMrO,EAAQqO,MAAQ,KACtBlP,OAAQ9G,KAAKqM,QACb4J,eAAgBF,EAGpB,CAEA,wBAAMG,CAAmBvO,GAEvB,OAAOsC,EAAYtC,EAAS,KADRA,EAAQtB,OAAO0H,gBAErC,CAEA,sBAAMrG,CAAiB6N,EAAKlP,GAC1B,IAEIiJ,GAFA,WAAE6G,EAAU,OAAEC,EAAM,UAAExE,GAAcvL,GAAU,CAAC,EAGnD,GAFA+P,OAAoBpH,IAAXoH,GAA8BA,EAEnCD,GAAcZ,EAAIrQ,KACpB,IACEoK,QAAgBtP,KAAKmH,oBAAoB,CACvCtH,QAAS,GACTuH,gBAAiB,UAGnBmO,EA1qCR,SAA2B5N,EAAS0O,GAClC,SAASC,EAAaC,EAAaC,EAAYC,EAAO,QAEpD,IAAK,IAAI/E,KAAO8E,EACd,IAAKD,EAAYnD,eAAe1B,GAC9B,MAAM,IAAIrP,MAAM,gBAAgBqP,0BAA4B+E,MAKhE,IAAK,IAAI/E,KAAO6E,EACd,GAAY,SAAR7E,IAAmB8E,EAAWpD,eAAe1B,GAC/C,MAAM,IAAIrP,MAAM,mBAAmBqP,0BAA4B+E,KAGrE,CAmDA,OAFAH,EAAa3O,EAAS0O,EAA4B,YA/ClD,SAASK,EAAkBC,EAAYC,EAAYH,EAAO,QACxD,GAA0B,iBAAfE,GAA4BxM,MAAMC,QAAQuM,IAqB9C,GAAIxM,MAAMC,QAAQuM,GAAa,CACpC,GAAIA,EAAW3R,SAAW4R,EAAW5R,OACnC,MAAM,IAAI3C,MAAM,4BAA4BoU,MAE9CE,EAAWE,SAAQ,CAACvM,EAAGC,KACrB,IAAIuM,EAAU,GAAGL,KAAQlM,KACzB,GAAiB,iBAAND,GAAmBH,MAAMC,QAAQE,IAErC,GAAiB,mBAANA,EAAkB,CAClC,IAAIsM,EAAWxD,eAAe7I,GAO5B,MAAM,IAAIlI,MACR,wCAAwCkI,cAAcuM,MAPxDH,EAAWpM,IAAK,OAAeD,EAAG,CAChCzD,KAAM+P,EAAWrM,GAAS,KAC1BjD,YAAasP,EAAWrM,GAAGjD,aAAe,GAC1CC,WAAYqP,EAAWrM,GAAe,YAO5C,OAbEmM,EAAkBpM,EAAGsM,EAAWrM,GAAIuM,EAatC,GAEJ,MA3CkE,CAChER,EAAaK,EAAYC,EAAYH,GACrC,IAAK,IAAIhM,KAAKkM,EAAY,CACxB,IAAIrM,EAAIqM,EAAWlM,GACfqM,EAAU,GAAGL,KAAQhM,IACzB,GAAiB,iBAANH,GAAmBH,MAAMC,QAAQE,IAErC,GAAiB,mBAANA,EAAkB,CAClC,IAAIsM,EAAWxD,eAAe3I,GAO5B,MAAM,IAAIpI,MACR,gCAAgCoI,eAAeqM,MAPjDH,EAAWlM,IAAK,OAAeH,EAAG,CAChCzD,KAAM+P,EAAWnM,GAAS,KAC1BnD,YAAasP,EAAWnM,GAAGnD,aAAe,GAC1CC,WAAYqP,EAAWnM,GAAe,YAO5C,OAbEiM,EAAkBpM,EAAGsM,EAAWnM,GAAIqM,EAcxC,CACF,CAuBF,CAGAJ,CAAkB/O,EAAS0O,EAA4B,YAChD1O,CACT,CAumCcoP,CAAkBxB,QADAjG,EAAQ0H,iBAAiBzB,EAAIrQ,MAEvD,CAAE,MAAOyO,GACP,MAAM,IAAItR,MAAM,8BAA8BkT,EAAIrQ,gBAAgByO,IACpE,CAGF,MAAMhM,EAAU3H,KAAK6N,YAAY0H,EAAK3D,GAChC/B,EAAc7P,KAAK8P,sBAAsBnI,GAC/C,GAAIyO,EACF,IACE9G,EACEA,SACOtP,KAAKmH,oBAAoB,CAC9BtH,QAAS,GACTuH,gBAAiB,gBAEfkI,EAAQ7H,gBAAgBoI,EAChC,CAAE,MAAO8D,GACP,MAAM,IAAItR,MAAM,uCAAuCsR,IACzD,CAEF,OAAO9D,CACT,CAEA,wBAAMoH,CAAmBtP,EAASyO,GAEhC,IAAI3B,EAgBJ,GAjBA2B,OAAoBpH,IAAXoH,GAA8BA,EAGrC3B,EADqB,iBAAZ9M,EACIA,EAEAA,EAAQmG,IAEvB,QACE2G,GAAoC,iBAAfA,EACrB,uBAAuBA,KAErBA,EAAWtP,SAAS,OACtBsP,EAAaA,EAAWnQ,MAAM,KAAK,IAEjCmQ,EAAWtP,SAAS,OACtBsP,EAAaA,EAAWnQ,MAAM,KAAK,KAEhCtE,KAAK+M,UAAU0H,GAClB,MAAM,IAAIpS,MAAM,sBAAsBoS,KAExC,GAAI2B,EAAQ,CACV,MAAM9G,QAAgBtP,KAAKmH,oBAAoB,CAC7CtH,QAAS,GACTuH,gBAAiB,gBAEbkI,EAAQ4H,kBAAkBzC,EAClC,QACOzU,KAAK+M,UAAU0H,EACxB,CAEA,QAAA0C,CAASC,EAAYC,EAAOC,GAC1B,MAAMC,GAAS,QAAkBH,GACjC,GAAIE,GAASA,IAAUC,EACrB,KACE,8CAAgDA,EAAS,OAASD,EAItE,OADAD,EAAQA,GAAS,CAACD,EAAWpS,QACtB,CACLwS,OAAQ,UACRC,QAASL,EAAWrT,OACpB2T,QAASL,EACTM,QAASJ,EAEb,CAEA,gBAAAK,CACE/Q,EACAmE,EACAmI,EACA0E,EACArE,EACAsE,EACAxQ,GAEA,IAAI8N,EAAY,GAAGjC,KAActM,IAC7BkR,EAAU,CACZP,OAAQ,SACRlG,SAAUwG,EACN,GAAGA,KAAmB9X,KAAKG,aAC3BH,KAAKG,WACToR,SAAU6D,EACV5D,WAAW,GAGb,MAAMwG,EAAOhY,KACb,IAAIiY,EAAmB,WACrB,IACEjN,EAASS,MAAM,KAAMtB,MAAM+N,UAAU3S,MAAM4S,KAAKC,WAClD,CAAE,MAAOjV,GACPxB,QAAQwB,MACN,qBAAqBiS,MAAc9N,OAAiBnE,IAExD,CAAE,QAEIqQ,GAASA,EAAMjI,SACjBiI,EAAM9H,QAIJmM,GAAsBG,EAAKhL,cAAcmG,KAE9B,YAATtM,GAA+B,WAATA,SACjBmR,EAAKhL,cAAcmG,GAG1B6E,EAAKK,2BAA2BlF,EAAYtM,GAGlD,CACF,EAEA,OADAoR,EAAiBK,SAAW,YAAYlD,KACjC,CAAC2C,EAASE,EACnB,CAEA,0BAAAI,CAA2BlF,EAAYoF,GAIrC,GAAKpF,EAKL,IACE,MAAMqF,EAAQxY,KAAKyY,mBAAmBtF,GAAY,GAClD,IAAKqF,EAEH,YADA7W,QAAQoK,MAAM,WAAWoH,2BAI3B,IAAIuF,GAAiB,EAGrB,GAAIF,EAAMG,iBACR,IACE,MAAMC,EAAkBJ,EAAMG,iBAE5BC,EAAgBC,4BAChBD,EAAgBC,2BAA2BN,KAEvCK,EAAgBE,QAClBF,EAAgBE,SAElBJ,GAAiB,EACjB/W,QAAQoK,MACN,mBAAmBoH,oCAGzB,CAAE,MAAOQ,GACPhS,QAAQkD,KACN,gDAAgDsO,KAChDQ,EAEJ,MAMqB,YAAlB4E,GAAiD,WAAlBA,IAChCC,EAAMO,YACN7Q,OAAO6I,KAAKyH,EAAMO,YAAY5T,SAASoT,KAEvCG,GAAiB,EACjB/W,QAAQoK,MACN,mBAAmBoH,8BAAuCoF,MAK5DG,GACF1Y,KAAKgZ,4BAA4B7F,EAErC,CAAE,MAAOhQ,GACPxB,QAAQkD,KAAK,oCAAoCsO,KAAehQ,EAClE,MAxDExB,QAAQoK,MAAM,8CAyDlB,CAEA,2BAAAiN,CAA4B7F,GAI1B,IACE,MAAMqF,EAAQxY,KAAKyY,mBAAmBtF,GAAY,GAClD,IAAKqF,EAEH,YADA7W,QAAQoK,MAAM,WAAWoH,wBAK3B,GAAIqF,EAAMhF,OAAsC,mBAAtBgF,EAAMhF,MAAM9H,MACpC,IACE8M,EAAMhF,MAAM9H,OACd,CAAE,MAAOvI,GACPxB,QAAQkD,KACN,oCAAoCsO,KACpChQ,EAEJ,CAGF,GACEqV,EAAMlF,gBACiC,mBAAhCkF,EAAMlF,eAAeQ,OAE5B,IACE0E,EAAMlF,eAAeQ,QACvB,CAAE,MAAO3Q,GACPxB,QAAQkD,KACN,yCAAyCsO,KACzChQ,EAEJ,CAIF,MAAM8V,EAAS9F,EAAW7O,MAAM,KAChC,IAAI4U,EAAgBlZ,KAAKgN,cAGzB,IAAK,IAAIzC,EAAI,EAAGA,EAAI0O,EAAOjU,OAAS,EAAGuF,IAAK,CAC1C,MAAM4O,EAAQF,EAAO1O,GACrB,IAAK2O,EAAcC,GAIjB,YAHAxX,QAAQoK,MACN,gBAAgBoH,wBAAiCgG,KAIrDD,EAAgBA,EAAcC,EAChC,CAGA,MAAMC,EAAYH,EAAOA,EAAOjU,OAAS,GACrCkU,EAAcE,YACTF,EAAcE,GACrBzX,QAAQoK,MAAM,sBAAsBoH,KAGpCnT,KAAKqZ,0BAA0BJ,EAAO1T,MAAM,GAAI,IAEpD,CAAE,MAAOpC,GACPxB,QAAQkD,KACN,yCAAyCsO,KACzChQ,EAEJ,CACF,CAEA,yBAAAkW,CAA0BC,GAIxB,IAEE,IAAK,IAAIC,EAAQD,EAAYtU,OAAS,EAAGuU,GAAS,EAAGA,IAAS,CAC5D,IAAIL,EAAgBlZ,KAAKgN,cAGzB,IAAK,IAAIzC,EAAI,EAAGA,EAAIgP,EAAOhP,IAEzB,GADA2O,EAAgBA,EAAcI,EAAY/O,KACrC2O,EAAe,OAItB,MAAMM,EAAgBF,EAAYC,GAC5BE,EAAYP,EAAcM,GAEhC,IACEC,GACqB,iBAAdA,GAC2B,IAAlCvR,OAAO6I,KAAK0I,GAAWzU,OAQvB,aANOkU,EAAcM,GACrB7X,QAAQoK,MACN,uCAAuCwN,MAAUD,EAAY/T,MAAM,EAAGgU,EAAQ,GAAGtJ,KAAK,OAM5F,CACF,CAAE,MAAO9M,GACPxB,QAAQkD,KAAK,sCAAuC1B,EACtD,CACF,CAEA,iBAAAuW,GAIE,MAAMC,EAAQ,CACZC,eAAgB,EAChBC,iBAAkB,EAClBC,iBAAkB,EAClBC,qBAAsB,EACtBC,wBAAyB,EACzBC,cAAe,CAAC,EAChBC,YAAa,GACbC,aAAc,GAGhB,IAAKna,KAAKgN,cACR,OAAO2M,EAGT,IAAK,MAAMjI,KAAO1R,KAAKgN,cAAe,CACpC,MAAM/I,EAAQjE,KAAKgN,cAAc0E,GAE7B,CAAC,WAAY,iBAAiBvM,SAASuM,GAEzCiI,EAAMM,cAAcvI,GAAO,CACzB0I,KACmB,iBAAVnW,GAAsBA,EAAQiE,OAAO6I,KAAK9M,GAAOe,OAAS,GAMnEf,GAA0B,iBAAVA,GACEiE,OAAO6I,KAAK9M,GAGhBe,OAAS,IACvB2U,EAAMC,iBACND,EAAMO,YAAYlK,KAAK0B,GAEnBzN,EAAM0U,iBACRgB,EAAME,mBAENF,EAAMG,oBAGJ7V,EAAMoW,QAAUpW,EAAMuP,QAAOmG,EAAMI,wBACnC9V,EAAMqW,YAAcrW,EAAM0N,YAC5BgI,EAAMK,0BAGRL,EAAMQ,cAAgBzV,KAAKgG,UAAUzG,GAAOe,OAGlD,CAEA,OAAO2U,CACT,CAEA,2BAAAY,GAIE,IAAKva,KAAKgN,cAER,YADArL,QAAQoK,MAAM,gCAIhB,IAAIyO,EAAgB,EACpB,MAAMC,EAAiB,GAEvB,IAAK,MAAM/I,KAAO1R,KAAKgN,cAErB,IAAK,CAAC,WAAY,iBAAiB7H,SAASuM,GAAM,CAChD,MAAMzN,EAAQjE,KAAKgN,cAAc0E,GAE/BzN,GACiB,iBAAVA,GACPiE,OAAO6I,KAAK9M,GAAOe,OAAS,IAE5ByV,EAAezK,KAAK0B,GACpB8I,IAEJ,CAIF,IAAK,MAAM9I,KAAO+I,SACTza,KAAKgN,cAAc0E,GAG5B/P,QAAQoK,MAAM,qBAAqByO,aACrC,CAGA,uBAAAE,CAAwBC,GACtB,MAAMxH,EAAawH,EAAYrW,MAAM,KAAK,GACpC+O,EAAUrT,KAAKyY,mBAAmBtF,GAAY,GACpD,OAAOE,GAAWA,EAAQsF,gBAC5B,CAGA,uBAAAiC,GAIE,MAAO,CACL/B,2BAA6BN,GACpB,CAAC,UAAW,UAAUpT,SAASoT,GAExCO,OAAQ,KAENnX,QAAQoK,MAAM,kBAAkB,EAGtC,CAEA,qBAAM8O,CACJ1Y,EACAqH,EACA2J,EACA0E,EACArE,EACAsE,EACAxQ,GAEA,IAAIkR,EAAQxY,KAAKyY,mBAAmBtF,GAAY,GAC3CqF,IACH7W,QAAQkD,KACN,kCAAkCsO,yCAEpCqF,EAAQ,CAAC,GAIXA,EAAMG,iBAAmB3Y,KAAK4a,0BAE9B,IAAI7C,EAAU,CAAC,EAmCf,OAjCIvE,GAAShK,GAAUxJ,KAAK4M,kBACzBmL,EAAQpG,UAAW6G,EAAM7G,WAAa3R,KAAK4X,iBAC1C,YACApE,EAAMhI,MAAMnE,KAAKmM,GACjBL,GACA,EACA,KACA2E,GAEFU,EAAMhF,MAAQA,EACduE,EAAQ+C,SAAW9a,KAAK4M,gBAAkB,GAE1C4G,EAAQ,MAGTuE,EAAQ5V,QAASqW,EAAMrW,SAAWnC,KAAK4X,iBACtC,UACAzV,EACAgR,EACA0E,EACArE,EACAsE,EACA,YAAYxQ,OAEbyQ,EAAQvO,OAAQgP,EAAMhP,QAAUxJ,KAAK4X,iBACpC,SACApO,EACA2J,EACA0E,EACArE,EACAsE,EACA,WAAWxQ,MAENyQ,CACT,CAEA,kBAAMgD,CAAarV,EAAMyO,EAAWhB,GAElC,MAAM6H,QAAwBhb,KAAKyT,mBACjC,GAAGU,cAEL,IAAK6G,EAAgB1M,cACnB,MAAM,IAAIjM,MACR,sEAIJ,MAAMiM,EAAgB0M,EAAgB1M,cAChC2M,EAAa9H,IAAc,UAC3B+H,EAAaxV,EAAKV,OAClBmW,EAAanZ,KAAKC,MAClBmZ,EAAY9X,KAAK+X,KAAKH,EAAalb,KAAK8M,0BAC9C,GAAIkO,EAAgB3U,OAAO4H,aAAe,EAAG,OACrCK,EAAcC,OAAO0M,IAAc9H,GACzC,MAAMmI,EAAY,IAAI,KAjvDF,IAmvDdC,EAAQ,GACd,IAAK,IAAIC,EAAM,EAAGA,EAAMJ,EAAWI,IAAO,CACxC,MAAMC,EAAYD,EAAMxb,KAAK8M,yBACvB4O,EAAQhW,EAAKH,MACjBkW,EACAA,EAAYzb,KAAK8M,0BAGb6O,EAASxV,gBACPmI,EAAchJ,IAAI2V,EAAYO,EAAKE,IAASvI,EAAW,EAO/DoI,EAAMvL,KAAKsL,EAAUM,IAAID,GAC3B,CAGA,UACQzZ,QAAQ2Z,IAAIN,EACpB,CAAE,MAAOpY,GAEP,UACQmL,EAAcO,OAAOoM,EAC7B,CAAE,MAAOa,GACPna,QAAQwB,MACN,iDAAiD2Y,IAErD,CACA,MAAM3Y,CACR,CACF,KAAO,OAECmL,EAAcC,OAAO0M,IAAc9H,GACzC,IAAK,IAAIqI,EAAM,EAAGA,EAAMJ,EAAWI,IAAO,CACxC,MAAMC,EAAYD,EAAMxb,KAAK8M,yBACvB4O,EAAQhW,EAAKH,MACjBkW,EACAA,EAAYzb,KAAK8M,gCAEbwB,EAAcG,OAAOwM,EAAYS,IAASvI,EAIlD,CACF,OACM7E,EAAcX,QAAQsN,IAAc9H,KACpBnR,KAAKC,MAAQkZ,GAAc,KAAM1X,QAAQ,EAEjE,CAEA,IAAAsY,CAAKC,EAAcC,GAKjB,IAJA,QAC0B,iBAAjBD,GAA6BA,EAAa9W,KACjD,6DAEG8W,EAAatJ,GAEhB,YADA1S,KAAKkQ,MAAM8L,EAAa9W,KAAM8W,GAGhC,IAAIE,GAAkB,OAAcF,GACpC,GAAIC,EAAY,CACd,MAAMpJ,GAAQ,OAAcoJ,GAC5BC,EAAkB,IAAI9W,WAAW,IAAI8W,KAAoBrJ,GAC3D,CACA,MAAMqI,EAAagB,EAAgBlX,OAInC,OAHIkW,EAAalb,KAAK8M,yBAA2B,MAC/CnL,QAAQkD,KAAK,+BAA+BqW,MAEvClb,KAAKiP,cAAciN,EAC5B,CAEA,uBAAA9K,CACE+K,EACAC,EACAC,EACAC,EACAxE,GAEA,IAAI3D,EAAYgI,EAAe7K,SAC3BgL,IAAqBnI,EAAUhP,SAAS,OAErCgP,EAAUlO,WAAW,QACpBqW,IAAqBnI,IACvBA,EAAYmI,EAAmB,IAAMnI,GAGvCgI,EAAe7K,SAAW6C,IAG9B,IAAIiB,EAAY+G,EAAe5K,SAC3BgL,EAAeJ,EAAe3K,YAAa,EAC/C,MAAMlK,EAAc,WAAW8N,YAAoB+G,EAAe1K,QAC5DuG,EAAOhY,KAEb,SAASwc,IACP,OAAO,IAAIta,SAAQiE,MAAOhE,EAASqH,KACjC,IAAIiT,GAAmB,UACnBJ,IAEFI,EAAmBJ,EAAe,IAAMI,GAE1C,IAAIjE,EAAQR,EAAKS,mBAAmBgE,GAAkB,GACtD,IAAKjE,EAMH,YALAhP,EACE,IAAInH,MACF,8CAA8Coa,eAA8BnV,OAKlFkR,EAAiB,UAAIrE,EACrB,MAAMlJ,QAAa+M,EAAK0E,QACtBvS,MAAM+N,UAAU3S,MAAM4S,KAAKC,WAC3BqE,EACA3E,GAEI6E,EAAY1R,EAAKjG,OAEjB4X,EACJD,EAAY,GACmB,iBAAxB1R,EAAK0R,EAAY,IACA,OAAxB1R,EAAK0R,EAAY,IACjB1R,EAAK0R,EAAY,GAAGE,SAGtB,IAAIC,EAFAF,UAAmB3R,EAAK0R,EAAY,GAAGE,SAMzCC,EAHG9E,EAAK1L,iBAGM0L,EAAK1L,iBAAmB,IAAM0L,EAAK7X,WAFnC6X,EAAK7X,WAKrB,IAAI6b,EAAe,CACjB9W,KAAM,SACNmD,KAAMyU,EACNpK,GAAIyB,EACJxR,OAAQyS,GAEN6G,EAAa,CAAC,EACdhR,IACFgR,EAAiB,KAAIhR,GAEnB2R,IACFX,EAAwB,YAAIW,GAM1BR,IAGFJ,EAAqB,OAAII,GAG3B,IAAI5I,EAAQ,KACZ,GAAI+I,EAAc,CAIhBP,EAAsB,QAAIS,EAC1B,IAAItH,EAAc,GAAGhB,KAAaiB,IAKlC,MAAM2H,EAAkB,SAAUC,GAEhCxT,EAAOwT,GAEHhF,EAAKhL,cAAcyP,YACdzE,EAAKhL,cAAcyP,GAC1B9a,QAAQoK,MACN,sBAAsB0Q,mBAG5B,EAYA,SAASQ,EAAmBlT,GAC1B,SAAKA,GAAsB,iBAARA,MACA,IAAfA,EAAImT,SACJ/S,MAAMC,QAAQL,GACTA,EAAIoT,MAAMC,GAASH,EAAmBG,KAE3CrT,EAAIxK,cAAgB2I,QACfA,OAAOsH,OAAOzF,GAAKoT,MAAMlZ,GAC9BgZ,EAAmBhZ,MAIzB,CAtBAuP,EAAQ,IAAIzI,EACViN,EAAKpL,gBACLmQ,EACA,CAAC,0BAA0B5H,eAAyB7N,KACpD6N,GAoBF,IAAI0C,GAAsBoF,EAAmBhS,GAE7C,MAAMoS,QAAoBrF,EAAK6C,gBAC7B1Y,EACAqH,EACAiT,EACA5E,EACArE,EACAsE,EACAxQ,GAGF,IAAqB,IAAjBiV,EACFN,EAAoB,QAAIoB,MACnB,IAAqB,MAAjBd,EAIT,MAAM,IAAIla,MAAM,6BAA6Bka,KAH7CN,EAAoB,QAAI,IACxBA,EAAc,EAAIjE,EAAKpL,gBAAkB,CAG3C,CACF,CAEA,IAAIsP,GAAkB,OAAcF,GACpC,GAAIC,EAAY,CACd,MAAMpJ,GAAQ,OAAcoJ,GAC5BC,EAAkB,IAAI9W,WAAW,IAAI8W,KAAoBrJ,GAC3D,CACmBqJ,EAAgBlX,QAEnBgT,EAAKlL,yBAA2B,MAC9C0P,EAAcc,aAEdtF,EACG/I,cAAciN,GACdxS,MAAK,WACA8J,GAEFA,EAAMzR,OAEV,IACC8H,OAAM,SAAU0T,GACf,MAAMP,EAAY,mDAAmD7I,KAAaiB,cAAsBmI,IACpG/T,EACFA,EAAO,IAAInH,MAAM2a,IAGjBrb,QAAQkD,KAAK,mCAAoCmY,GAE/CxJ,GACFA,EAAM9H,OAEV,IAGFsM,EACG+C,aAAamB,EAAiB/H,EAAWiI,GACzC1S,MAAK,WACA8J,GAEFA,EAAMzR,OAEV,IACC8H,OAAM,SAAU0T,GACf,MAAMP,EAAY,mDAAmD7I,KAAaiB,cAAsBmI,IACpG/T,EACFA,EAAO,IAAInH,MAAM2a,IAGjBrb,QAAQkD,KAAK,mCAAoCmY,GAE/CxJ,GACFA,EAAM9H,OAEV,GACJ,GAEJ,CAGA8Q,EAAclH,eAAiB6G,EAC/B,MAAMqB,EAAQpI,EAAU9Q,MAAM,KAY9B,OAVAkY,EAAclE,SAAW6D,EAAesB,QAAUD,EAAMA,EAAMxY,OAAS,GACnEwX,EAAclE,SAASnT,SAAS,OAClCqX,EAAclE,SAAWkE,EAAclE,SAAShU,MAAM,KAAK,IAE7DkY,EAAckB,QACZvB,EAAe1K,OAAS,kBAAkB2D,IAC5CoH,EAAcxU,WAAamU,EAAewB,SAE1CnB,EAAcc,aACgB,2CAA5BnB,EAAe5K,SACViL,CACT,CAEA,eAAAoB,GACE,MAAM3Q,EAAW,GACjB,IAAK,IAAItF,KAAWO,OAAOsH,OAAOxP,KAAK+M,WACrCE,EAAS+C,KAAKhQ,KAAK8P,sBAAsBnI,IAG3C,MAAO,CACLmG,GAAI9N,KAAKG,WACT8M,SAAUA,EAEd,CAEA,oBAAM8B,CAAerJ,GACnB,IACI4N,EAAiB,KACrB,KACE,QAAO5N,EAAK/C,QAAU+C,EAAKmY,KAAOnY,EAAK2C,MACvC,MAAM8M,EAAczP,EAAK2C,KAAO,IAAM3C,EAAK/C,OACrC2Z,EAAmB5W,EAAK2C,KAAK/D,MAAM,KAAK,GACxCwZ,EAAmBpY,EAAK2C,KAAK/D,MAAM,KAAK,GAM9C,IAAIwT,EAJJpS,EAAS,GAAIA,EAAS,GAAEP,SAAS,KAC7BO,EAAS,GACT4W,EAAmB,IAAM5W,EAAS,GACtCA,EAAU,IAAM,GAAIA,EAAS,GAExB1F,KAAKsM,kBAGJtM,KAAKsM,kBAA8C,MAA1BtM,KAAKsM,mBAChC,QACE5G,EAAS,GAAEpB,MAAM,KAAK,KAAOtE,KAAKsM,iBAClC,uBACE5G,EAAS,GAAEpB,MAAM,KAAK,GACtB,OACAtE,KAAKsM,kBAGXwL,EAAkB9X,KAAKsM,kBAXvBwL,EAAkBpS,EAAS,GAAEpB,MAAM,KAAK,GAa1C,MAAM+X,EAAe3W,EAAKqY,OAE1B,IAAI5b,EAASqH,EAiCT7G,EA+HAsI,EA/JJ,GAAIvF,EAAK4D,QAAS,CAGhB,MAAMA,QAAgBtJ,KAAKge,QACR,MAAjBtY,EAAK4D,QAAkBtJ,KAAKie,gBAAgBvY,GAAQA,EAAK4D,QACzD5D,EAAK2N,QACLgJ,EACAC,EACAxE,GAIF,GAFA3V,EAAUmH,EAAQnH,QAClBqH,EAASF,EAAQE,OACbF,EAAQqI,WAAarI,EAAQwR,SAAU,CACzC3U,eAAewL,IACb,UAEQrI,EAAQqI,WAChB,CAAE,MAAO4L,GACP5b,QAAQwB,MAAMoa,EAChB,CACF,CAGA,GAFAjK,EAAiB4K,YAAYvM,EAA8B,IAAnBrI,EAAQwR,UAE5CpV,EAAK2N,QAAS,CAChB,MAAM8K,EAAgBne,KAAKyY,mBAAmB/S,EAAK2N,SAAS,GACxD8K,IACFA,EAAc7K,eAAiBA,EAEnC,CACF,CACF,CAIA,IACE3Q,EAASmH,EAAY9J,KAAKgN,cAAetH,EAAa,OACxD,CAAE,MAAOiO,GAEP,GAAI3T,KAAK0a,wBAAwBhV,EAAa,QAI5C,YAHA/D,QAAQoK,MACN,kBAAkBrG,EAAa,8DAAyDyP,KAM5F,MAAMiJ,EAAe1Y,EAAa,OAAEpB,MAAM,KAC1C,GAAI8Z,EAAapZ,OAAS,EAAG,CAC3B,MAAMmO,EAAaiL,EAAa,GAEhC,OAAIjL,KAAcnT,KAAKgN,eACrBrL,QAAQoK,MACN,WAAWoH,uBAAgCzN,EAAa,8CAAyCyP,UAG7E,mBAAX3L,GACTA,EAAO,IAAInH,MAAM,gCAAgC8S,SAInDxT,QAAQoK,MACN,WAAWoH,0BAAmCzN,EAAa,8BAAyByP,UAGhE,mBAAX3L,GACTA,EAAO,IAAInH,MAAM,sBAAsB8S,OAI7C,CAEAxT,QAAQoK,MACN,yBAAyBoJ,QAAkBnV,KAAKG,cAElD,MAAMgD,EAAQ,IAAId,MAChB,qBAAqB8S,QAAkBnV,KAAKG,cAW9C,YATsB,mBAAXqJ,EACTA,EAAOrG,GAGPxB,QAAQkD,KACN,2CACA1B,EAAMC,SAIZ,CAQA,IANA,QACET,GAA4B,mBAAXA,EACjB,mBAAqBwS,GAInBnV,KAAKwM,oBAAoB6R,IAAI1b,IAE/B,GAAwD,cAApD3C,KAAKwM,oBAAoB8R,IAAI3b,GAAQqL,WAEvC,GAAI8J,IAAoBwE,QAInB,GACHtc,KAAKwM,oBAAoB8R,IAAI3b,GAAQ+R,uBACrC1U,KAAKwM,oBACF8R,IAAI3b,GACJ+R,sBAAsBvP,SAASmX,SAK/B,GACkB,MAArBA,GACAwB,IAAqB9d,KAAKmP,YAAYnO,WAItC,MAAM,IAAIqB,MACR,mDACE8S,EACA,yBACA2C,EACA,OACAwE,OAIH,CAEL,IAAIiC,EACFve,KAAKgN,cAActH,EAAK/C,OAAO2B,MAAM,KAAK,IAAI6P,UAQhD,GANE2D,IAAoBwE,GACpBiC,IACoC,IAApCA,EAAkB3T,QAAQ,OAE1B2T,EAAoBzG,EAAkB,IAAMyG,GAE1CA,IAAsB7Y,EAAK2C,KAC7B,MAAM,IAAIhG,MACR,kCACE8S,EACA,UACAzP,EAAK2C,KACL,cACAkW,EAGR,CAsBA,GAnBIlC,IAEF,QACkD,OAAhDrc,KAAKyY,mBAAmB4D,GAAc,GACtC,8BAAgCA,GAKlCpR,EADEvF,EAAKuF,WACMjL,KAAKge,QAChBtY,EAAKuF,KACLvF,EAAK2N,QACL,KACAiJ,EACA,MAGK,GAGPtc,KAAKwM,oBAAoB6R,IAAI1b,IAC7B3C,KAAKwM,oBAAoB8R,IAAI3b,GAAQoL,gBACrC,CAGA,GAAI9C,EAAKjG,OAAS,EAAIrC,EAAOqC,OAC3B,IAAK,IAAIuF,EAAIU,EAAKjG,OAAQuF,EAAI5H,EAAOqC,OAAS,EAAGuF,IAC/CU,EAAK+E,UAAKhB,GAGd/D,EAAK+E,KAAKtK,EAAKmY,IAKjB,CAEA,GAAInY,EAAK4D,QAAS,CAChB,MAAMK,EAAShH,EAAO8I,MAAM,KAAMR,GAC9BtB,aAAkBzH,QACpByH,EACGD,MAAMC,IACLxH,EAAQwH,GACR4J,cAAcD,EAAe,IAE9BzJ,OAAO0T,IACN/T,EAAO+T,GACPhK,cAAcD,EAAe,KAGjCnR,EAAQwH,GACR4J,cAAcD,GAElB,MACE3Q,EAAO8I,MAAM,KAAMR,GACnBsI,cAAcD,EAElB,CAAE,MAAOiK,GAKL5b,QAAQwB,MAAM,gCAAiCoa,GAGjDhK,cAAcD,EAChB,CACF,CAEA,MAAAkL,CAAOxJ,EAAS7B,GACd,OAAOnT,KAAK0c,QAAQ1H,EAAS7B,EAC/B,CAEA,kBAAAsF,CAAmBtF,EAAY5E,GAC7B,IAAK4E,EACH,OAAO,KAET,IAAIqF,EAAQxY,KAAKgN,cACjB,MAAMiM,EAAS9F,EAAW7O,MAAM,KAChC,GAAIiK,EAAQ,CACV,MAAMkQ,EAAaxF,EAAOjU,OAAS,EACnC,IAAK,IAAImU,KAASF,EAAO1T,MAAM,EAAGkZ,GAC3BjG,EAAMW,KAETX,EAAMW,GAAS,CAAC,GAElBX,EAAQA,EAAMW,GAMhB,OAHKX,EAAMS,EAAOwF,MAChBjG,EAAMS,EAAOwF,IAAe,CAAC,GAExBjG,EAAMS,EAAOwF,GACtB,CACE,IAAK,IAAItF,KAASF,EAAQ,CACxB,IAAKT,EAAMW,GACT,OAAO,KAETX,EAAQA,EAAMW,EAChB,CACA,OAAOX,CAEX,CAWA,aAAMkE,CAAQ1H,EAAS7B,EAAY2E,GACjC,MAAM4G,SAAe1J,EACrB,GACY,WAAV0J,GACU,WAAVA,GACU,YAAVA,GAFAA,MAGA1J,GAEAA,aAAmB5P,WAEnB,OAAO4P,EAET,GAAIA,aAAmBlC,YACrB,MAAO,CACL0E,OAAQ,aACRC,QAAS,IAAIrS,WAAW4P,IAI5B,GAAIA,EAAQM,iBACMN,EAAQM,eAAejE,UAAYrR,KAAK6M,oBACxC7M,KAAK6M,iBACnB,OAAOmI,EAAQM,eAQnB,IAAIqJ,EAGJ,GAAI3J,EAAQzV,uBAAuB2I,QAAU8M,EAAQwC,OAAQ,CAE3D,MAAMoH,EAAO5J,EAAQwC,OAIrB,cAHOxC,EAAQwC,OACfmH,QAAgB3e,KAAK0c,QAAQ1H,EAAS7B,EAAY2E,GAClD6G,EAAQnH,OAASoH,EACVD,CACT,CAEA,IAAI,QAAY3J,KAAY,QAAiBA,GAAU,EAErD,QACE7B,GAAoC,iBAAfA,EACrB,iDAEF,MAAM8B,GAAY,UAGZuD,EAAQxY,KAAKyY,mBAAmBtF,GAAY,IAClD,QACY,OAAVqF,EACA,kCAAkCrF,2BAIpC,MAAM0L,GAAU,QAAiB7J,GAG3B8J,EAAiB3Y,UACrB,GAAI0Y,EAAS,CACX,MAAME,EAAW/J,EACXrL,QAAeoV,EAASvM,OAC9B,OAAI7I,EAAO3F,aACFwU,EAAMvD,GACN,CAAEuC,OAAQ,mBAEZ7N,EAAO1F,KAChB,CAAO,CACL,MACM0F,EADWqL,EACOxC,OACxB,OAAI7I,EAAO3F,aACFwU,EAAMvD,GACN,CAAEuC,OAAQ,mBAEZ7N,EAAO1F,KAChB,GAeF,OAXAuU,EAAMvD,GAAa6J,EAGnBH,EAAU,CACRnH,OAAQ,YACRnG,SAAUrR,KAAK6M,iBACfyE,SAAUtR,KAAKG,WACfoR,SAAU,GAAG4B,KAAc8B,IAC3BzD,UAAW,IACXC,MAAO,oBAEFkN,CACT,CAAO,GAAuB,mBAAZ3J,EAAwB,CACxC,GAAIhV,KAAKwM,oBAAoB6R,IAAIrJ,GAAU,CACzC,IAAIgK,EAAahf,KAAKwM,oBAAoB8R,IAAItJ,GAC9C2J,EAAU,CACRnH,OAAQ,SACRnG,SAAUrR,KAAK6M,iBACfyE,SAAUtR,KAAKG,WACfoR,SAAUyN,EAAW5J,UACrB5D,UAAW,IACXiM,OAAQzI,EAAQnO,KAEpB,KAAO,CAEL,IAAIoO,GADJ,QAA6B,iBAAf9B,GAGZ8B,EADED,EAAQsD,SACE,IAAG,aAAYtD,EAAQsD,YAEvB,UAEdqG,EAAU,CACRnH,OAAQ,SACRnG,SAAUrR,KAAK6M,iBACfyE,SAAUtR,KAAKG,WACfoR,SAAU,GAAG4B,KAAc8B,IAC3BzD,UAAW,IACXiM,OAAQzI,EAAQnO,MAElB,IAAI2R,EAAQxY,KAAKyY,mBAAmBtF,GAAY,IAChD,QACY,OAAVqF,EACA,kCAAkCrF,2BAEpCqF,EAAMvD,GAAaD,CACrB,CAEA,GADA2J,EAAQlN,MAAQuD,EAAQ0I,SACnBiB,EAAQlN,MACX,IACE,MAAMwN,EA/yEhB,SAAyBC,GACvB,MAAMC,EAAaD,EAAK3R,WAGlB6R,EAAYD,EAAWE,MAAM,oBAC7BxY,EAAQuY,GAAaA,EAAU,IAAO,GAGtCE,EAAcH,EAAWE,MAAM,eACrC,IAAIE,EAAS,GACTD,IACFC,EAASD,EAAY,GAClBhb,MAAM,KACN+F,KAAKgI,GACJA,EACGnS,QAAQ,eAAgB,IACxBA,QAAQ,WAAY,MAExBsf,QAAQnN,GAAMA,EAAE5N,OAAOO,OAAS,IAChCqF,KAAKgI,GAAMA,EAAE5N,SACbwL,KAAK,OAIV,IAAIwP,EAAWN,EAAWE,MAAM,gCAChC,MAAMK,EAAkBD,GAAYA,EAAS,GAAGhb,QAAW,GAG3Dgb,EAAWN,EAAWE,MAAM,wCAC5B,MAAMM,EACHF,GACCA,EAAS,GACNnb,MAAM,MACN+F,KAAKuV,GAAMA,EAAE1f,QAAQ,WAAY,IAAIuE,SACrCwL,KAAK,OACV,GAEI4P,EAAYH,GAAkBC,EACpC,OACE9Y,GACA0Y,EAAOva,OAAS,GAAK,CACnB6B,KAAMA,EACNiZ,IAAKP,EACLQ,IAAKF,EAGX,CAiwE2BG,CAAgBhL,GAC7BiK,IAAaN,EAAQlN,QACvBkN,EAAQlN,MAAQ,GAAGwN,EAASc,MAEhC,CAAE,MAAOpM,GACPhS,QAAQwB,MAAM,wCAAyC6R,EACzD,CAGF,OADA2J,EAAQhB,SAAW3I,EAAQhN,WACpB2W,CACT,CACA,MAAMsB,EAAU9V,MAAMC,QAAQ4K,GAE9B,IAAK,IAAIkL,KAAMhY,OAAO6I,KAAK/Q,KAAKmM,SAAU,CACxC,MAAMgU,EAAQngB,KAAKmM,QAAQ+T,GAC3B,GAAIC,EAAMC,SAAWpL,aAAmBmL,EAAMjb,KAAM,CAElD,IAAImb,QAAmBne,QAAQC,QAAQge,EAAMC,QAAQpL,IAGrD,GAFIqL,IAAeA,EAAW7I,SAAQ6I,EAAW7I,OAAS2I,EAAMtZ,MAEtC,iBAAfwZ,EAAyB,CAClC,MAAMzB,EAAOyB,EAAW7I,cACjB6I,EAAW7I,OAClB6I,QAAmBrgB,KAAK0c,QACtB2D,EACAlN,EACA2E,GAEFuI,EAAW7I,OAASoH,CACtB,CAEA,OADAD,EAAU0B,EACH1B,CACT,CACF,CAEA,GAEgB,oBAAP2B,IACPA,GAAGC,QACHvL,aAAmBsL,GAAGC,OACtB,CACA,MAAMC,EAAWxL,EAAQyL,WACzB9B,EAAU,CACRnH,OAAQ,UACRC,QAAS,IAAIrS,WAAWob,EAASzc,QACjC2T,QAAS1C,EAAQqC,MACjBM,QAAS3C,EAAQsC,MAErB,MAAO,GAES,oBAAPoJ,IACPA,GAAGC,SACH3L,aAAmB0L,GAAGC,QACtB,CACA,IAAK3L,EAAQ4L,YAAc5L,EAAQ4L,UAAUlb,KAC3C,MAAM,IAAIrD,MAAM,kDAElB,MAAMiV,GAAQ,QAAkBtC,EAAQ4L,UAAUlb,MAClDiZ,EAAU,CACRnH,OAAQ,UACRC,QAAS,IAAIrS,WAAW4P,EAAQ4L,UAAUlb,KAAK3B,QAC/C2T,QAAS1C,EAAQqC,MACjBM,QAASL,EAEb,MAAO,GAAItC,aAAmB3S,MAC5BV,QAAQwB,MAAM6R,GACd2J,EAAU,CACRnH,OAAQ,QACRC,QAASzC,EAAQzH,WACjBsT,QAAS7L,EAAQ8L,YAKhB,GACH9L,IAAY9M,OAAO8M,IACnBA,aAAmB+L,SACnB/L,aAAmBgM,QACnBhM,aAAmBhT,MACnBgT,aAAmBiM,QACG,oBAAdC,WAA6BlM,aAAmBkM,WACnC,oBAAbC,UAA4BnM,aAAmBmM,UACjB,oBAA9BC,2BACNpM,aAAmBoM,2BACY,oBAAzBC,sBACNrM,aAAmBqM,sBACQ,oBAArBC,kBACNtM,aAAmBsM,kBACoB,oBAAjCC,8BACNvM,aAAmBuM,6BAErB5C,EAAU3J,OAEL,GAAIA,aAAmBwM,KAAM,CAClC,IAAIC,EAAe,EACnBtb,eAAejC,EAAKc,GAClB,IAAI0c,EAEFA,EADE1c,EACKgQ,EAAQzP,MAAMkc,EAAcA,EAAezc,GAE3CgQ,EAAQzP,MAAMkc,GAEvB,MAAME,EAAM,IAAIvc,iBAAiBsc,EAAKE,eAEtC,OADAH,GAA8BE,EAAIvY,WAC3BuY,CACT,CACA,SAASE,EAAKC,GACZL,EAAeK,CACjB,CACAnD,EAAU,CACRnH,OAAQ,WACRuK,SAAU,UACV7c,KAAM8P,EAAQ9P,KACd2B,KAAMmO,EAAQnO,KACduT,KAAMpF,EAAQoF,KACd3D,KAAMzB,EAAQgN,OAAShN,EAAQiN,mBAC/B/d,WAAYlE,KAAK0c,QAAQxY,EAAMiP,EAAY2E,GAC3C+J,WAAY7hB,KAAK0c,QAAQmF,EAAM1O,EAAY2E,GAE/C,MAAO,GAAI9C,aAAmBlM,EAAiB,CAC7C,MAAMwO,GAAQ,QAAkBtC,GAChC2J,EAAU,CACRnH,OAAQ,aACRC,QAAS,IAAIrS,WAAW4P,EAAQjR,QAChC4T,QAASL,EAEb,MAAO,GAAItC,aAAmBkN,SAC5BvD,EAAU,CACRnH,OAAQ,aACRC,QAAS,IAAIrS,WAAW4P,EAAQjR,cAE7B,GAAIiR,aAAmB7H,IAC5BwR,EAAU,CACRnH,OAAQ,MACRC,cAAezX,KAAK0c,QAClBvS,MAAM9B,KAAK2M,GACX7B,EACA2E,SAGC,GAAI9C,aAAmBmN,IAC5BxD,EAAU,CACRnH,OAAQ,aACRC,cAAezX,KAAK0c,QAClBvS,MAAM9B,KAAK2M,GACX7B,EACA2E,QAGC,MACL9C,EAAQzV,cAAgB2I,QACxBiC,MAAMC,QAAQ4K,IACdA,aAAmBrJ,GAYnB,KAAM,qCAAqCqJ,kEAX3C,CACA2J,EAAUsB,EAAU,GAAK,CAAC,EAC1B,MAAMlP,EAAO7I,OAAO6I,KAAKiE,GACzB,IAAK,IAAIvK,KAAKsG,EACZ4N,EAAQlU,SAAWzK,KAAK0c,QACtB1H,EAAQvK,GACR0I,EACA2E,EAGN,CAEA,CAEA,IAAK6G,EACH,MAAM,IAAItc,MAAM,2BAElB,OAAOsc,CACT,CAEA,YAAMxa,CAAO6Q,GACX,aAAahV,KAAKge,QAAQhJ,EAC5B,CAEA,aAAMgJ,CACJhJ,EACAoH,EACAC,EACAC,EACAxE,GAEA,IAAK9C,EACH,OAAOA,EAET,IAAI2J,EACJ,GAAI3J,EAAQwC,OACV,GACExX,KAAKmM,QAAQ6I,EAAQwC,SACrBxX,KAAKmM,QAAQ6I,EAAQwC,QAAQ3T,QAC7B,CACA,MAAM+a,EAAO5J,EAAQwC,cACdxC,EAAQwC,QACfxC,QAAgBhV,KAAKge,QACnBhJ,EACAoH,EACAC,EACAC,EACAxE,IAEMN,OAASoH,EAEjBD,QAAgBzc,QAAQC,QACtBnC,KAAKmM,QAAQ6I,EAAQwC,QAAQ3T,QAAQmR,GAEzC,MAAO,GAAuB,WAAnBA,EAAQwC,OACjBmH,EAAU3e,KAAKoR,wBACb4D,EACAoH,EACAC,EACAC,EACAxE,QAEG,GAAuB,cAAnB9C,EAAQwC,OAAwB,CAEzC,MAAM4K,EAAapiB,KAAKoR,wBACtB4D,EACAoH,EACAC,EACAC,EACAxE,GAIF3R,eAAgBkc,IACd,OACE,IACE,MAAMC,QAAkBF,IAExB,GAAIE,GAAkC,mBAArBA,EAAU9K,OACzB,YAEI8K,CACR,CAAE,MAAOnf,GAEP,MADAxB,QAAQwB,MAAM,sBAAuBA,GAC/BA,CACR,CAEJ,CACAwb,EAAU0D,GACZ,MAAO,GAAuB,YAAnBrN,EAAQwC,OAGjB,GAAkB,oBAAPkJ,IAAsBA,GAAG6B,MAC9BpY,MAAMC,QAAQ4K,EAAQyC,WACxBzC,EAAQyC,QAAUzC,EAAQyC,QAAQrF,OAAOpJ,IAE3C2V,EAAU+B,GACP6B,MAAM,IAAIC,MAAMxN,EAAQyC,SAAUzC,EAAQ2C,SAC1C8K,QAAQzN,EAAQ0C,cACd,GAAkB,oBAAP4I,IAAsBA,GAAGC,OAAQ,CAC7CpW,MAAMC,QAAQ4K,EAAQyC,WACxBzC,EAAQyC,QAAUzC,EAAQyC,QAAQrF,OAAOpJ,IAE3C,MAAM0Z,EAAY,KAAkB1N,EAAQ2C,SAC5CgH,EAAU2B,GAAGqC,OACX,IAAID,EAAU1N,EAAQyC,SACtBzC,EAAQ0C,QACR1C,EAAQ2C,QAEZ,MAEEgH,EAAU3J,OAEP,GAAuB,UAAnBA,EAAQwC,OACjBmH,EAAU,IAAItc,MACZ,gBAAkB2S,EAAQyC,QAAU,MAAQzC,EAAQ6L,SAAW,UAE5D,GAAuB,eAAnB7L,EAAQwC,OAAyB,CAC1C,MAAMkL,EAAY,KAAkB1N,EAAQ2C,SAC5C,IAAK+K,EACH,MAAM,IAAIrgB,MAAM,sBAAwB2S,EAAQ2C,SAKlDgH,EAAU,IAAI+D,EAJC1N,EAAQyC,QAAQ1T,OAAOwB,MACpCyP,EAAQyC,QAAQmL,WAChB5N,EAAQyC,QAAQmL,WAAa5N,EAAQyC,QAAQrO,YAGjD,MAAO,GAAuB,eAAnB4L,EAAQwC,OACjBmH,EAAU3J,EAAQyC,QAAQ1T,OAAOwB,MAC/ByP,EAAQyC,QAAQmL,WAChB5N,EAAQyC,QAAQmL,WAAa5N,EAAQyC,QAAQrO,iBAE1C,GAAuB,aAAnB4L,EAAQwC,OAAuB,CACxC,GAAyB,YAArBxC,EAAQ+M,SAAwB,CAClC,MAAM7d,QAAalE,KAAKoR,wBACtB4D,EAAQ9Q,KACRkY,EACAC,EACAC,EACAxE,GAEI+K,QAAc3e,IACpBya,EAAU,IAAI6C,KAAK,CAACqB,GAAQ,CAC1B3d,KAAM8P,EAAQ9P,KACd2B,KAAMmO,EAAQnO,MAElB,KAAO,CACL8X,EAAU,CAAC,EACX,IAAK,IAAIlU,KAAKvC,OAAO6I,KAAKiE,GACnBvK,EAAExE,WAAW,OAChB0Y,EAAQlU,SAAWzK,KAAKge,QACtBhJ,EAAQvK,GACR2R,EACAC,EACAC,EACAxE,GAIR,CACA6G,EAAwB,eAAI3J,CAC9B,MAAO,GAAuB,eAAnBA,EAAQwC,OACjBmH,EAAU,IAAIwD,UACNniB,KAAKge,QACThJ,EAAQyC,QACR2E,EACAC,EACAC,EACAxE,SAGC,GAAuB,QAAnB9C,EAAQwC,OACjBmH,EAAU,IAAIxR,UACNnN,KAAKge,QACThJ,EAAQyC,QACR2E,EACAC,EACAC,EACAxE,QAGC,CACL,MAAM8G,EAAO5J,EAAQwC,cACdxC,EAAQwC,OACfmH,QAAgB3e,KAAKge,QACnBhJ,EACAoH,EACAC,EACAC,EACAxE,GAEF6G,EAAQnH,OAASoH,CACnB,MACK,GAAI5J,EAAQzV,cAAgB2I,QAAUiC,MAAMC,QAAQ4K,GAAU,CACnE,MAAMiL,EAAU9V,MAAMC,QAAQ4K,GAC9B2J,EAAUsB,EAAU,GAAK,CAAC,EAC1B,IAAK,IAAIxV,KAAKvC,OAAO6I,KAAKiE,GACxB,GAAIiL,GAAWjL,EAAQ5B,eAAe3I,GAAI,CACxC,MAAMH,EAAI0K,EAAQvK,GAClBkU,EAAQlU,SAAWzK,KAAKge,QACtB1T,EACA8R,EACAC,EACAC,EACAxE,EAEJ,CAEJ,MACE6G,EAAU3J,EAEZ,QAAgBhG,IAAZ2P,EACF,MAAM,IAAItc,MAAM,2BAElB,OAAOsc,CACT,CAEA,eAAAV,CAAgBvY,GACd,MAAO,CACLiM,UAAW,CACT6F,OAAQ,SACRlG,SAAU5L,EAAK2C,KAAK/D,MAAM,KAAK,GAC/BiN,SAAU7L,EAAK2N,QAAU,aACzB5B,MAAO,kCAAkC/L,EAAK/C,UAEhDR,QAAS,CACPqV,OAAQ,SACRlG,SAAU5L,EAAK2C,KAAK/D,MAAM,KAAK,GAC/BiN,SAAU7L,EAAK2N,QAAU,WACzB5B,MAAO,gCAAgC/L,EAAK/C,UAE9C6G,OAAQ,CACNgO,OAAQ,SACRlG,SAAU5L,EAAK2C,KAAK/D,MAAM,KAAK,GAC/BiN,SAAU7L,EAAK2N,QAAU,UACzB5B,MAAO,+BAA+B/L,EAAK/C,UAE7CmY,SAAUpV,EAAKod,EAEnB,E,0ECp3FK,SAASC,SACd,OAAOzf,KAAK0f,SAASzV,SAAS,IAAI0V,OAAO,EAAG,KAAM,IAAIjhB,MAAOkhB,SAC/D,CAEO,SAASC,YAAYC,GAE1B,OAAKA,EAAIje,SAAS,KAIXie,EAAIljB,QAAQ,OAAQmf,GAAUA,EAAM,GAAGgE,gBAHrCD,CAIX,CAEO,SAASE,YAAYF,GAE1B,OAAOA,EAAIljB,QAAQ,WAAY,OAAOqjB,aACxC,CAEO,SAASC,aAAazZ,GAC3B,GAAmB,iBAARA,GAA4B,OAARA,EAC7B,OAAOA,EAGT,MAAM0Z,EAAStZ,MAAMC,QAAQL,GAAO,GAAK,CAAC,EAE1C,IAAK,MAAM2H,KAAO3H,EAChB,GAAIA,EAAIqJ,eAAe1B,GAAM,CAC3B,MAAMzN,EAAQ8F,EAAI2H,GAEG,mBAAVzN,GACTwf,EAAO/R,GAAO,IAAIzG,KAChB,GAAoB,IAAhBA,EAAKjG,OACP,MAAM,IAAI3C,MAAM,aAAaqP,qCAI/B,MAAMgS,EAAUzY,EAAKA,EAAKjG,OAAS,GACnC,IAAI2e,EAAS,CAAC,EAad,MAVqB,iBAAZD,GACK,OAAZA,GACCvZ,MAAMC,QAAQsZ,KAGfC,EAAS,IAAKD,EAASE,SAAS,GAChC3Y,EAAOA,EAAK1F,MAAM,GAAI,IAIjBtB,KAASgH,EAAM0Y,EAAO,EAI/BF,EAAO/R,GAAK4G,SAAW5G,EACnBzN,EAAM+D,aACRyb,EAAO/R,GAAK1J,WAAa,IAAK/D,EAAM+D,YACpCyb,EAAO/R,GAAK1J,WAAWnB,KAAO6K,IAGhC+R,EAAO/R,GAAO8R,aAAavf,EAE/B,CAGF,OAAOwf,CACT,CAEO,SAASI,YAAY9Z,EAAK+Z,GAC/B,GAAmB,iBAAR/Z,GAA4B,OAARA,IAAiB+Z,EAC9C,OAAO/Z,EAGT,MAAM0Z,EAAStZ,MAAMC,QAAQL,GAAO,GAAK,CAAC,EAE1C,IAAK,MAAM2H,KAAO3H,EAChB,GAAIA,EAAIqJ,eAAe1B,GAAM,CAC3B,MAAMzN,EAAQ8F,EAAI2H,GACZqS,EAAWZ,YAAYzR,GACvBsS,EAAWV,YAAY5R,GAEZ,UAAboS,GACFL,EAAOM,GAAYF,YAAY5f,EAAO6f,GACjB,mBAAV7f,IACTwf,EAAOM,GAAUzL,SAAWyL,EACxB9f,EAAM+D,aACRyb,EAAOM,GAAU/b,WAAa,IAAK/D,EAAM+D,YACzCyb,EAAOM,GAAU/b,WAAWnB,KAAOkd,KAGjB,UAAbD,GACTL,EAAOO,GAAYH,YAAY5f,EAAO6f,GACjB,mBAAV7f,IACTwf,EAAOO,GAAU1L,SAAW0L,EACxB/f,EAAM+D,aACRyb,EAAOO,GAAUhc,WAAa,IAAK/D,EAAM+D,YACzCyb,EAAOO,GAAUhc,WAAWnB,KAAOmd,MAKnCF,EAAS3e,SAAS,WACpBse,EAAOM,GAAYF,YAAY5f,EAAO,UAEpC6f,EAAS3e,SAAS,WACpBse,EAAOO,GAAYH,YAAY5f,EAAO,UAG5C,CAGF,OAAOwf,CACT,CAEO,SAASQ,gBAAgB1hB,GAE9BA,EAAMA,EAAIrC,QAAQ,MAAO,IAGzB,MAAMgkB,EAAU,IAAIjD,OAClB,kJAQI5B,EAAQ9c,EAAI8c,MAAM6E,GACxB,IAAK7E,EACH,MAAM,IAAIhd,MAAM,2CAGlB,MAAMkE,EAAY8Y,EAAM,GAClB3f,EAAY2f,EAAM,GAClB/Y,EAAW+Y,EAAM8E,QAAQ7d,UAAY,IACrCmC,EAAY4W,EAAM8E,QAAQ1b,UAGhC,MAAO,CAAElC,YAAW7G,YAAW4G,WAAUmC,YAAWC,MAFtC2W,EAAM8E,QAAQzb,OAAS,IAGvC,C,kTAEO,MAAM0b,kBAAoB,CAC/BC,KAAMC,UACNC,MAAOC,WACPC,MAAOC,WACPC,MAAOvf,WACPwf,OAAQC,YACRC,OAAQC,YACRC,QAASC,aACTC,QAASC,aACT5C,MAAOpY,OAGFhE,eAAeif,yBAAyBC,GAC7C,SAASC,EAAc/iB,GAIrB,OAAO,IAAIL,SAAQ,CAACC,EAASqH,KAC3B,IAAI+b,EAAYC,SAASC,cAAc,UACvCF,EAAUG,IAAMnjB,EAChBgjB,EAAUrgB,KAAO,kBACjBqgB,EAAUI,OAASxjB,EACnBojB,EAAUK,mBAAqB,WACL,WAApB5lB,KAAK6lB,YAA+C,aAApB7lB,KAAK6lB,YACvC1jB,GAEJ,EACAojB,EAAUO,QAAUtc,EACpBgc,SAASO,KAAKC,YAAYT,EAAU,GAExC,CAGApf,eAAe8f,IAIb,IAHA,IAAIhb,EAAOd,MAAM+N,UAAU3S,MAAM4S,KAAKC,WACpC8N,EAAMjb,EAAKjG,OACXuF,EAAI,EACCA,EAAI2b,EAAK3b,UACR+a,EAAcra,EAAKV,GAE7B,CAEA,GACE8a,IACClb,MAAMC,QAAQib,IAAyC,iBAAjBA,GAEvC,IACE,IAAIc,EAGJ,GAFAd,EAC0B,iBAAjBA,EAA4B,CAACA,GAAgBA,GAClDlb,MAAMC,QAAQib,GAuChB,KAAM,sCAtCN,IAAK,IAAI9a,EAAI,EAAGA,EAAI8a,EAAargB,OAAQuF,IAErC8a,EAAa9a,GAAGgZ,cAAcrd,SAAS,SACvCmf,EAAa9a,GAAGtE,WAAW,SAEvBof,EAAa9a,GAAGtE,WAAW,UAC7Bof,EAAa9a,GAAK8a,EAAa9a,GAAGhF,MAAM,KAE1C4gB,EAAYX,SAASC,cAAc,SACzBW,IAAM,aAChBD,EAAUE,KAAOhB,EAAa9a,GAC9Bib,SAASO,KAAKC,YAAYG,IAE1Bd,EAAa9a,GAAGgZ,cAAcrd,SAAS,SACvCmf,EAAa9a,GAAGtE,WAAW,SAGvBof,EAAa9a,GAAGtE,WAAW,UAC7Bof,EAAa9a,GAAK8a,EAAa9a,GAAGhF,MAAM,UAEpC+gB,OAAiCjB,EAAa9a,KAEpD8a,EAAa9a,GAAGgZ,cAAcrd,SAAS,QACvCmf,EAAa9a,GAAGtE,WAAW,QAEvBof,EAAa9a,GAAGtE,WAAW,SAC7Bof,EAAa9a,GAAK8a,EAAa9a,GAAGhF,MAAM,UAEpC0gB,EAAcZ,EAAa9a,KACxB8a,EAAa9a,GAAGtE,WAAW,cAC9BggB,EAAcZ,EAAa9a,IACxB8a,EAAa9a,GAAGtE,WAAW,WAGpCtE,QAAQqP,IAAI,iCAAmCqU,EAAa9a,GAMpE,CAAE,MAAOoJ,GACP,KAAM,sCAAwC0R,EAAa9X,UAC7D,CAEJ,CAEOpH,eAAeogB,4BAA4BlB,GAChD,GACEA,IACClb,MAAMC,QAAQib,IAAyC,iBAAjBA,GAEvC,IACOlb,MAAMC,QAAQib,KACjBA,EAAe,CAACA,IAElB,IAAK,IAAI9a,EAAI,EAAGA,EAAI8a,EAAargB,OAAQuF,IAAK,CAC5C,GACE8a,EAAa9a,GAAGgZ,cAAcrd,SAAS,SACvCmf,EAAa9a,GAAGtE,WAAW,QAE3B,KAAM,sCAENof,EAAa9a,GAAGgZ,cAAcrd,SAAS,QACvCmf,EAAa9a,GAAGtE,WAAW,QAEvBof,EAAa9a,GAAGtE,WAAW,SAC7Bof,EAAa9a,GAAK8a,EAAa9a,GAAGhF,MAAM,IAE1C0gB,cAAcZ,EAAa9a,KAClB8a,EAAa9a,GAAGtE,WAAW,QACpCggB,cAAcZ,EAAa9a,IAClB8a,EAAa9a,GAAGtE,WAAW,WAGpCtE,QAAQqP,IAAI,iCAAmCqU,EAAa9a,GAEhE,CACF,CAAE,MAAOoJ,GACP,KAAM,sCAAwC0R,EAAa9X,UAC7D,CAEJ,CAEO,SAASiZ,iBAAiBnB,GAC/B,MAC+B,oBAAtBoB,mBACPzO,gBAAgByO,kBAETF,4BAA4BlB,GAE5BD,yBAAyBC,EAEpC,CAEO,SAASqB,gBAAgBrgB,GAa9B,OAZAA,EAAOsgB,QAAUtgB,EAAOsgB,SAAW,QACnCtgB,EAAOiB,YACLjB,EAAOiB,aAAe,8BAA8BjB,EAAOQ,SAC7DR,EAAOnB,KAAOmB,EAAOnB,MAAQ,aAC7BmB,EAAOyH,GAAKzH,EAAOyH,IAAMiV,SACzB1c,EAAOugB,cAAgBvgB,EAAOugB,eAAiB,IAC/CvgB,EAAOwgB,gBAAkBxgB,EAAOwgB,kBAAmB,EAEnDxgB,EAAS6B,OAAO6I,KAAK1K,GAAQ+L,QAAO,CAACC,EAAGC,KACb,mBAAdjM,EAAOiM,KAAmBD,EAAEC,GAAKjM,EAAOiM,IAC5CD,IACN,CAAC,EAEN,CACO,MAAMyU,yBAA2B,CACtCxC,UAAW,OACXE,WAAY,QACZE,WAAY,QACZtf,WAAY,QACZyf,YAAa,SACbE,YAAa,SACbE,aAAc,UACdE,aAAc,UACdhb,MAAO,SAGH4c,sBAAwB,GAC9B,IAAK,MAAMC,WAAW9e,OAAO6I,KAAK+V,0BAChCC,sBAAsB/W,KAAKiX,KAAKD,UAG3B,SAASE,kBAAkBnd,GAChC,IAAIuN,EAAQwP,yBAAyB/c,EAAIxK,YAAYsH,MACrD,IAAKyQ,EAAO,CACV,MAAM6P,EAAKjf,OAAOa,eAAegB,GACjC,IAAK,MAAMid,KAAWD,sBACpB,GAAII,aAAcH,EAAS,CACzB1P,EAAQwP,yBAAyBE,EAAQngB,MACzC,KACF,CAEJ,CACA,OAAOyQ,CACT,CAEA,SAAS8P,wBAAwB7kB,GAC/B,OAAO,IAAIL,SAAQ,SAAUC,EAASqH,GACpC,MAAMpG,EAAU,CACdikB,QAAS,MACT9kB,IAAKA,GAEP,IAAK+kB,UAAUC,gBAAkBD,UAAUC,cAAcC,SAEvD,YADAhe,EAAO,oCAGT,MAAMie,EAAiB,IAAIC,eAC3BD,EAAeE,MAAMC,UAAY,SAAUva,GACrCA,EAAM3H,MAAQ2H,EAAM3H,KAAKvC,MAC3BqG,EAAO6D,EAAM3H,KAAKvC,OAElBhB,EAAQkL,EAAM3H,MAAQ2H,EAAM3H,KAAKiE,OAErC,EAEI2d,UAAUC,eAAiBD,UAAUC,cAAcM,WACrDP,UAAUC,cAAcM,WAAWC,YAAY1kB,EAAS,CACtDqkB,EAAeM,QAGjBve,EAAO,6CAEX,GACF,CAEOrD,eAAe6hB,kBAAkB3C,GACtCA,EAAeA,GAAgB,GAC1Blb,MAAMC,QAAQib,KACjBA,EAAe,CAACA,IAElB,IAAK,IAAI4C,KAAO5C,EAEV4C,EAAIhiB,WAAW,SAAQgiB,EAAMA,EAAI1iB,MAAM,IACvC0iB,EAAIhiB,WAAW,UAASgiB,EAAMA,EAAI1iB,MAAM,IACxC0iB,EAAIhiB,WAAW,YAAWgiB,EAAMA,EAAI1iB,MAAM,IACzC0iB,EAAIhiB,WAAW,eAEdmhB,wBAAwBa,GAAKpe,OAAO8J,IACxChS,QAAQwB,MAAMwQ,EAAE,GAGtB,CAEO,SAASuU,OAAOC,EAAW/kB,GAChC,IAAK+kB,EACH,MAAM,IAAI9lB,MAAMe,GAAW,mBAE/B,CAGO,SAASglB,WAAWnd,GACzB,OAAOA,EACJgF,KAAK,KACL/P,QAAQ,SAAU,KAClBA,QAAQ,WAAY,SACpBA,QAAQ,SAAU,UAClBA,QAAQ,kBAAmB,MAC3BA,QAAQ,MAAO,KACfA,QAAQ,IAAK,IAClB,CAEO,SAAS+G,QAAQohB,EAAMC,EAAMnlB,GAClC,IAAIqQ,EACJ,OAAOtR,QAAQqmB,KAAK,CAClBF,EACA,IAAInmB,SACF,CAACsmB,EAAIC,IACFjV,EAAQpR,YAAW,KAClBqmB,EAAItlB,GAAS,gBAAgB,GACrB,IAAPmlB,OAENI,SAAQ,IAAM9e,aAAa4J,IAChC,CAEO,MAAMmV,eACX,WAAAppB,CAAYwM,GACV/L,KAAKgT,gBAAkB,CAAC,EACxBhT,KAAK4oB,eAAiB,CAAC,EACvB5oB,KAAK6oB,OAAS9c,CAChB,CACA,IAAAgQ,GACE,MAAM,IAAI1Z,MAAM,0BAClB,CACA,EAAA+F,CAAGiF,EAAOjM,GACHpB,KAAKgT,gBAAgB3F,KACxBrN,KAAKgT,gBAAgB3F,GAAS,IAEhCrN,KAAKgT,gBAAgB3F,GAAO2C,KAAK5O,EACnC,CACA,IAAA0nB,CAAKzb,EAAOjM,GACVA,EAAQ2nB,mBAAoB,EAC5B/oB,KAAKoI,GAAGiF,EAAOjM,EACjB,CACA,GAAAwS,CAAIvG,EAAOjM,GACT,GAAKiM,GAAUjM,GAGR,GAAIiM,IAAUjM,EAEfpB,KAAKgT,gBAAgB3F,KAAQrN,KAAKgT,gBAAgB3F,GAAS,SAG/D,GAAIrN,KAAKgT,gBAAgB3F,GAAQ,CAC/B,MAAMmO,EAAMxb,KAAKgT,gBAAgB3F,GAAOzC,QAAQxJ,GAC5Coa,GAAO,GACTxb,KAAKgT,gBAAgB3F,GAAOxC,OAAO2Q,EAAK,EAE5C,OAXAxb,KAAKgT,gBAAkB,CAAC,CAa5B,CACA,KAAA9C,CAAM7C,EAAO3H,GACX,GAAI1F,KAAKgT,gBAAgB3F,GAEvB,IADA,IAAI9C,EAAIvK,KAAKgT,gBAAgB3F,GAAOrI,OAC7BuF,KAAK,CACV,MAAMnJ,EAAUpB,KAAKgT,gBAAgB3F,GAAO9C,GAC5C,IACEnJ,EAAQsE,EACV,CAAE,MAAOiO,GACPhS,QAAQwB,MAAMwQ,EAChB,CAAE,QACIvS,EAAQ2nB,mBACV/oB,KAAKgT,gBAAgB3F,GAAOxC,OAAON,EAAG,EAE1C,CACF,MAEIvK,KAAK6oB,QACPlnB,QAAQkD,KAAK,kBAAmBwI,EAAO3H,EAG7C,CAEA,OAAAuB,CAAQoG,EAAOxN,GACb,OAAO,IAAIqC,SAAQ,CAACC,EAASqH,KAC3B,MAAMpI,EAAWsE,IACfkE,aAAa4J,GACbrR,EAAQuD,EAAK,EAEf1F,KAAK8oB,KAAKzb,EAAOjM,GACjB,MAAMoS,EAAQpR,YAAW,KACvBpC,KAAK4T,IAAIvG,EAAOjM,GAChBoI,EAAO,IAAInH,MAAM,WAAW,GACjB,IAAVxC,EAAe,GAEtB,EAGK,MAAMmpB,UACX,WAAAzpB,CAAY0pB,GACVjpB,KAAKipB,IAAMA,EACXjpB,KAAKkpB,MAAQ,GACblpB,KAAKmpB,QAAU,CACjB,CACA,SAAMvN,CAAI/H,GACJ7T,KAAKmpB,SAAWnpB,KAAKipB,WAEjB,IAAI/mB,SAASC,GAAYnC,KAAKkpB,MAAMlZ,KAAK7N,KAEjDnC,KAAKmpB,UACL,IACE,aAAatV,GACf,CAAE,QACA7T,KAAKmpB,UACDnpB,KAAKkpB,MAAMlkB,OAAS,GAEtBhF,KAAKkpB,MAAME,OAAXppB,EAEJ,CACF,EAQK,SAASqpB,YAAYtf,GAC1B,QAAKA,GAGY,iBAARA,GACa,mBAAbA,EAAIyI,MACU,mBAAdzI,EAAIuf,OACW,mBAAfvf,EAAIwf,MAEf,CAOO,SAASC,iBAAiBzf,GAC/B,QAAKA,GAGY,iBAARA,GACa,mBAAbA,EAAIyI,MACU,mBAAdzI,EAAIuf,OACW,mBAAfvf,EAAIwf,QACXE,OAAOC,iBAAiBxhB,OAAO6B,IACH,mBAA5BA,EAAI0f,OAAOE,YAEf,C,8CCzhBO,MAAMC,EAAI,CACfC,OAASriB,IAAe,CACtBtC,KAAM,SACNsC,aACAI,SAAUM,OAAO6I,KAAKvJ,GAAYgY,QAC/B9N,IAASlK,EAAWkK,GAAKoY,cAI9BC,OAAQ,KAAM,CAAG7kB,KAAM,SAAU4kB,WAAW,IAC5CE,OAAQ,KAAM,CAAG9kB,KAAM,SAAU4kB,WAAW,IAC5CG,QAAS,KAAM,CAAG/kB,KAAM,UAAW4kB,WAAW,IAC9CI,QAAS,KAAM,CAAGhlB,KAAM,UAAW4kB,WAAW,IAC9CvH,MAAQ4H,IAAU,CAAGjlB,KAAM,QAASilB,QAAOL,WAAW,IAGtDM,SAAW5f,IAAW,IAAMA,EAAQsf,WAAW,KAe1C,SAASO,EACdnL,GACA,YAAEoL,EAAc,OAAM,KAAEzjB,EAAO,KAAI,YAAES,EAAc,KAAI,WAAEC,EAAa,OAEtE,IAAK2X,GAAwB,mBAATA,EAClB,MAAM7c,MAAM,8BAEd,QAAuB,SAAhBioB,EAAwB,8BAG/B,MAAMC,EAAW1jB,GAAQqY,EAAKrY,MAC9B,QAAO0jB,EAAU,2BAGjB,IAAIC,EAAsBjjB,EAC1B,GACEA,GACsB,iBAAfA,GACa,WAApBA,EAAWrC,KACX,CACAslB,EAAsB,CACpBtlB,KAAM,SACNsC,WAAYD,EAAWC,YAAc,CAAC,EACtCI,SAAUL,EAAWK,UAAY,IAInC,IAAK,MAAO8J,EAAKlH,KAAWtC,OAAOuiB,QACjCD,EAAoBhjB,iBAEKwH,IAArBxE,EAAOsf,kBACFtf,EAAOsf,SAGpB,CAYA,OAVA,QACEU,GAAoD,WAA7BA,EAAoBtlB,KAC3C,yCAGFga,EAAKlX,WAAa,CAChBnB,KAAM0jB,EACNjjB,YAAaA,GAAe,GAC5BC,WAAYijB,GAEPtL,CACT,CA1DA,CAAC,SAAU,SAAU,UAAW,UAAW,SAASrI,SAAS3R,IAC3D0kB,EAAE1kB,GAAQ,KACR,MAAMsF,EAAS,CACbtF,KAAe,YAATA,EAAqB,UAAYA,EACvC4kB,WAAW,EAEbtf,SAAmBlD,IAAgB,IAAMkD,EAAQlD,iBACjD,OAAOkD,CAAM,CACd,G,wEC3BH,MAAMkgB,EACJ,WAAAnrB,CAAYorB,GACV3qB,KAAK4qB,cAAgBD,EACrB3qB,KAAKU,gBAAkB,KACvBV,KAAKM,oBAAsB,KAC3BN,KAAKW,qBAAuB,KAC5BX,KAAKY,kBAAoB,OACzBZ,KAAKgB,WAAa,KAClBhB,KAAK6qB,cAAgB,KACrB7qB,KAAK4qB,cAAcE,OAAS3kB,UACtBnG,KAAK6qB,gBACPlpB,QAAQC,KAAK,uDACb5B,KAAK4qB,cAAcG,KAAK/qB,KAAK6qB,eAC7B7qB,KAAK6qB,cAAgB,MAEvB7qB,KAAKY,mBACHZ,KAAKY,kBAAkB,CAAE+pB,QAAS3qB,KAAK4qB,eAAgB,EAE3D5qB,KAAK4qB,cAAchD,UAAYzhB,MAAOkH,IACpC,IAAI3H,EAAO2H,EAAM3H,KACbA,aAAgB8b,OAClB9b,QAAaA,EAAKkc,eAEpB5hB,KAAKU,gBAAgBgF,EAAK,EAE5B,MAAMsS,EAAOhY,KACbA,KAAK4qB,cAAcI,QAAU,WACvBhrB,KAAKW,sBAAsBX,KAAKW,qBAAqB,UACzDgB,QAAQqP,IAAI,oBACZgH,EAAK4S,cAAgB,IACvB,CACF,CAEA,eAAAvpB,CAAgBD,GACdpB,KAAKW,qBAAuBS,CAC9B,CAEA,YAAAE,CAAaF,GACXpB,KAAKY,kBAAoBQ,CAC3B,CAEA,UAAAD,CAAWC,IACT,QAAOA,EAAS,uBAChBpB,KAAKU,gBAAkBU,CACzB,CAEA,kBAAMuE,CAAaD,IACjB,QAAO1F,KAAKU,gBAAiB,0BAC7B,IACEV,KAAK6qB,cAAgBnlB,EACrB1F,KAAK4qB,cAAcG,KAAKrlB,GACxB1F,KAAK6qB,cAAgB,IACvB,CAAE,MAAOI,GAEP,MADAtpB,QAAQwB,MAAM,+BAA+B8nB,KACvCA,CACR,CACF,CAEA,gBAAMnlB,CAAWC,GACf/F,KAAK6qB,cAAgB,KACrB7qB,KAAK4qB,cAAgB,KACrBjpB,QAAQC,KAAK,yCAAyCmE,KACxD,EAGFI,eAAe+kB,EAAU7kB,IACvB,QAAOA,EAAOskB,QAAS,wBACvB,QAAOtkB,EAAO3G,UAAW,yBACzB,MAAMirB,EAAUtkB,EAAOskB,QACjBrkB,EAAWD,EAAO5G,YAAa,UAC/B+G,EAAa,IAAIkkB,EAAiBC,GAaxC,OAZAtkB,EAAO8K,QAAU9K,EAAO8K,SAAW,CAAC,EACpC9K,EAAO8K,QAAQvK,gBAAkB,SACjCP,EAAO8K,QAAQwB,GAAKtM,EAAO3G,UACf,IAAI,IAAI8G,EAAY,CAC9B/G,UAAW6G,EACXK,gBAAiBN,EAAO8K,QACxBtK,KAAMR,EAAOQ,KACbJ,eAAgBJ,EAAOI,gBAAkB,GACzC/G,UAAW2G,EAAO3G,UAClBoH,OAAQT,EAAOS,OACfmF,wBAAyB5F,EAAO4F,yBAGpC,CA+DA9F,eAAeglB,EAAcviB,EAAQ6L,EAAYpO,IAC/CA,EAASA,GAAU,CAAC,GACb+kB,QAAU/kB,EAAO+kB,UAAW,UAEnC,MAAMC,EAAK,IAAIC,kBAAkB,CAC/BC,WAAYllB,EAAOmlB,aAAe,CAChC,CAAEC,KAAM,CAAC,kCAEXC,aAAc,iBAGhB,OAAO,IAAIxpB,SAAQiE,MAAOhE,EAASqH,KACjC,IAAImiB,GAAW,EACf,MAAM9rB,EAAUuC,YAAW,KACpBupB,IACHA,GAAW,EACXN,EAAGpY,QACHzJ,EAAO,IAAInH,MAAM,8BACnB,GACC,KAEH,IACEgpB,EAAGzd,iBACD,yBACA,KACEjM,QAAQqP,IAAI,4BAA6Bqa,EAAGO,iBACjB,WAAvBP,EAAGO,gBACAD,IACHA,GAAW,EACX/hB,aAAa/J,GACbwrB,EAAGpY,QACHzJ,EAAO,IAAInH,MAAM,8BAEa,WAAvBgpB,EAAGO,gBACPD,IACHA,GAAW,EACX/hB,aAAa/J,GACb2J,EAAO,IAAInH,MAAM,8BAEa,cAAvBgpB,EAAGO,iBACZjqB,QAAQqP,IAAI,6CACd,IAEF,GAIFqa,EAAGzd,iBAAiB,4BAA4B,KAC9CjM,QAAQqP,IAAI,yBAA0Bqa,EAAGQ,oBACX,WAA1BR,EAAGQ,qBACAF,IACHA,GAAW,EACX/hB,aAAa/J,GACbwrB,EAAGpY,QACHzJ,EAAO,IAAInH,MAAM,2BAErB,IAGEgE,EAAOylB,gBACHzlB,EAAOylB,QAAQT,UACdhlB,EAAOylB,SAGhB,IAAInB,EAAUU,EAAGU,kBAAkB1lB,EAAO+kB,QAAS,CAAEY,SAAS,IAC9DrB,EAAQsB,WAAa,cAGrB,MAAMC,QAAcb,EAAGc,oBACjBd,EAAGe,oBAAoBF,SAGvB,IAAIhqB,SAASmqB,IACY,aAAzBhB,EAAGiB,kBACLD,KAEAhB,EAAGzd,iBAAiB,2BAA2B,KAChB,aAAzByd,EAAGiB,mBACLD,GACF,IAGFjqB,WAAWiqB,EAAY,KACzB,IAGF,MAAMvX,QAAYlM,EAAOd,WAAW2M,GAC9B8X,QAAezX,EAAIoX,MAAM,CAC7BM,IAAKnB,EAAGoB,iBAAiBD,IACzBtnB,KAAMmmB,EAAGoB,iBAAiBvnB,OAG5BylB,EAAQG,OAAS,KACfzkB,EAAOskB,QAAUA,EACjBtkB,EAAO3G,UAAY6sB,EAAO7sB,UAE1B0C,YAAW+D,UACT,IAAKwlB,EACH,IACE,MAAMjlB,QAAYwkB,EAAU7kB,GAE5BF,eAAeiI,EAAYvH,KAASoE,GASlC,OARA,SACGpE,EAAK1B,SAAS,KACf,+CAEF,SACG0B,EAAK1B,SAAS,KACf,oDAEWuB,EAAI+M,mBACfpN,EAAO3G,UAAY,IAAM2G,EAAO+kB,QAAU,IAAMvkB,KAC7CoE,EAEP,CACA9E,eAAeL,UACPY,EAAIZ,aACVulB,EAAGpY,OACL,CAlBAoY,EAAG3kB,IAAMA,EAmBT2kB,EAAGvjB,YAAa,OAAesG,EAAa,CAC1CvH,KAAM,aACNS,YAAa,kCACbC,WAAY,CACVrC,KAAM,SACNsC,WAAY,CACViN,WAAY,CACVvP,KAAM,SACNoC,YACE,8JAEJjB,OAAQ,CACNnB,KAAM,SACNoC,YAAa,4BAGjBM,SAAU,CAAC,SAGfyjB,EAAGvlB,YAAa,OAAeA,EAAY,CACzCe,KAAM,aACNS,YAAa,mDACbC,WAAY,CAAErC,KAAM,SAAUsC,WAAY,CAAC,KAE7C6jB,EAAGqB,eAAgB,OAAehmB,EAAIuK,eAAgB,CACpDpK,KAAM,gBACNS,YAAa,6CACbC,WAAY,CACVrC,KAAM,SACNsC,WAAY,CACV2Y,MAAO,CACLjb,KAAM,SACNoC,YAAa,oBACbE,WAAY,CACVX,KAAM,CAAE3B,KAAM,UACdA,KAAM,CAAC,EACPkb,QAAS,CAAElb,KAAM,YACjBrB,QAAS,CAAEqB,KAAM,kBAM3BymB,GAAW,EACX/hB,aAAa/J,GACbsC,EAAQkpB,EACV,CAAE,MAAO1X,GACFgY,IACHA,GAAW,EACX/hB,aAAa/J,GACb2J,EAAOmK,GAEX,CACF,GACC,IAAK,EAGVgX,EAAQK,QAAU,KACXW,IACHA,GAAW,EACX/hB,aAAa/J,GACb2J,EAAO,IAAInH,MAAM,wBACnB,EAGFsoB,EAAQ7E,QAAW3iB,IACZwoB,IACHA,GAAW,EACX/hB,aAAa/J,GACb2J,EAAO,IAAInH,MAAM,uBAAuBc,MAC1C,QAGIkoB,EAAGsB,qBACP,IAAIC,sBAAsB,CACxBJ,IAAKD,EAAOC,IACZtnB,KAAMqnB,EAAOrnB,OAGnB,CAAE,MAAOyO,GACFgY,IACHA,GAAW,EACX/hB,aAAa/J,GACb2J,EAAOmK,GAEX,IAEJ,CAEAxN,eAAe0mB,EAAmBjkB,EAAQ6L,EAAYpO,GAKpD,MAAMymB,GAJNzmB,EAASA,GAAU,CACjB2H,WAAY,YACZD,iBAAiB,IAEG+d,QAEtB,cADOzlB,EAAOylB,cACDljB,EAAOnB,gBAAgB,CAClCqG,GAAI2G,EACJpO,SACA6lB,MAAO,CAAC3M,EAAQpO,IAvRpBhL,eAA4BoZ,EAAQ3W,EAAQvC,EAAQymB,EAAQ3b,GAC1D9K,EAASA,GAAU,CAAC,EACpB,IAAI6lB,EAAQ,IAAIU,sBAAsB,CACpCJ,IAAKjN,EAAOiN,IACZtnB,KAAMqa,EAAOra,OAGXmmB,EAAK,IAAIC,kBAAkB,CAC7BC,WAAYllB,EAAOmlB,aAAe,CAChC,CAAEC,KAAM,CAAC,kCAEXC,aAAc,iBAGZ9iB,GACFyiB,EAAGzd,iBAAiB,eAAezH,MAAOkH,IACxC,MAAMsd,EAAUtd,EAAMsd,QACtB,IAAI9M,EAAM,KACN1M,GAAWA,EAAQyB,OAAMiL,EAAM,CAAEjL,KAAMzB,EAAQyB,KAAMD,GAAIxB,EAAQwB,YACnDuY,EAAU,CAC1BP,QAASA,EACTlrB,UAAWkrB,EAAQzf,MACnBxL,UAAWkJ,EAAOvC,OAAO3G,UACzByR,QAAS0M,KAGP9Q,UAAYnE,EAAOlC,IAAIqG,SAAS,IAIpC+f,SACIA,EAAOzB,SAGTA,EAAGsB,qBAAqBT,GAE9B,IAAIK,QAAelB,EAAG0B,eAkBtB,aAjBM1B,EAAGe,oBAAoBG,SAGvB,IAAIrqB,SAASmqB,IACY,aAAzBhB,EAAGiB,kBACLD,KAEAhB,EAAGzd,iBAAiB,2BAA2B,KAChB,aAAzByd,EAAGiB,mBACLD,GACF,IAGFjqB,WAAWiqB,EAAY,KACzB,IAGK,CACLG,IAAKnB,EAAGoB,iBAAiBD,IACzBtnB,KAAMmmB,EAAGoB,iBAAiBvnB,KAC1BxF,UAAWkJ,EAAOvC,OAAO3G,UAE7B,CA6NMstB,CAAazN,EAAQ3W,EAAQvC,EAAQymB,EAAQ3b,IAEnD,C,iCCpXA,IACQ8b,EADJC,GACID,EAAgB,SAAUE,EAAGhb,GAI7B,OAHA8a,EAAgB/kB,OAAOklB,gBAClB,CAAEC,UAAW,cAAgBljB,OAAS,SAAUgjB,EAAGhb,GAAKgb,EAAEE,UAAYlb,CAAG,GAC1E,SAAUgb,EAAGhb,GAAK,IAAK,IAAIE,KAAKF,EAAOjK,OAAOgQ,UAAU9E,eAAe+E,KAAKhG,EAAGE,KAAI8a,EAAE9a,GAAKF,EAAEE,GAAI,EAC7F4a,EAAcE,EAAGhb,EAC5B,EACO,SAAUgb,EAAGhb,GAChB,GAAiB,mBAANA,GAA0B,OAANA,EAC3B,MAAM,IAAImb,UAAU,uBAAyBtM,OAAO7O,GAAK,iCAE7D,SAASob,IAAOvtB,KAAKT,YAAc4tB,CAAG,CADtCF,EAAcE,EAAGhb,GAEjBgb,EAAEjV,UAAkB,OAAN/F,EAAajK,OAAOqG,OAAO4D,IAAMob,EAAGrV,UAAY/F,EAAE+F,UAAW,IAAIqV,EACnF,GAEAC,EAA6B,SAAUC,GAEvC,SAASD,EAAYpqB,GACjB,IAAIsqB,EAAQD,EAAOtV,KAAKnY,KAAMoD,IAAYpD,KAEtC2tB,EAAQzlB,OAAOqG,OAAOif,EAAYtV,WAOtC,OANAhQ,OAAOklB,eAAeM,EAAOC,GAC7BzlB,OAAO0lB,eAAeF,EAAO,OAAQ,CACjCG,cAAc,EACdC,YAAY,EACZ7pB,MAAOupB,EAAY3mB,OAEhB6mB,CACX,CACA,OAbAR,EAAUM,EAAaC,GAahBD,CACX,CAfgC,CAe9BnrB,M,iCC3BF,IAAI0rB,EACA,SAAiB7oB,EAAMQ,GACnB1F,KAAKkF,KAAOA,EACZlF,KAAK0F,KAAOA,CAChB,E,kBCoFOsoB,EAAqB,CAC5B9oB,MAzFwB,EA0FxBsZ,OA3CG,SAAkCqL,GAEjC,IAZAoE,EACAC,EACAC,EAEAC,EAOJ,OAAIvE,aAAkB7nB,KA7CnB,SAAmCqsB,GACtC,IA0BQC,EA1BJJ,EAAMG,EAAGH,IAAKC,EAAOE,EAAGF,KAC5B,GAAID,GAAO,GAAKC,GAAQ,GAAKD,GAHP,YAGmC,CAErD,GAAa,IAATC,GAAcD,GANA,WAM4B,CAE1C,IAAIK,EAAK,IAAInpB,WAAW,GAGxB,OAFIkpB,EAAO,IAAIpM,SAASqM,EAAGxqB,SACtByqB,UAAU,EAAGN,GACXK,CACX,CAGI,IAAIE,EAAUP,EAAM,WAChBQ,EAAe,WAANR,EAOb,OANIK,EAAK,IAAInpB,WAAW,IACpBkpB,EAAO,IAAIpM,SAASqM,EAAGxqB,SAEtByqB,UAAU,EAAIL,GAAQ,EAAgB,EAAVM,GAEjCH,EAAKE,UAAU,EAAGE,GACXH,CAEf,CAOI,OAJIA,EAAK,IAAInpB,WAAW,KACpBkpB,EAAO,IAAIpM,SAASqM,EAAGxqB,SACtByqB,UAAU,EAAGL,IAClB,QAASG,EAAM,EAAGJ,GACXK,CAEf,CAeeI,EAXPR,EAA4B,MAF5BF,EAYoCpE,EAZxB3G,WAES,KADrBgL,EAAM5qB,KAAKsrB,MAAMX,EAAO,OAIrB,CACHC,IAAKA,GAFLE,EAAY9qB,KAAKsrB,MAAMT,EAAO,MAG9BA,KAAMA,EAAmB,IAAZC,KASN,IAEf,EAoCIjqB,OAPG,SAAkCuB,GACrC,IAAImpB,EA7BD,SAAmCnpB,GACtC,IAAI4oB,EAAO,IAAIpM,SAASxc,EAAK3B,OAAQ2B,EAAKkd,WAAYld,EAAK0D,YAE3D,OAAQ1D,EAAK0D,YACT,KAAK,EAID,MAAO,CAAE8kB,IAFCI,EAAKQ,UAAU,GAENX,KADR,GAGf,KAAK,EAED,IAAIY,EAAoBT,EAAKQ,UAAU,GAIvC,MAAO,CAAEZ,IAF6B,YAAP,EAApBa,GADIT,EAAKQ,UAAU,GAGXX,KADRY,IAAsB,GAGrC,KAAK,GAID,MAAO,CAAEb,KAFC,QAASI,EAAM,GAENH,KADRG,EAAKQ,UAAU,IAG9B,QACI,MAAM,IAAItB,EAAA,EAAY,gEAAgE7X,OAAOjQ,EAAKV,SAE9G,CAEmBgqB,CAA0BtpB,GACzC,OAAO,IAAI1D,KAAoB,IAAf6sB,EAASX,IAAYW,EAASV,KAAO,IACzD,GCvFIc,EAAgC,WAChC,SAASA,IAELjvB,KAAKkvB,gBAAkB,GACvBlvB,KAAKmvB,gBAAkB,GAEvBnvB,KAAKovB,SAAW,GAChBpvB,KAAKqvB,SAAW,GAChBrvB,KAAKwnB,SAASwG,EAClB,CAuDA,OAtDAiB,EAAe/W,UAAUsP,SAAW,SAAU6G,GAC1C,IAAInpB,EAAOmpB,EAAGnpB,KAAMsZ,EAAS6P,EAAG7P,OAAQra,EAASkqB,EAAGlqB,OACpD,GAAIe,GAAQ,EAERlF,KAAKovB,SAASlqB,GAAQsZ,EACtBxe,KAAKqvB,SAASnqB,GAAQf,MAErB,CAED,IAAI2N,EAAQ,EAAI5M,EAChBlF,KAAKkvB,gBAAgBpd,GAAS0M,EAC9Bxe,KAAKmvB,gBAAgBrd,GAAS3N,CAClC,CACJ,EACA8qB,EAAe/W,UAAUoX,YAAc,SAAUzF,EAAQ1Y,GAErD,IAAK,IAAI5G,EAAI,EAAGA,EAAIvK,KAAKkvB,gBAAgBlqB,OAAQuF,IAE7C,GAAiB,OADbglB,EAAYvvB,KAAKkvB,gBAAgB3kB,KAGrB,OADR7E,EAAO6pB,EAAU1F,EAAQ1Y,IAGzB,OAAO,IAAI4c,GADC,EAAIxjB,EACS7E,GAKrC,IAAS6E,EAAI,EAAGA,EAAIvK,KAAKovB,SAASpqB,OAAQuF,IAAK,CAC3C,IAAIglB,EAEI7pB,EADR,GAAiB,OADb6pB,EAAYvvB,KAAKovB,SAAS7kB,KAGd,OADR7E,EAAO6pB,EAAU1F,EAAQ1Y,IAGzB,OAAO,IAAI4c,EADAxjB,EACc7E,EAGrC,CACA,OAAImkB,aAAkBkE,EAEXlE,EAEJ,IACX,EACAoF,EAAe/W,UAAU/T,OAAS,SAAUuB,EAAMR,EAAMiM,GACpD,IAAIqe,EAAYtqB,EAAO,EAAIlF,KAAKmvB,iBAAiB,EAAIjqB,GAAQlF,KAAKqvB,SAASnqB,GAC3E,OAAIsqB,EACOA,EAAU9pB,EAAMR,EAAMiM,GAItB,IAAI4c,EAAQ7oB,EAAMQ,EAEjC,EACAupB,EAAeQ,aAAe,IAAIR,EAC3BA,CACX,CAjEmC,E,gBCH5B,SAASS,EAAWC,GACvB,MAAO,GAAGha,OAAOga,EAAO,EAAI,IAAM,GAAI,MAAMha,OAAOrS,KAAKssB,IAAID,GAAMpiB,SAAS,IAAIsiB,SAAS,EAAG,KAC/F,C,mECCIC,EAAkC,WAClC,SAASA,EAAiBC,EAAcC,QACf,IAAjBD,IAA2BA,EAJV,SAKG,IAApBC,IAA8BA,EAJT,IAKzBhwB,KAAK+vB,aAAeA,EACpB/vB,KAAKgwB,gBAAkBA,EACvBhwB,KAAKiwB,IAAM,EACXjwB,KAAKkwB,KAAO,EAGZlwB,KAAKmwB,OAAS,GACd,IAAK,IAAI5lB,EAAI,EAAGA,EAAIvK,KAAK+vB,aAAcxlB,IACnCvK,KAAKmwB,OAAOngB,KAAK,GAEzB,CA2CA,OA1CA8f,EAAiB5X,UAAUkY,YAAc,SAAUhnB,GAC/C,OAAOA,EAAa,GAAKA,GAAcpJ,KAAK+vB,YAChD,EACAD,EAAiB5X,UAAUmY,KAAO,SAAUxN,EAAOyN,EAAalnB,GAE5DmnB,EAAY,IAAK,IAAIC,EAAK,EAAGC,EADfzwB,KAAKmwB,OAAO/mB,EAAa,GACWonB,EAAKC,EAAUzrB,OAAQwrB,IAAM,CAG3E,IAFA,IAAIE,EAASD,EAAUD,GACnBG,EAAcD,EAAO7N,MAChB+N,EAAI,EAAGA,EAAIxnB,EAAYwnB,IAC5B,GAAID,EAAYC,KAAO/N,EAAMyN,EAAcM,GACvC,SAASL,EAGjB,OAAOG,EAAOtN,GAClB,CACA,OAAO,IACX,EACA0M,EAAiB5X,UAAUM,MAAQ,SAAUqK,EAAO5e,GAChD,IAAI4sB,EAAU7wB,KAAKmwB,OAAOtN,EAAM7d,OAAS,GACrC0rB,EAAS,CAAE7N,MAAOA,EAAOO,IAAKnf,GAC9B4sB,EAAQ7rB,QAAUhF,KAAKgwB,gBAGvBa,EAASvtB,KAAK0f,SAAW6N,EAAQ7rB,OAAU,GAAK0rB,EAGhDG,EAAQ7gB,KAAK0gB,EAErB,EACAZ,EAAiB5X,UAAU/T,OAAS,SAAU0e,EAAOyN,EAAalnB,GAC9D,IAAI0nB,EAAc9wB,KAAKqwB,KAAKxN,EAAOyN,EAAalnB,GAChD,GAAmB,MAAf0nB,EAEA,OADA9wB,KAAKiwB,MACEa,EAEX9wB,KAAKkwB,OACL,IAAI9M,GAAM,EAAA2N,EAAA,IAAalO,EAAOyN,EAAalnB,GAEvC4nB,EAAoB5rB,WAAW8S,UAAU3S,MAAM4S,KAAK0K,EAAOyN,EAAaA,EAAclnB,GAE1F,OADApJ,KAAKwY,MAAMwY,EAAmB5N,GACvBA,CACX,EACO0M,CACX,CA1DqC,G,SCMjCmB,EAA4C,SAAUC,EAASvtB,GAC/D,IAAsGwtB,EAAGC,EAAGtO,EAAGuO,EAA3GC,EAAI,CAAEpmB,MAAO,EAAGqmB,KAAM,WAAa,GAAW,EAAPzO,EAAE,GAAQ,MAAMA,EAAE,GAAI,OAAOA,EAAE,EAAI,EAAG0O,KAAM,GAAIC,IAAK,IAChG,OAAOJ,EAAI,CAAE7e,KAAMkf,EAAK,GAAI,MAASA,EAAK,GAAI,OAAUA,EAAK,IAAwB,mBAAXjI,SAA0B4H,EAAE5H,OAAO1K,UAAY,WAAa,OAAO/e,IAAM,GAAIqxB,EACvJ,SAASK,EAAKC,GAAK,OAAO,SAAUrnB,GAAK,OACzC,SAAcsnB,GACV,GAAIT,EAAG,MAAM,IAAI7D,UAAU,mCAC3B,KAAOgE,OACH,GAAIH,EAAI,EAAGC,IAAMtO,EAAY,EAAR8O,EAAG,GAASR,EAAU,OAAIQ,EAAG,GAAKR,EAAS,SAAOtO,EAAIsO,EAAU,SAAMtO,EAAE3K,KAAKiZ,GAAI,GAAKA,EAAE5e,SAAWsQ,EAAIA,EAAE3K,KAAKiZ,EAAGQ,EAAG,KAAK5tB,KAAM,OAAO8e,EAE3J,OADIsO,EAAI,EAAGtO,IAAG8O,EAAK,CAAS,EAARA,EAAG,GAAQ9O,EAAE7e,QACzB2tB,EAAG,IACP,KAAK,EAAG,KAAK,EAAG9O,EAAI8O,EAAI,MACxB,KAAK,EAAc,OAAXN,EAAEpmB,QAAgB,CAAEjH,MAAO2tB,EAAG,GAAI5tB,MAAM,GAChD,KAAK,EAAGstB,EAAEpmB,QAASkmB,EAAIQ,EAAG,GAAIA,EAAK,CAAC,GAAI,SACxC,KAAK,EAAGA,EAAKN,EAAEG,IAAIltB,MAAO+sB,EAAEE,KAAKjtB,MAAO,SACxC,QACI,MAAkBue,GAAZA,EAAIwO,EAAEE,MAAYxsB,OAAS,GAAK8d,EAAEA,EAAE9d,OAAS,KAAkB,IAAV4sB,EAAG,IAAsB,IAAVA,EAAG,IAAW,CAAEN,EAAI,EAAG,QAAU,CAC3G,GAAc,IAAVM,EAAG,MAAc9O,GAAM8O,EAAG,GAAK9O,EAAE,IAAM8O,EAAG,GAAK9O,EAAE,IAAM,CAAEwO,EAAEpmB,MAAQ0mB,EAAG,GAAI,KAAO,CACrF,GAAc,IAAVA,EAAG,IAAYN,EAAEpmB,MAAQ4X,EAAE,GAAI,CAAEwO,EAAEpmB,MAAQ4X,EAAE,GAAIA,EAAI8O,EAAI,KAAO,CACpE,GAAI9O,GAAKwO,EAAEpmB,MAAQ4X,EAAE,GAAI,CAAEwO,EAAEpmB,MAAQ4X,EAAE,GAAIwO,EAAEG,IAAIzhB,KAAK4hB,GAAK,KAAO,CAC9D9O,EAAE,IAAIwO,EAAEG,IAAIltB,MAChB+sB,EAAEE,KAAKjtB,MAAO,SAEtBqtB,EAAKjuB,EAAKwU,KAAK+Y,EAASI,EAC5B,CAAE,MAAO3d,GAAKie,EAAK,CAAC,EAAGje,GAAIyd,EAAI,CAAG,CAAE,QAAUD,EAAIrO,EAAI,CAAG,CACzD,GAAY,EAAR8O,EAAG,GAAQ,MAAMA,EAAG,GAAI,MAAO,CAAE3tB,MAAO2tB,EAAG,GAAKA,EAAG,QAAK,EAAQ5tB,MAAM,EAC9E,CAtBgD6tB,CAAK,CAACF,EAAGrnB,GAAK,CAAG,CAuBrE,EACIwnB,EAAgD,SAAUC,GAC1D,IAAKtI,OAAOC,cAAe,MAAM,IAAI4D,UAAU,wCAC/C,IAAiC/iB,EAA7BynB,EAAID,EAAEtI,OAAOC,eACjB,OAAOsI,EAAIA,EAAE7Z,KAAK4Z,IAAMA,EAAwB,mBAAbE,SAA0BA,SAASF,GAAKA,EAAEtI,OAAO1K,YAAaxU,EAAI,CAAC,EAAGmnB,EAAK,QAASA,EAAK,SAAUA,EAAK,UAAWnnB,EAAEkf,OAAOC,eAAiB,WAAc,OAAO1pB,IAAM,EAAGuK,GAC9M,SAASmnB,EAAKC,GAAKpnB,EAAEonB,GAAKI,EAAEJ,IAAM,SAAUrnB,GAAK,OAAO,IAAIpI,SAAQ,SAAUC,EAASqH,IACvF,SAAgBrH,EAASqH,EAAQ2jB,EAAG7iB,GAAKpI,QAAQC,QAAQmI,GAAGZ,MAAK,SAASY,GAAKnI,EAAQ,CAAE8B,MAAOqG,EAAGtG,KAAMmpB,GAAM,GAAG3jB,EAAS,CADbsP,CAAO3W,EAASqH,GAA7Bc,EAAIynB,EAAEJ,GAAGrnB,IAA8BtG,KAAMsG,EAAErG,MAAQ,GAAI,CAAG,CAEnK,EACIiuB,EAAoC,SAAU5nB,GAAK,OAAOtK,gBAAgBkyB,GAAWlyB,KAAKsK,EAAIA,EAAGtK,MAAQ,IAAIkyB,EAAQ5nB,EAAI,EAwBzH6nB,EAAa,IAAIjQ,SAAS,IAAIpP,YAAY,IAC1Csf,EAAc,IAAIhtB,WAAW+sB,EAAWpuB,QAGjCsuB,EAAgC,WACvC,IAGIF,EAAWG,QAAQ,EACvB,CACA,MAAO3e,GACH,OAAOA,EAAEpU,WACb,CACA,MAAM,IAAI8C,MAAM,gBACnB,CAV0C,GAWvCkwB,EAAY,IAAIF,EAA8B,qBAC9CG,EAAyB,IAAI1C,EAC7B2C,EAAyB,WACzB,SAASA,EAAQC,EAAgBvhB,EAASwhB,EAAcC,EAAcC,EAAgBC,EAAcC,EAAcC,QACvF,IAAnBN,IAA6BA,EAAiBzD,EAAA,EAAeQ,mBACjD,IAAZte,IAAsBA,OAAUnC,QACf,IAAjB2jB,IAA2BA,EAAe,WACzB,IAAjBC,IAA2BA,EAAe,WACvB,IAAnBC,IAA6BA,EAAiB,WAC7B,IAAjBC,IAA2BA,EAAe,WACzB,IAAjBC,IAA2BA,EAAe,WAC3B,IAAfC,IAAyBA,EAAaR,GAC1CxyB,KAAK0yB,eAAiBA,EACtB1yB,KAAKmR,QAAUA,EACfnR,KAAK2yB,aAAeA,EACpB3yB,KAAK4yB,aAAeA,EACpB5yB,KAAK6yB,eAAiBA,EACtB7yB,KAAK8yB,aAAeA,EACpB9yB,KAAK+yB,aAAeA,EACpB/yB,KAAKgzB,WAAaA,EAClBhzB,KAAKizB,SAAW,EAChBjzB,KAAK8hB,IAAM,EACX9hB,KAAKsuB,KAAO6D,EACZnyB,KAAK6iB,MAAQuP,EACbpyB,KAAKkzB,UAxCY,EAyCjBlzB,KAAK8gB,MAAQ,EACjB,CA8mBA,OA7mBA2R,EAAQva,UAAUib,kBAAoB,WAClCnzB,KAAKizB,SAAW,EAChBjzB,KAAKkzB,UA7CY,EA8CjBlzB,KAAK8gB,MAAM9b,OAAS,CAExB,EACAytB,EAAQva,UAAUkb,UAAY,SAAUrvB,GACpC/D,KAAK6iB,OAAQ,OAAiB9e,GAC9B/D,KAAKsuB,MAAO,OAAetuB,KAAK6iB,OAChC7iB,KAAK8hB,IAAM,CACf,EACA2Q,EAAQva,UAAUmb,aAAe,SAAUtvB,GACvC,IAvDiB,IAuDb/D,KAAKkzB,UAAoClzB,KAAKszB,aAAa,GAG1D,CACD,IAAIC,EAAgBvzB,KAAK6iB,MAAM2Q,SAASxzB,KAAK8hB,KACzC2R,GAAU,OAAiB1vB,GAE3BsB,EAAY,IAAID,WAAWmuB,EAAcvuB,OAASyuB,EAAQzuB,QAC9DK,EAAUC,IAAIiuB,GACdluB,EAAUC,IAAImuB,EAASF,EAAcvuB,QACrChF,KAAKozB,UAAU/tB,EACnB,MAVIrF,KAAKozB,UAAUrvB,EAWvB,EACA0uB,EAAQva,UAAUob,aAAe,SAAUlZ,GACvC,OAAOpa,KAAKsuB,KAAKllB,WAAapJ,KAAK8hB,KAAO1H,CAC9C,EACAqY,EAAQva,UAAUwb,qBAAuB,SAAUC,GAC/C,IAAerF,EAANtuB,KAAgBsuB,KAAMxM,EAAtB9hB,KAA+B8hB,IACxC,OAAO,IAAI8R,WAAW,SAASje,OAAO2Y,EAAKllB,WAAa0Y,EAAK,QAAQnM,OAAO2Y,EAAKllB,WAAY,6BAA6BuM,OAAOge,EAAW,KAChJ,EAKAlB,EAAQva,UAAU/T,OAAS,SAAUJ,GACjC/D,KAAKmzB,oBACLnzB,KAAKozB,UAAUrvB,GACf,IAAI8lB,EAAS7pB,KAAK6zB,eAClB,GAAI7zB,KAAKszB,aAAa,GAClB,MAAMtzB,KAAK0zB,qBAAqB1zB,KAAK8hB,KAEzC,OAAO+H,CACX,EACA4I,EAAQva,UAAU4b,YAAc,SAAU/vB,GACtC,OAAOktB,EAAYjxB,MAAM,SAAUquB,GAC/B,OAAQA,EAAGnjB,OACP,KAAK,EACDlL,KAAKmzB,oBACLnzB,KAAKozB,UAAUrvB,GACfsqB,EAAGnjB,MAAQ,EACf,KAAK,EACD,OAAKlL,KAAKszB,aAAa,GAChB,CAAC,EAAatzB,KAAK6zB,gBADQ,CAAC,EAAa,GAEpD,KAAK,EAED,OADAxF,EAAGkD,OACI,CAAC,EAAa,GACzB,KAAK,EAAG,MAAO,CAAC,GAExB,GACJ,EACAkB,EAAQva,UAAU6b,YAAc,SAAU3vB,GACtC,IAAI4vB,EAAUC,EACVC,EAAK7F,EA7KqC6C,EAASiD,EAAYC,EAAGC,EA8KtE,OA9K8CnD,EA8K7BlxB,KA9KsCm0B,OA8KhC,EA9K+CE,EA8K/B,WACnC,IAAIpvB,EAAS4kB,EAAQ9lB,EAAQuwB,EAAOC,EAAIrB,EAAUpR,EAAKmR,EACvD,OAAOhC,EAAYjxB,MAAM,SAAUw0B,GAC/B,OAAQA,EAAGtpB,OACP,KAAK,EACDjG,GAAU,EACVuvB,EAAGtpB,MAAQ,EACf,KAAK,EACDspB,EAAGhD,KAAKxhB,KAAK,CAAC,EAAG,EAAG,EAAG,KACvBgkB,EAAWlC,EAAc1tB,GACzBowB,EAAGtpB,MAAQ,EACf,KAAK,EAAG,MAAO,CAAC,EAAa8oB,EAASxhB,QACtC,KAAK,EACD,IAAMyhB,EAAaO,EAAGjD,QAAoBvtB,KAAO,MAAO,CAAC,EAAa,GAEtE,GADAD,EAASkwB,EAAWhwB,MAChBgB,EACA,MAAMjF,KAAK0zB,qBAAqB1zB,KAAKizB,UAEzCjzB,KAAKqzB,aAAatvB,GAClB,IACI8lB,EAAS7pB,KAAK6zB,eACd5uB,GAAU,CACd,CACA,MAAO0O,GACH,KAAMA,aAAa0e,GACf,MAAM1e,CAGd,CACA3T,KAAKizB,UAAYjzB,KAAK8hB,IACtB0S,EAAGtpB,MAAQ,EACf,KAAK,EAAG,MAAO,CAAC,EAAa,GAC7B,KAAK,EAAG,MAAO,CAAC,EAAa,IAC7B,KAAK,EAGD,OAFAopB,EAAQE,EAAGjD,OACX2C,EAAM,CAAE/wB,MAAOmxB,GACR,CAAC,EAAa,IACzB,KAAK,EAED,OADAE,EAAGhD,KAAKxhB,KAAK,CAAC,EAAG,CAAE,GAAI,KACjBikB,IAAeA,EAAWjwB,OAASqqB,EAAK2F,EAASzK,QAChD,CAAC,EAAa8E,EAAGlW,KAAK6b,IAD2C,CAAC,EAAa,GAE1F,KAAK,EACDQ,EAAGjD,OACHiD,EAAGtpB,MAAQ,EACf,KAAK,EAAG,MAAO,CAAC,EAAa,IAC7B,KAAK,GACD,GAAIgpB,EAAK,MAAMA,EAAI/wB,MACnB,MAAO,CAAC,GACZ,KAAK,GAAI,MAAO,CAAC,GACjB,KAAK,GACD,GAAI8B,EAAS,CACT,GAAIjF,KAAKszB,aAAa,GAClB,MAAMtzB,KAAK0zB,qBAAqB1zB,KAAKizB,UAEzC,MAAO,CAAC,EAAcpJ,EAC1B,CAEA,MADWqJ,GAAXqB,EAAKv0B,MAAoBkzB,SAAUpR,EAAMyS,EAAGzS,IAAKmR,EAAWsB,EAAGtB,SACzD,IAAIW,WAAW,gCAAgCje,OAAO+Z,EAAWwD,GAAW,QAAQvd,OAAOsd,EAAU,MAAMtd,OAAOmM,EAAK,4BAEzI,GACJ,EAxOG,KAFgEsS,OA8KpC,KA5KjBA,EAAIlyB,WAAU,SAAUC,EAASqH,GAC/C,SAASirB,EAAUxwB,GAAS,IAAM4tB,EAAKwC,EAAU7hB,KAAKvO,GAAS,CAAE,MAAO0P,GAAKnK,EAAOmK,EAAI,CAAE,CAC1F,SAAS+gB,EAASzwB,GAAS,IAAM4tB,EAAKwC,EAAiB,MAAEpwB,GAAS,CAAE,MAAO0P,GAAKnK,EAAOmK,EAAI,CAAE,CAC7F,SAASke,EAAKloB,GAJlB,IAAe1F,EAIa0F,EAAO3F,KAAO7B,EAAQwH,EAAO1F,QAJ1CA,EAIyD0F,EAAO1F,MAJhDA,aAAiBmwB,EAAInwB,EAAQ,IAAImwB,GAAE,SAAUjyB,GAAWA,EAAQ8B,EAAQ,KAIjByF,KAAK+qB,EAAWC,EAAW,CAC7G7C,GAAMwC,EAAYA,EAAU5oB,MAAMylB,EAASiD,GAAc,KAAK3hB,OAClE,GAoOA,EACAigB,EAAQva,UAAUyc,kBAAoB,SAAUvwB,GAC5C,OAAOpE,KAAK40B,iBAAiBxwB,GAAQ,EACzC,EACAquB,EAAQva,UAAU2c,aAAe,SAAUzwB,GACvC,OAAOpE,KAAK40B,iBAAiBxwB,GAAQ,EACzC,EACAquB,EAAQva,UAAU0c,iBAAmB,SAAUxwB,EAAQgG,GACnD,OAvMkD,SAAU8mB,EAASiD,EAAYE,GACrF,IAAK5K,OAAOC,cAAe,MAAM,IAAI4D,UAAU,wCAC/C,IAAoD/iB,EAAhD8mB,EAAIgD,EAAU5oB,MAAMylB,EAASiD,GAAc,IAAQW,EAAI,GAC3D,OAAOvqB,EAAI,CAAC,EAAGmnB,EAAK,QAASA,EAAK,SAAUA,EAAK,UAAWnnB,EAAEkf,OAAOC,eAAiB,WAAc,OAAO1pB,IAAM,EAAGuK,EACpH,SAASmnB,EAAKC,GAASN,EAAEM,KAAIpnB,EAAEonB,GAAK,SAAUrnB,GAAK,OAAO,IAAIpI,SAAQ,SAAU6yB,EAAG5iB,GAAK2iB,EAAE9kB,KAAK,CAAC2hB,EAAGrnB,EAAGyqB,EAAG5iB,IAAM,GAAK6iB,EAAOrD,EAAGrnB,EAAI,GAAI,EAAG,CACzI,SAAS0qB,EAAOrD,EAAGrnB,GAAK,KACV2qB,EADqB5D,EAAEM,GAAGrnB,IACnBrG,iBAAiBiuB,EAAUhwB,QAAQC,QAAQ8yB,EAAEhxB,MAAMqG,GAAGZ,KAAKwrB,EAAS1rB,GAAUsP,EAAOgc,EAAE,GAAG,GAAIG,EADtE,CAAE,MAAOthB,GAAKmF,EAAOgc,EAAE,GAAG,GAAInhB,EAAI,CAC/E,IAAcshB,CADmE,CAEjF,SAASC,EAAQjxB,GAAS+wB,EAAO,OAAQ/wB,EAAQ,CACjD,SAASuF,EAAOvF,GAAS+wB,EAAO,QAAS/wB,EAAQ,CACjD,SAAS6U,EAAOqY,EAAG7mB,GAAS6mB,EAAE7mB,GAAIwqB,EAAE1L,QAAS0L,EAAE9vB,QAAQgwB,EAAOF,EAAE,GAAG,GAAIA,EAAE,GAAG,GAAK,CACrF,CA6LeK,CAAiBn1B,KAAMoY,WAAW,WACrC,IAAIgd,EAAuBC,EAAgBC,EAAUC,EAAYxxB,EAAQyxB,EAAKC,EAC1EC,EAAKrH,EACT,OAAO4C,EAAYjxB,MAAM,SAAUu0B,GAC/B,OAAQA,EAAGrpB,OACP,KAAK,EACDkqB,EAAwBhrB,EACxBirB,GAAkB,EAClBd,EAAGrpB,MAAQ,EACf,KAAK,EACDqpB,EAAG/C,KAAKxhB,KAAK,CAAC,EAAG,GAAI,GAAI,KACzBslB,EAAWxD,EAAc1tB,GACzBmwB,EAAGrpB,MAAQ,EACf,KAAK,EAAG,MAAO,CAAC,EAAagnB,EAAQoD,EAAS9iB,SAC9C,KAAK,EACD,IAAM+iB,EAAahB,EAAGhD,QAAoBvtB,KAAO,MAAO,CAAC,EAAa,IAEtE,GADAD,EAASwxB,EAAWtxB,MAChBmG,GAA8B,IAAnBirB,EACX,MAAMr1B,KAAK0zB,qBAAqB1zB,KAAKizB,UAEzCjzB,KAAKqzB,aAAatvB,GACdqxB,IACAC,EAAiBr1B,KAAK21B,gBACtBP,GAAwB,EACxBp1B,KAAK41B,YAETrB,EAAGrpB,MAAQ,EACf,KAAK,EACDqpB,EAAG/C,KAAKxhB,KAAK,CAAC,EAAG,EAAG,CAAE,KACtBukB,EAAGrpB,MAAQ,EACf,KAAK,EAED,MAAO,CAAC,EAAagnB,EAAQlyB,KAAK6zB,iBACtC,KAAK,EAAG,MAAO,CAAC,EAAaU,EAAGhD,QAChC,KAAK,EAED,OADAgD,EAAGhD,OACsB,KAAnB8D,EACK,CAAC,EAAa,GAElB,CAAC,EAAa,GACzB,KAAK,EAAG,MAAO,CAAC,EAAa,IAC7B,KAAK,EAED,MADAG,EAAMjB,EAAGhD,kBACYc,GACjB,MAAMmD,EAEV,MAAO,CAAC,EAAa,IACzB,KAAK,GACDx1B,KAAKizB,UAAYjzB,KAAK8hB,IACtByS,EAAGrpB,MAAQ,GACf,KAAK,GAAI,MAAO,CAAC,EAAa,GAC9B,KAAK,GAAI,MAAO,CAAC,EAAa,IAC9B,KAAK,GAGD,OAFAuqB,EAAQlB,EAAGhD,OACXmE,EAAM,CAAEvyB,MAAOsyB,GACR,CAAC,EAAa,IACzB,KAAK,GAED,OADAlB,EAAG/C,KAAKxhB,KAAK,CAAC,GAAI,CAAE,GAAI,KAClBulB,IAAeA,EAAWvxB,OAASqqB,EAAKiH,EAAS/L,QAChD,CAAC,EAAa2I,EAAQ7D,EAAGlW,KAAKmd,KADmC,CAAC,EAAa,IAE1F,KAAK,GACDf,EAAGhD,OACHgD,EAAGrpB,MAAQ,GACf,KAAK,GAAI,MAAO,CAAC,EAAa,IAC9B,KAAK,GACD,GAAIwqB,EAAK,MAAMA,EAAIvyB,MACnB,MAAO,CAAC,GACZ,KAAK,GAAI,MAAO,CAAC,GACjB,KAAK,GAAI,MAAO,CAAC,GAEzB,GACJ,GACJ,EACAsvB,EAAQva,UAAU2b,aAAe,WAC7BgC,EAAQ,OAAa,CACjB,IAAI3C,EAAWlzB,KAAK81B,eAChBjM,OAAS,EACb,GAAIqJ,GAAY,IAEZrJ,EAASqJ,EAAW,SAEnB,GAAIA,EAAW,IAChB,GAAIA,EAAW,IAEXrJ,EAASqJ,OAER,GAAIA,EAAW,IAAM,CAGtB,GAAa,IADT9Y,EAAO8Y,EAAW,KACN,CACZlzB,KAAK+1B,aAAa3b,GAClBpa,KAAK41B,WACL,SAASC,CACb,CAEIhM,EAAS,CAAC,CAElB,MACK,GAAIqJ,EAAW,IAAM,CAGtB,GAAa,IADT9Y,EAAO8Y,EAAW,KACN,CACZlzB,KAAKg2B,eAAe5b,GACpBpa,KAAK41B,WACL,SAASC,CACb,CAEIhM,EAAS,EAEjB,KACK,CAED,IAAIzgB,EAAa8pB,EAAW,IAC5BrJ,EAAS7pB,KAAKi2B,iBAAiB7sB,EAAY,EAC/C,MAEC,GAAiB,MAAb8pB,EAELrJ,EAAS,UAER,GAAiB,MAAbqJ,EAELrJ,GAAS,OAER,GAAiB,MAAbqJ,EAELrJ,GAAS,OAER,GAAiB,MAAbqJ,EAELrJ,EAAS7pB,KAAKk2B,eAEb,GAAiB,MAAbhD,EAELrJ,EAAS7pB,KAAKm2B,eAEb,GAAiB,MAAbjD,EAELrJ,EAAS7pB,KAAKo2B,cAEb,GAAiB,MAAblD,EAELrJ,EAAS7pB,KAAKq2B,eAEb,GAAiB,MAAbnD,EAELrJ,EAAS7pB,KAAKs2B,eAEb,GAAiB,MAAbpD,EAELrJ,EAAS7pB,KAAKu2B,eAEb,GAAiB,MAAbrD,EAELrJ,EAAS7pB,KAAKw2B,cAEb,GAAiB,MAAbtD,EAELrJ,EAAS7pB,KAAKy2B,eAEb,GAAiB,MAAbvD,EAELrJ,EAAS7pB,KAAK02B,eAEb,GAAiB,MAAbxD,EAELrJ,EAAS7pB,KAAK22B,eAEb,GAAiB,MAAbzD,EAED9pB,EAAapJ,KAAK42B,SACtB/M,EAAS7pB,KAAKi2B,iBAAiB7sB,EAAY,QAE1C,GAAiB,MAAb8pB,EAED9pB,EAAapJ,KAAK62B,UACtBhN,EAAS7pB,KAAKi2B,iBAAiB7sB,EAAY,QAE1C,GAAiB,MAAb8pB,EAED9pB,EAAapJ,KAAK82B,UACtBjN,EAAS7pB,KAAKi2B,iBAAiB7sB,EAAY,QAE1C,GAAiB,MAAb8pB,EAAmB,CAGxB,GAAa,KADT9Y,EAAOpa,KAAKq2B,WACA,CACZr2B,KAAKg2B,eAAe5b,GACpBpa,KAAK41B,WACL,SAASC,CACb,CAEIhM,EAAS,EAEjB,MACK,GAAiB,MAAbqJ,EAAmB,CAGxB,GAAa,KADT9Y,EAAOpa,KAAKs2B,WACA,CACZt2B,KAAKg2B,eAAe5b,GACpBpa,KAAK41B,WACL,SAASC,CACb,CAEIhM,EAAS,EAEjB,MACK,GAAiB,MAAbqJ,EAAmB,CAGxB,GAAa,KADT9Y,EAAOpa,KAAKq2B,WACA,CACZr2B,KAAK+1B,aAAa3b,GAClBpa,KAAK41B,WACL,SAASC,CACb,CAEIhM,EAAS,CAAC,CAElB,MACK,GAAiB,MAAbqJ,EAAmB,CAGxB,GAAa,KADT9Y,EAAOpa,KAAKs2B,WACA,CACZt2B,KAAK+1B,aAAa3b,GAClBpa,KAAK41B,WACL,SAASC,CACb,CAEIhM,EAAS,CAAC,CAElB,MACK,GAAiB,MAAbqJ,EAAmB,CAExB,IAAI9Y,EAAOpa,KAAK42B,SAChB/M,EAAS7pB,KAAK+2B,aAAa3c,EAAM,EACrC,MACK,GAAiB,MAAb8Y,EAED9Y,EAAOpa,KAAK62B,UAChBhN,EAAS7pB,KAAK+2B,aAAa3c,EAAM,QAEhC,GAAiB,MAAb8Y,EAED9Y,EAAOpa,KAAK82B,UAChBjN,EAAS7pB,KAAK+2B,aAAa3c,EAAM,QAEhC,GAAiB,MAAb8Y,EAELrJ,EAAS7pB,KAAKg3B,gBAAgB,EAAG,QAEhC,GAAiB,MAAb9D,EAELrJ,EAAS7pB,KAAKg3B,gBAAgB,EAAG,QAEhC,GAAiB,MAAb9D,EAELrJ,EAAS7pB,KAAKg3B,gBAAgB,EAAG,QAEhC,GAAiB,MAAb9D,EAELrJ,EAAS7pB,KAAKg3B,gBAAgB,EAAG,QAEhC,GAAiB,MAAb9D,EAELrJ,EAAS7pB,KAAKg3B,gBAAgB,GAAI,QAEjC,GAAiB,MAAb9D,EAED9Y,EAAOpa,KAAK42B,SAChB/M,EAAS7pB,KAAKg3B,gBAAgB5c,EAAM,QAEnC,GAAiB,MAAb8Y,EAED9Y,EAAOpa,KAAK62B,UAChBhN,EAAS7pB,KAAKg3B,gBAAgB5c,EAAM,OAEnC,IAAiB,MAAb8Y,EAML,MAAM,IAAI1F,EAAA,EAAY,2BAA2B7X,OAAO+Z,EAAWwD,KAJ/D9Y,EAAOpa,KAAK82B,UAChBjN,EAAS7pB,KAAKg3B,gBAAgB5c,EAAM,EAIxC,CACApa,KAAK41B,WAEL,IADA,IAAI9U,EAAQ9gB,KAAK8gB,MACVA,EAAM9b,OAAS,GAAG,CAErB,IAAIiyB,EAAQnW,EAAMA,EAAM9b,OAAS,GACjC,GAAmB,IAAfiyB,EAAM/xB,KAA8B,CAGpC,GAFA+xB,EAAM1U,MAAM0U,EAAMC,UAAYrN,EAC9BoN,EAAMC,WACFD,EAAMC,WAAaD,EAAM7c,KAKzB,SAASyb,EAJT/U,EAAMvc,MACNslB,EAASoN,EAAM1U,KAKvB,KACK,IAAmB,IAAf0U,EAAM/xB,KAAgC,CAC3C,QAjeZiyB,EACe,WADfA,SAiemCtN,IAheI,WAAZsN,EAieX,MAAM,IAAI3J,EAAA,EAAY,uDAAyD3D,GAEnF,GAAe,cAAXA,EACA,MAAM,IAAI2D,EAAA,EAAY,oCAE1ByJ,EAAMvlB,IAAMmY,EACZoN,EAAM/xB,KAAO,EACb,SAAS2wB,CACb,CAKI,GAFAoB,EAAM5sB,IAAI4sB,EAAMvlB,KAAOmY,EACvBoN,EAAMG,YACFH,EAAMG,YAAcH,EAAM7c,KAIzB,CACD6c,EAAMvlB,IAAM,KACZulB,EAAM/xB,KAAO,EACb,SAAS2wB,CACb,CAPI/U,EAAMvc,MACNslB,EAASoN,EAAM5sB,GAOvB,CACJ,CACA,OAAOwf,CACX,CA5fgB,IAChBsN,CA4fJ,EACA1E,EAAQva,UAAU4d,aAAe,WAK7B,OA/fiB,IA2fb91B,KAAKkzB,WACLlzB,KAAKkzB,SAAWlzB,KAAKo2B,UAGlBp2B,KAAKkzB,QAChB,EACAT,EAAQva,UAAU0d,SAAW,WACzB51B,KAAKkzB,UAlgBY,CAmgBrB,EACAT,EAAQva,UAAUyd,cAAgB,WAC9B,IAAIzC,EAAWlzB,KAAK81B,eACpB,OAAQ5C,GACJ,KAAK,IACD,OAAOlzB,KAAKq2B,UAChB,KAAK,IACD,OAAOr2B,KAAKs2B,UAChB,QACI,GAAIpD,EAAW,IACX,OAAOA,EAAW,IAGlB,MAAM,IAAI1F,EAAA,EAAY,iCAAiC7X,OAAO+Z,EAAWwD,KAIzF,EACAT,EAAQva,UAAU6d,aAAe,SAAU3b,GACvC,GAAIA,EAAOpa,KAAK8yB,aACZ,MAAM,IAAItF,EAAA,EAAY,oCAAoC7X,OAAOyE,EAAM,4BAA4BzE,OAAO3V,KAAK8yB,aAAc,MAEjI9yB,KAAK8gB,MAAM9Q,KAAK,CACZ9K,KAAM,EACNkV,KAAMA,EACN1I,IAAK,KACL0lB,UAAW,EACX/sB,IAAK,CAAC,GAEd,EACAooB,EAAQva,UAAU8d,eAAiB,SAAU5b,GACzC,GAAIA,EAAOpa,KAAK6yB,eACZ,MAAM,IAAIrF,EAAA,EAAY,sCAAsC7X,OAAOyE,EAAM,wBAAwBzE,OAAO3V,KAAK6yB,eAAgB,MAEjI7yB,KAAK8gB,MAAM9Q,KAAK,CACZ9K,KAAM,EACNkV,KAAMA,EACNmI,MAAO,IAAIpY,MAAMiQ,GACjB8c,SAAU,GAElB,EACAzE,EAAQva,UAAU+d,iBAAmB,SAAU7sB,EAAYiuB,GACvD,IAAIhJ,EACJ,GAAIjlB,EAAapJ,KAAK2yB,aAClB,MAAM,IAAInF,EAAA,EAAY,2CAA2C7X,OAAOvM,EAAY,sBAAsBuM,OAAO3V,KAAK2yB,aAAc,MAExI,GAAI3yB,KAAK6iB,MAAMzZ,WAAapJ,KAAK8hB,IAAMuV,EAAejuB,EAClD,MAAMmpB,EAEV,IACI1I,EADAyN,EAASt3B,KAAK8hB,IAAMuV,EAYxB,OATIxN,EADA7pB,KAAKu3B,kBAA+C,QAA1BlJ,EAAKruB,KAAKgzB,kBAA+B,IAAP3E,OAAgB,EAASA,EAAG+B,YAAYhnB,IAC3FpJ,KAAKgzB,WAAW7uB,OAAOnE,KAAK6iB,MAAOyU,EAAQluB,GAE/CA,EAAa,MACT,EAAA2nB,EAAA,IAAa/wB,KAAK6iB,MAAOyU,EAAQluB,IAGjC,EAAA2nB,EAAA,IAAa/wB,KAAK6iB,MAAOyU,EAAQluB,GAE9CpJ,KAAK8hB,KAAOuV,EAAejuB,EACpBygB,CACX,EACA4I,EAAQva,UAAUqf,cAAgB,WAC9B,OAAIv3B,KAAK8gB,MAAM9b,OAAS,GAEE,IADVhF,KAAK8gB,MAAM9gB,KAAK8gB,MAAM9b,OAAS,GAC9BE,IAGrB,EACAutB,EAAQva,UAAU6e,aAAe,SAAU3tB,EAAYouB,GACnD,GAAIpuB,EAAapJ,KAAK4yB,aAClB,MAAM,IAAIpF,EAAA,EAAY,oCAAoC7X,OAAOvM,EAAY,sBAAsBuM,OAAO3V,KAAK4yB,aAAc,MAEjI,IAAK5yB,KAAKszB,aAAalqB,EAAaouB,GAChC,MAAMjF,EAEV,IAAI+E,EAASt3B,KAAK8hB,IAAM0V,EACpB3N,EAAS7pB,KAAK6iB,MAAM2Q,SAAS8D,EAAQA,EAASluB,GAElD,OADApJ,KAAK8hB,KAAO0V,EAAapuB,EAClBygB,CACX,EACA4I,EAAQva,UAAU8e,gBAAkB,SAAU5c,EAAMod,GAChD,GAAIpd,EAAOpa,KAAK+yB,aACZ,MAAM,IAAIvF,EAAA,EAAY,oCAAoC7X,OAAOyE,EAAM,sBAAsBzE,OAAO3V,KAAK+yB,aAAc,MAE3H,IAAI0E,EAAUz3B,KAAKsuB,KAAKgE,QAAQtyB,KAAK8hB,IAAM0V,GACvC9xB,EAAO1F,KAAK+2B,aAAa3c,EAAMod,EAAa,GAChD,OAAOx3B,KAAK0yB,eAAevuB,OAAOuB,EAAM+xB,EAASz3B,KAAKmR,QAC1D,EACAshB,EAAQva,UAAU0e,OAAS,WACvB,OAAO52B,KAAKsuB,KAAKoJ,SAAS13B,KAAK8hB,IACnC,EACA2Q,EAAQva,UAAU2e,QAAU,WACxB,OAAO72B,KAAKsuB,KAAKqJ,UAAU33B,KAAK8hB,IACpC,EACA2Q,EAAQva,UAAU4e,QAAU,WACxB,OAAO92B,KAAKsuB,KAAKQ,UAAU9uB,KAAK8hB,IACpC,EACA2Q,EAAQva,UAAUke,OAAS,WACvB,IAAInyB,EAAQjE,KAAKsuB,KAAKoJ,SAAS13B,KAAK8hB,KAEpC,OADA9hB,KAAK8hB,MACE7d,CACX,EACAwuB,EAAQva,UAAUse,OAAS,WACvB,IAAIvyB,EAAQjE,KAAKsuB,KAAKgE,QAAQtyB,KAAK8hB,KAEnC,OADA9hB,KAAK8hB,MACE7d,CACX,EACAwuB,EAAQva,UAAUme,QAAU,WACxB,IAAIpyB,EAAQjE,KAAKsuB,KAAKqJ,UAAU33B,KAAK8hB,KAErC,OADA9hB,KAAK8hB,KAAO,EACL7d,CACX,EACAwuB,EAAQva,UAAUue,QAAU,WACxB,IAAIxyB,EAAQjE,KAAKsuB,KAAKsJ,SAAS53B,KAAK8hB,KAEpC,OADA9hB,KAAK8hB,KAAO,EACL7d,CACX,EACAwuB,EAAQva,UAAUoe,QAAU,WACxB,IAAIryB,EAAQjE,KAAKsuB,KAAKQ,UAAU9uB,KAAK8hB,KAErC,OADA9hB,KAAK8hB,KAAO,EACL7d,CACX,EACAwuB,EAAQva,UAAUwe,QAAU,WACxB,IAAIzyB,EAAQjE,KAAKsuB,KAAKuJ,SAAS73B,KAAK8hB,KAEpC,OADA9hB,KAAK8hB,KAAO,EACL7d,CACX,EACAwuB,EAAQva,UAAUqe,QAAU,WACxB,IAAItyB,GAAQ,QAAUjE,KAAKsuB,KAAMtuB,KAAK8hB,KAEtC,OADA9hB,KAAK8hB,KAAO,EACL7d,CACX,EACAwuB,EAAQva,UAAUye,QAAU,WACxB,IAAI1yB,GAAQ,QAASjE,KAAKsuB,KAAMtuB,KAAK8hB,KAErC,OADA9hB,KAAK8hB,KAAO,EACL7d,CACX,EACAwuB,EAAQva,UAAUge,QAAU,WACxB,IAAIjyB,EAAQjE,KAAKsuB,KAAKwJ,WAAW93B,KAAK8hB,KAEtC,OADA9hB,KAAK8hB,KAAO,EACL7d,CACX,EACAwuB,EAAQva,UAAUie,QAAU,WACxB,IAAIlyB,EAAQjE,KAAKsuB,KAAKyJ,WAAW/3B,KAAK8hB,KAEtC,OADA9hB,KAAK8hB,KAAO,EACL7d,CACX,EACOwuB,CACX,CAvoB4B,GCnFjBuF,EAAuB,CAAC,EAU5B,SAAS7zB,EAAOJ,EAAQk0B,GAG3B,YAFgB,IAAZA,IAAsBA,EAAUD,GACtB,IAAIvF,EAAQwF,EAAQvF,eAAgBuF,EAAQ9mB,QAAS8mB,EAAQtF,aAAcsF,EAAQrF,aAAcqF,EAAQpF,eAAgBoF,EAAQnF,aAAcmF,EAAQlF,cACtJ5uB,OAAOJ,EAC1B,CAQO,SAAS+vB,EAAY/vB,EAAQk0B,GAGhC,YAFgB,IAAZA,IAAsBA,EAAUD,GACtB,IAAIvF,EAAQwF,EAAQvF,eAAgBuF,EAAQ9mB,QAAS8mB,EAAQtF,aAAcsF,EAAQrF,aAAcqF,EAAQpF,eAAgBoF,EAAQnF,aAAcmF,EAAQlF,cACtJe,YAAY/vB,EAC/B,C,yECrBIm0B,EAAyB,WACzB,SAASA,EAAQxF,EAAgBvhB,EAASgnB,EAAUC,EAAmBC,EAAUC,EAAcC,EAAiBC,QACrF,IAAnB9F,IAA6BA,EAAiBzD,EAAA,EAAeQ,mBACjD,IAAZte,IAAsBA,OAAUnC,QACnB,IAAbmpB,IAAuBA,EANJ,UAOG,IAAtBC,IAAgCA,EANH,WAOhB,IAAbC,IAAuBA,GAAW,QACjB,IAAjBC,IAA2BA,GAAe,QACtB,IAApBC,IAA8BA,GAAkB,QACxB,IAAxBC,IAAkCA,GAAsB,GAC5Dx4B,KAAK0yB,eAAiBA,EACtB1yB,KAAKmR,QAAUA,EACfnR,KAAKm4B,SAAWA,EAChBn4B,KAAKo4B,kBAAoBA,EACzBp4B,KAAKq4B,SAAWA,EAChBr4B,KAAKs4B,aAAeA,EACpBt4B,KAAKu4B,gBAAkBA,EACvBv4B,KAAKw4B,oBAAsBA,EAC3Bx4B,KAAK8hB,IAAM,EACX9hB,KAAKsuB,KAAO,IAAIpM,SAAS,IAAIpP,YAAY9S,KAAKo4B,oBAC9Cp4B,KAAK6iB,MAAQ,IAAIzd,WAAWpF,KAAKsuB,KAAKvqB,OAC1C,CAkYA,OAjYAm0B,EAAQhgB,UAAUib,kBAAoB,WAClCnzB,KAAK8hB,IAAM,CACf,EAMAoW,EAAQhgB,UAAUugB,gBAAkB,SAAU5O,GAG1C,OAFA7pB,KAAKmzB,oBACLnzB,KAAK04B,SAAS7O,EAAQ,GACf7pB,KAAK6iB,MAAM2Q,SAAS,EAAGxzB,KAAK8hB,IACvC,EAIAoW,EAAQhgB,UAAUsG,OAAS,SAAUqL,GAGjC,OAFA7pB,KAAKmzB,oBACLnzB,KAAK04B,SAAS7O,EAAQ,GACf7pB,KAAK6iB,MAAMtd,MAAM,EAAGvF,KAAK8hB,IACpC,EACAoW,EAAQhgB,UAAUwgB,SAAW,SAAU7O,EAAQtQ,GAC3C,GAAIA,EAAQvZ,KAAKm4B,SACb,MAAM,IAAI91B,MAAM,6BAA6BsT,OAAO4D,IAE1C,MAAVsQ,EACA7pB,KAAK24B,YAEkB,kBAAX9O,EACZ7pB,KAAK44B,cAAc/O,GAEI,iBAAXA,EACZ7pB,KAAK64B,aAAahP,GAEK,iBAAXA,EACZ7pB,KAAK84B,aAAajP,GAGlB7pB,KAAK+4B,aAAalP,EAAQtQ,EAElC,EACA2e,EAAQhgB,UAAU8gB,wBAA0B,SAAUC,GAClD,IAAIC,EAAel5B,KAAK8hB,IAAMmX,EAC1Bj5B,KAAKsuB,KAAKllB,WAAa8vB,GACvBl5B,KAAKm5B,aAA4B,EAAfD,EAE1B,EACAhB,EAAQhgB,UAAUihB,aAAe,SAAUC,GACvC,IAAI/zB,EAAY,IAAIyN,YAAYsmB,GAC5BC,EAAW,IAAIj0B,WAAWC,GAC1Bi0B,EAAU,IAAIpX,SAAS7c,GAC3Bg0B,EAAS/zB,IAAItF,KAAK6iB,OAClB7iB,KAAKsuB,KAAOgL,EACZt5B,KAAK6iB,MAAQwW,CACjB,EACAnB,EAAQhgB,UAAUygB,UAAY,WAC1B34B,KAAKu5B,QAAQ,IACjB,EACArB,EAAQhgB,UAAU0gB,cAAgB,SAAU/O,IACzB,IAAXA,EACA7pB,KAAKu5B,QAAQ,KAGbv5B,KAAKu5B,QAAQ,IAErB,EACArB,EAAQhgB,UAAU2gB,aAAe,SAAUhP,GACnC2P,OAAOC,cAAc5P,KAAY7pB,KAAKw4B,oBAClC3O,GAAU,EACNA,EAAS,IAET7pB,KAAKu5B,QAAQ1P,GAERA,EAAS,KAEd7pB,KAAKu5B,QAAQ,KACbv5B,KAAKu5B,QAAQ1P,IAERA,EAAS,OAEd7pB,KAAKu5B,QAAQ,KACbv5B,KAAK05B,SAAS7P,IAETA,EAAS,YAEd7pB,KAAKu5B,QAAQ,KACbv5B,KAAK25B,SAAS9P,KAId7pB,KAAKu5B,QAAQ,KACbv5B,KAAK45B,SAAS/P,IAIdA,IAAW,GAEX7pB,KAAKu5B,QAAQ,IAAQ1P,EAAS,IAEzBA,IAAW,KAEhB7pB,KAAKu5B,QAAQ,KACbv5B,KAAK65B,QAAQhQ,IAERA,IAAW,OAEhB7pB,KAAKu5B,QAAQ,KACbv5B,KAAK85B,SAASjQ,IAETA,IAAW,YAEhB7pB,KAAKu5B,QAAQ,KACbv5B,KAAK+5B,SAASlQ,KAId7pB,KAAKu5B,QAAQ,KACbv5B,KAAKg6B,SAASnQ,IAMlB7pB,KAAKs4B,cAELt4B,KAAKu5B,QAAQ,KACbv5B,KAAKi6B,SAASpQ,KAId7pB,KAAKu5B,QAAQ,KACbv5B,KAAKk6B,SAASrQ,GAG1B,EACAqO,EAAQhgB,UAAUiiB,kBAAoB,SAAU/wB,GAC5C,GAAIA,EAAa,GAEbpJ,KAAKu5B,QAAQ,IAAOnwB,QAEnB,GAAIA,EAAa,IAElBpJ,KAAKu5B,QAAQ,KACbv5B,KAAKu5B,QAAQnwB,QAEZ,GAAIA,EAAa,MAElBpJ,KAAKu5B,QAAQ,KACbv5B,KAAK05B,SAAStwB,OAEb,MAAIA,EAAa,YAMlB,MAAM,IAAI/G,MAAM,oBAAoBsT,OAAOvM,EAAY,oBAJvDpJ,KAAKu5B,QAAQ,KACbv5B,KAAK25B,SAASvwB,EAIlB,CACJ,EACA8uB,EAAQhgB,UAAU4gB,aAAe,SAAUjP,GAGvC,GADgBA,EAAO7kB,OACP,KAAwB,CACpC,IAAIoE,GAAa,EAAA2nB,EAAA,IAAUlH,GAC3B7pB,KAAKg5B,wBAJW,EAI6B5vB,GAC7CpJ,KAAKm6B,kBAAkB/wB,IACvB,EAAA2nB,EAAA,IAAalH,EAAQ7pB,KAAK6iB,MAAO7iB,KAAK8hB,KACtC9hB,KAAK8hB,KAAO1Y,CAChB,MAEQA,GAAa,EAAA2nB,EAAA,IAAUlH,GAC3B7pB,KAAKg5B,wBAXW,EAW6B5vB,GAC7CpJ,KAAKm6B,kBAAkB/wB,IACvB,EAAA2nB,EAAA,IAAalH,EAAQ7pB,KAAK6iB,MAAO7iB,KAAK8hB,KACtC9hB,KAAK8hB,KAAO1Y,CAEpB,EACA8uB,EAAQhgB,UAAU6gB,aAAe,SAAUlP,EAAQtQ,GAE/C,IAAI6gB,EAAMp6B,KAAK0yB,eAAepD,YAAYzF,EAAQ7pB,KAAKmR,SACvD,GAAW,MAAPipB,EACAp6B,KAAKq6B,gBAAgBD,QAEpB,GAAIjwB,MAAMC,QAAQyf,GACnB7pB,KAAKs6B,YAAYzQ,EAAQtQ,QAExB,GAAIzG,YAAYC,OAAO8W,GACxB7pB,KAAKu6B,aAAa1Q,OAEjB,IAAsB,iBAAXA,EAKZ,MAAM,IAAIxnB,MAAM,wBAAwBsT,OAAOzN,OAAOgQ,UAAU3K,SAAS9B,MAAMoe,KAJ/E7pB,KAAKw6B,UAAU3Q,EAAQtQ,EAK3B,CACJ,EACA2e,EAAQhgB,UAAUqiB,aAAe,SAAU1Q,GACvC,IAAIzP,EAAOyP,EAAOzgB,WAClB,GAAIgR,EAAO,IAEPpa,KAAKu5B,QAAQ,KACbv5B,KAAKu5B,QAAQnf,QAEZ,GAAIA,EAAO,MAEZpa,KAAKu5B,QAAQ,KACbv5B,KAAK05B,SAAStf,OAEb,MAAIA,EAAO,YAMZ,MAAM,IAAI/X,MAAM,qBAAqBsT,OAAOyE,IAJ5Cpa,KAAKu5B,QAAQ,KACbv5B,KAAK25B,SAASvf,EAIlB,CACA,IAAIyI,GAAQ,OAAiBgH,GAC7B7pB,KAAKy6B,SAAS5X,EAClB,EACAqV,EAAQhgB,UAAUoiB,YAAc,SAAUzQ,EAAQtQ,GAC9C,IAAIa,EAAOyP,EAAO7kB,OAClB,GAAIoV,EAAO,GAEPpa,KAAKu5B,QAAQ,IAAOnf,QAEnB,GAAIA,EAAO,MAEZpa,KAAKu5B,QAAQ,KACbv5B,KAAK05B,SAAStf,OAEb,MAAIA,EAAO,YAMZ,MAAM,IAAI/X,MAAM,oBAAoBsT,OAAOyE,IAJ3Cpa,KAAKu5B,QAAQ,KACbv5B,KAAK25B,SAASvf,EAIlB,CACA,IAAK,IAAIoW,EAAK,EAAGkK,EAAW7Q,EAAQ2G,EAAKkK,EAAS11B,OAAQwrB,IAAM,CAC5D,IAAIpT,EAAOsd,EAASlK,GACpBxwB,KAAK04B,SAAStb,EAAM7D,EAAQ,EAChC,CACJ,EACA2e,EAAQhgB,UAAUyiB,sBAAwB,SAAU9Q,EAAQ9Y,GAExD,IADA,IAAI6pB,EAAQ,EACHpK,EAAK,EAAGqK,EAAS9pB,EAAMyf,EAAKqK,EAAO71B,OAAQwrB,SAE5BxhB,IAAhB6a,EADMgR,EAAOrK,KAEboK,IAGR,OAAOA,CACX,EACA1C,EAAQhgB,UAAUsiB,UAAY,SAAU3Q,EAAQtQ,GAC5C,IAAIxI,EAAO7I,OAAO6I,KAAK8Y,GACnB7pB,KAAKq4B,UACLtnB,EAAK+pB,OAET,IAAI1gB,EAAOpa,KAAKu4B,gBAAkBv4B,KAAK26B,sBAAsB9Q,EAAQ9Y,GAAQA,EAAK/L,OAClF,GAAIoV,EAAO,GAEPpa,KAAKu5B,QAAQ,IAAOnf,QAEnB,GAAIA,EAAO,MAEZpa,KAAKu5B,QAAQ,KACbv5B,KAAK05B,SAAStf,OAEb,MAAIA,EAAO,YAMZ,MAAM,IAAI/X,MAAM,yBAAyBsT,OAAOyE,IAJhDpa,KAAKu5B,QAAQ,KACbv5B,KAAK25B,SAASvf,EAIlB,CACA,IAAK,IAAIoW,EAAK,EAAGuK,EAAShqB,EAAMyf,EAAKuK,EAAO/1B,OAAQwrB,IAAM,CACtD,IAAI9e,EAAMqpB,EAAOvK,GACbvsB,EAAQ4lB,EAAOnY,GACb1R,KAAKu4B,sBAA6BvpB,IAAV/K,IAC1BjE,KAAK84B,aAAapnB,GAClB1R,KAAK04B,SAASz0B,EAAOsV,EAAQ,GAErC,CACJ,EACA2e,EAAQhgB,UAAUmiB,gBAAkB,SAAUD,GAC1C,IAAIhgB,EAAOggB,EAAI10B,KAAKV,OACpB,GAAa,IAAToV,EAEApa,KAAKu5B,QAAQ,UAEZ,GAAa,IAATnf,EAELpa,KAAKu5B,QAAQ,UAEZ,GAAa,IAATnf,EAELpa,KAAKu5B,QAAQ,UAEZ,GAAa,IAATnf,EAELpa,KAAKu5B,QAAQ,UAEZ,GAAa,KAATnf,EAELpa,KAAKu5B,QAAQ,UAEZ,GAAInf,EAAO,IAEZpa,KAAKu5B,QAAQ,KACbv5B,KAAKu5B,QAAQnf,QAEZ,GAAIA,EAAO,MAEZpa,KAAKu5B,QAAQ,KACbv5B,KAAK05B,SAAStf,OAEb,MAAIA,EAAO,YAMZ,MAAM,IAAI/X,MAAM,+BAA+BsT,OAAOyE,IAJtDpa,KAAKu5B,QAAQ,KACbv5B,KAAK25B,SAASvf,EAIlB,CACApa,KAAK65B,QAAQO,EAAIl1B,MACjBlF,KAAKy6B,SAASL,EAAI10B,KACtB,EACAwyB,EAAQhgB,UAAUqhB,QAAU,SAAUt1B,GAClCjE,KAAKg5B,wBAAwB,GAC7Bh5B,KAAKsuB,KAAK0M,SAASh7B,KAAK8hB,IAAK7d,GAC7BjE,KAAK8hB,KACT,EACAoW,EAAQhgB,UAAUuiB,SAAW,SAAUjrB,GACnC,IAAI4K,EAAO5K,EAAOxK,OAClBhF,KAAKg5B,wBAAwB5e,GAC7Bpa,KAAK6iB,MAAMvd,IAAIkK,EAAQxP,KAAK8hB,KAC5B9hB,KAAK8hB,KAAO1H,CAChB,EACA8d,EAAQhgB,UAAU2hB,QAAU,SAAU51B,GAClCjE,KAAKg5B,wBAAwB,GAC7Bh5B,KAAKsuB,KAAK2M,QAAQj7B,KAAK8hB,IAAK7d,GAC5BjE,KAAK8hB,KACT,EACAoW,EAAQhgB,UAAUwhB,SAAW,SAAUz1B,GACnCjE,KAAKg5B,wBAAwB,GAC7Bh5B,KAAKsuB,KAAK4M,UAAUl7B,KAAK8hB,IAAK7d,GAC9BjE,KAAK8hB,KAAO,CAChB,EACAoW,EAAQhgB,UAAU4hB,SAAW,SAAU71B,GACnCjE,KAAKg5B,wBAAwB,GAC7Bh5B,KAAKsuB,KAAK6M,SAASn7B,KAAK8hB,IAAK7d,GAC7BjE,KAAK8hB,KAAO,CAChB,EACAoW,EAAQhgB,UAAUyhB,SAAW,SAAU11B,GACnCjE,KAAKg5B,wBAAwB,GAC7Bh5B,KAAKsuB,KAAKE,UAAUxuB,KAAK8hB,IAAK7d,GAC9BjE,KAAK8hB,KAAO,CAChB,EACAoW,EAAQhgB,UAAU6hB,SAAW,SAAU91B,GACnCjE,KAAKg5B,wBAAwB,GAC7Bh5B,KAAKsuB,KAAK8M,SAASp7B,KAAK8hB,IAAK7d,GAC7BjE,KAAK8hB,KAAO,CAChB,EACAoW,EAAQhgB,UAAU+hB,SAAW,SAAUh2B,GACnCjE,KAAKg5B,wBAAwB,GAC7Bh5B,KAAKsuB,KAAK+M,WAAWr7B,KAAK8hB,IAAK7d,GAC/BjE,KAAK8hB,KAAO,CAChB,EACAoW,EAAQhgB,UAAUgiB,SAAW,SAAUj2B,GACnCjE,KAAKg5B,wBAAwB,GAC7Bh5B,KAAKsuB,KAAKgN,WAAWt7B,KAAK8hB,IAAK7d,GAC/BjE,KAAK8hB,KAAO,CAChB,EACAoW,EAAQhgB,UAAU0hB,SAAW,SAAU31B,GACnCjE,KAAKg5B,wBAAwB,IAC7B,QAAUh5B,KAAKsuB,KAAMtuB,KAAK8hB,IAAK7d,GAC/BjE,KAAK8hB,KAAO,CAChB,EACAoW,EAAQhgB,UAAU8hB,SAAW,SAAU/1B,GACnCjE,KAAKg5B,wBAAwB,IAC7B,QAASh5B,KAAKsuB,KAAMtuB,KAAK8hB,IAAK7d,GAC9BjE,KAAK8hB,KAAO,CAChB,EACOoW,CACX,CAxZ4B,GCLxBqD,EAAuB,CAAC,EAOrB,SAAS/c,EAAOva,EAAOg0B,GAG1B,YAFgB,IAAZA,IAAsBA,EAAUsD,GACtB,IAAIrD,EAAQD,EAAQvF,eAAgBuF,EAAQ9mB,QAAS8mB,EAAQE,SAAUF,EAAQG,kBAAmBH,EAAQI,SAAUJ,EAAQK,aAAcL,EAAQM,gBAAiBN,EAAQO,qBAC1KC,gBAAgBx0B,EACnC,C,sECXO,IAAIu3B,EAAa,WAGjB,SAASC,EAAUnN,EAAMgJ,EAAQrzB,GACpC,IAAIy3B,EAAOz3B,EAAQ,WACf03B,EAAM13B,EACVqqB,EAAKE,UAAU8I,EAAQoE,GACvBpN,EAAKE,UAAU8I,EAAS,EAAGqE,EAC/B,CACO,SAASC,EAAStN,EAAMgJ,EAAQrzB,GACnC,IAAIy3B,EAAOp4B,KAAKsrB,MAAM3qB,EAAQ,YAC1B03B,EAAM13B,EACVqqB,EAAKE,UAAU8I,EAAQoE,GACvBpN,EAAKE,UAAU8I,EAAS,EAAGqE,EAC/B,CACO,SAASE,EAASvN,EAAMgJ,GAG3B,OAAc,WAFHhJ,EAAKuJ,SAASP,GACfhJ,EAAKQ,UAAUwI,EAAS,EAEtC,CACO,SAASwE,EAAUxN,EAAMgJ,GAG5B,OAAc,WAFHhJ,EAAKQ,UAAUwI,GAChBhJ,EAAKQ,UAAUwI,EAAS,EAEtC,C,gBCzBO,SAASyE,EAAiBh4B,GAC7B,OAAIA,aAAkBqB,WACXrB,EAEF+O,YAAYC,OAAOhP,GACjB,IAAIqB,WAAWrB,EAAOA,OAAQA,EAAO6e,WAAY7e,EAAOqF,YAE1DrF,aAAkB+O,YAChB,IAAI1N,WAAWrB,GAIfqB,WAAWiD,KAAKtE,EAE/B,CACO,SAASi4B,EAAej4B,GAC3B,GAAIA,aAAkB+O,YAClB,OAAO,IAAIoP,SAASne,GAExB,IAAIk4B,EAAaF,EAAiBh4B,GAClC,OAAO,IAAIme,SAAS+Z,EAAWl4B,OAAQk4B,EAAWrZ,WAAYqZ,EAAW7yB,WAC7E,C,oHCrBIilB,EAAIkG,EAAIC,E,SAGR0H,GAA8C,oBAAZvuB,SAA+J,WAA1D,QAAxE0gB,EAAiB,OAAZ1gB,cAAgC,IAAZA,aAAqB,EAASA,QAAQwuB,WAAwB,IAAP9N,OAAgB,EAASA,EAAkB,iBACnK,oBAAhB+N,aACgB,oBAAhBt4B,YACJ,SAASu4B,EAAUjZ,GAItB,IAHA,IAAIkZ,EAAYlZ,EAAIpe,OAChBoE,EAAa,EACb0Y,EAAM,EACHA,EAAMwa,GAAW,CACpB,IAAIr4B,EAAQmf,EAAImZ,WAAWza,KAC3B,GAAa,WAAR7d,EAKA,GAAa,WAARA,EAIL,CAED,GAAIA,GAAS,OAAUA,GAAS,OAExB6d,EAAMwa,EAAW,CACjB,IAAIzpB,EAAQuQ,EAAImZ,WAAWza,GACF,QAAZ,MAARjP,OACCiP,EACF7d,IAAkB,KAARA,IAAkB,KAAe,KAAR4O,GAAiB,MAE5D,CAQAzJ,GANS,WAARnF,EAMa,EAJA,CAMtB,MAtBImF,GAAc,OALdA,GA4BR,CACA,OAAOA,CACX,CACO,SAASozB,EAAapZ,EAAKqZ,EAAQC,GAItC,IAHA,IAAIJ,EAAYlZ,EAAIpe,OAChBsyB,EAASoF,EACT5a,EAAM,EACHA,EAAMwa,GAAW,CACpB,IAAIr4B,EAAQmf,EAAImZ,WAAWza,KAC3B,GAAa,WAAR7d,EAAL,CAKK,GAAa,WAARA,EAIL,CAED,GAAIA,GAAS,OAAUA,GAAS,OAExB6d,EAAMwa,EAAW,CACjB,IAAIzpB,EAAQuQ,EAAImZ,WAAWza,GACF,QAAZ,MAARjP,OACCiP,EACF7d,IAAkB,KAARA,IAAkB,KAAe,KAAR4O,GAAiB,MAE5D,CAES,WAAR5O,GAODw4B,EAAOnF,KAAcrzB,GAAS,GAAM,EAAQ,IAC5Cw4B,EAAOnF,KAAcrzB,GAAS,GAAM,GAAQ,IAC5Cw4B,EAAOnF,KAAcrzB,GAAS,EAAK,GAAQ,MAP3Cw4B,EAAOnF,KAAcrzB,GAAS,GAAM,GAAQ,IAC5Cw4B,EAAOnF,KAAcrzB,GAAS,EAAK,GAAQ,IAQnD,MAzBIw4B,EAAOnF,KAAcrzB,GAAS,EAAK,GAAQ,IA0B/Cw4B,EAAOnF,KAAqB,GAARrzB,EAAgB,GADpC,MA9BIw4B,EAAOnF,KAAYrzB,CAgC3B,CACJ,CACA,IAAI04B,EAAoBT,EAA0B,IAAIE,iBAAgBptB,EAC3D4tB,EAA0BV,EAEZ,oBAAZvuB,SAA+J,WAA1D,QAAxE4mB,EAAiB,OAAZ5mB,cAAgC,IAAZA,aAAqB,EAASA,QAAQwuB,WAAwB,IAAP5H,OAAgB,EAASA,EAAkB,eAC3J,IACA,EAHJ,KAUKsI,GAAgBF,aAA6D,EAASA,EAAkBG,YAHnH,SAAgC1Z,EAAKqZ,EAAQC,GACzCC,EAAkBG,WAAW1Z,EAAKqZ,EAAOjJ,SAASkJ,GACtD,EALA,SAA4BtZ,EAAKqZ,EAAQC,GACrCD,EAAOn3B,IAAIq3B,EAAkBne,OAAO4E,GAAMsZ,EAC9C,EAKIK,EAAa,KACV,SAASC,EAAana,EAAOyN,EAAalnB,GAK7C,IAJA,IAAIkuB,EAAShH,EACT2M,EAAM3F,EAASluB,EACf8zB,EAAQ,GACRvzB,EAAS,GACN2tB,EAAS2F,GAAK,CACjB,IAAIE,EAAQta,EAAMyU,KAClB,GAAa,IAAR6F,EAIA,GAAuB,MAAV,IAARA,GAAwB,CAE9B,IAAIC,EAA0B,GAAlBva,EAAMyU,KAClB4F,EAAMltB,MAAe,GAARmtB,IAAiB,EAAKC,EACvC,MACK,GAAuB,MAAV,IAARD,GAAwB,CAE1BC,EAA0B,GAAlBva,EAAMyU,KAAlB,IACI+F,EAA0B,GAAlBxa,EAAMyU,KAClB4F,EAAMltB,MAAe,GAARmtB,IAAiB,GAAOC,GAAS,EAAKC,EACvD,MACK,GAAuB,MAAV,IAARF,GAAwB,CAE9B,IAGIG,GAAiB,EAARH,IAAiB,IAH1BC,EAA0B,GAAlBva,EAAMyU,OAG8B,IAF5C+F,EAA0B,GAAlBxa,EAAMyU,OAEgD,EADpC,GAAlBzU,EAAMyU,KAEdgG,EAAO,QACPA,GAAQ,MACRJ,EAAMltB,KAAOstB,IAAS,GAAM,KAAS,OACrCA,EAAO,MAAiB,KAAPA,GAErBJ,EAAMltB,KAAKstB,EACf,MAEIJ,EAAMltB,KAAKmtB,QA3BXD,EAAMltB,KAAKmtB,GA6BXD,EAAMl4B,QAAU+3B,IAChBpzB,GAAUqX,OAAOuc,aAAa9xB,MAAMuV,OAAQkc,GAC5CA,EAAMl4B,OAAS,EAEvB,CAIA,OAHIk4B,EAAMl4B,OAAS,IACf2E,GAAUqX,OAAOuc,aAAa9xB,MAAMuV,OAAQkc,IAEzCvzB,CACX,CACA,IAAI6zB,EAAoBtB,EAA0B,IAAIp4B,YAAgB,KAC3D25B,EAA0BvB,EAEZ,oBAAZvuB,SAA8J,WAAzD,QAAxE6mB,EAAiB,OAAZ7mB,cAAgC,IAAZA,aAAqB,EAASA,QAAQwuB,WAAwB,IAAP3H,OAAgB,EAASA,EAAiB,cAC1J,IACA,EAHJ,KAIC,SAASkJ,EAAa7a,EAAOyN,EAAalnB,GAC7C,IAAIu0B,EAAc9a,EAAM2Q,SAASlD,EAAaA,EAAclnB,GAC5D,OAAOo0B,EAAkBr5B,OAAOw5B,EACpC,C,GC7JIC,yBAA2B,CAAC,EAGhC,SAASC,oBAAoBC,GAE5B,IAAIC,EAAeH,yBAAyBE,GAC5C,QAAqB9uB,IAAjB+uB,EACH,OAAOA,EAAaC,QAGrB,IAAIC,EAASL,yBAAyBE,GAAY,CAGjDE,QAAS,CAAC,GAOX,OAHAE,oBAAoBJ,GAAUG,EAAQA,EAAOD,QAASH,qBAG/CI,EAAOD,OACf,CCrBAH,oBAAoB1Q,EAAI,CAAC6Q,EAASG,KACjC,IAAI,IAAIzsB,KAAOysB,EACXN,oBAAoB9L,EAAEoM,EAAYzsB,KAASmsB,oBAAoB9L,EAAEiM,EAAStsB,IAC5ExJ,OAAO0lB,eAAeoQ,EAAStsB,EAAK,CAAEoc,YAAY,EAAMxP,IAAK6f,EAAWzsB,IAE1E,ECNDmsB,oBAAoB9L,EAAI,CAAChoB,EAAKq0B,IAAUl2B,OAAOgQ,UAAU9E,eAAe+E,KAAKpO,EAAKq0B,G,mjCC+BlF,MAAMC,UAAY,IAElB,MAAMC,uBACJ,WAAA/+B,CACEC,EACAC,EACAC,EACAC,EACAC,EAAqB,KACrBC,EAAU,GACV0+B,EAAiB,KACjBz+B,EAAyB,KACzB0+B,EAAqB,OAErB,mDAAOh/B,GAAcC,EAAW,yCAChCO,KAAKC,YAAcT,EACnBQ,KAAKG,WAAaV,EAClBO,KAAKI,WAAaV,EAClBM,KAAKK,OAASV,EACdK,KAAKM,oBAAsBV,EAC3BI,KAAKy+B,WAAa,KAClBz+B,KAAKU,gBAAkB,KACvBV,KAAKY,kBAAoB,KACzBZ,KAAKW,qBAAuB,KAC5BX,KAAKO,SAAWV,EAChBG,KAAK0+B,gBAAkBH,GAAkBI,UACzC3+B,KAAKa,SAAU,EACfb,KAAK4+B,aAAe,KACpB5+B,KAAKe,gBAAkB,KACvBf,KAAKc,mBAAoB,EACzBd,KAAKQ,wBAA0BV,EAC/BE,KAAKgB,WAAa,KAClBhB,KAAK6+B,oBAAsB,KAC3B7+B,KAAK6qB,cAAgB,KACrB7qB,KAAK8+B,oBAAsB,IAAI3xB,IAC/BnN,KAAK++B,oBAAsBP,CAC7B,CAKA,QAAAQ,GAEMh/B,KAAK6+B,sBACPtrB,cAAcvT,KAAK6+B,qBACnB7+B,KAAK6+B,oBAAsB,MAI7B,IAAK,MAAMp1B,KAAazJ,KAAK8+B,oBAC3Bl1B,aAAaH,GAEfzJ,KAAK8+B,oBAAoBpzB,OAC3B,CAEA,UAAAvK,CAAWC,IACT,mDAAOA,EAAS,uBAChBpB,KAAKU,gBAAkBU,CACzB,CAEA,YAAAE,CAAaF,GACXpB,KAAKY,kBAAoBQ,CAC3B,CAEA,eAAAC,CAAgBD,GACdpB,KAAKW,qBAAuBS,CAC9B,CAEA,yBAAM69B,CAAoBz/B,EAAY0/B,GAAmB,GACvD,OAAO,IAAIh9B,SAAQ,CAACC,EAASqH,KAC3BxJ,KAAK4+B,cAAe,EACpB,MAAMO,EAAY,IAAIn/B,KAAK0+B,gBAAgBl/B,GAC3C2/B,EAAUlT,WAAa,cAEvBkT,EAAUrU,OAAS,KACjBnpB,QAAQC,KAAK,oCACbO,EAAQg9B,EAAU,EAGpBA,EAAUrZ,QAAWzY,IACnB1L,QAAQwB,MAAM,8BAA+BkK,GAC7C7D,EAAO,IAAInH,MAAM,+BAA+BgL,KAAS,EAG3D8xB,EAAUnU,QAAW3d,IACA,OAAfA,EAAM+xB,MAAiBF,GACzBv9B,QAAQC,KACN,qEAEF5B,KAAK4+B,cAAe,EACpB5+B,KAAKq/B,sCAAsC7/B,GACxCkK,KAAKvH,GACL0H,MAAML,IACAxJ,KAAKW,sBACdX,KAAKW,qBAAqB0M,EAAMtH,OAClC,CACD,GAEL,CAEA,2CAAMs5B,CAAsC7/B,GAE1C,MAAM8/B,EAAmB,GAGrBt/B,KAAKG,YACPm/B,EAAiBtvB,KAAK,aAAauvB,mBAAmBv/B,KAAKG,eACzDH,KAAKI,YACPk/B,EAAiBtvB,KAAK,aAAauvB,mBAAmBv/B,KAAKI,eACzDJ,KAAKK,QACPi/B,EAAiBtvB,KAAK,SAASuvB,mBAAmBv/B,KAAKK,WACrDL,KAAKM,qBACPg/B,EAAiBtvB,KACf,sBAAsBuvB,mBAAmBv/B,KAAKM,wBAIlD,MAIMk/B,EAAWhgC,GAHf8/B,EAAiBt6B,OAAS,EAAI,IAAIs6B,EAAiBrvB,KAAK,OAAS,IAKnE,aAAajQ,KAAKi/B,oBAAoBO,GAAU,EAClD,CAEA,qBAAAC,GACE,OAAO,IAAIv9B,SAAQ,CAACC,EAASqH,KAC3BxJ,KAAKy+B,WAAW7W,UAAava,IAC3B,MAAM3H,EAAO2H,EAAM3H,KACbg6B,EAAgBh7B,KAAKC,MAAMe,GACjC,GAA0B,mBAAtBg6B,EAAcx6B,KAgCX,IAA0B,SAAtBw6B,EAAcx6B,KAAiB,CACxC,MAAM/B,EAAQ,2BAA6Bu8B,EAAct8B,QAGzD,OAFAzB,QAAQwB,MAAM,sBAAwBA,QACtCqG,EAAO,IAAInH,MAAMc,GAEnB,CAUE,OATAxB,QAAQwB,MACN,uEACAuC,QAEF8D,EACE,IAAInH,MACF,uEAIN,CA/CErC,KAAKe,gBAAkB2+B,EACnB1/B,KAAKI,aACP,mDACEJ,KAAKe,gBAAgBrB,YAAcM,KAAKI,WACxC,qCAAqCJ,KAAKe,gBAAgBrB,wBAAwBM,KAAKI,cAGvFJ,KAAKe,gBAAgBnB,qBACvBI,KAAKM,oBAAsBN,KAAKe,gBAAgBnB,oBAE9CI,KAAKe,gBAAgB4+B,8BAGrB3/B,KAAKF,uBACLE,KAAKe,gBAAgB4+B,6BAA+B,MAEpDh+B,QAAQkD,KACN,uCAAuC7E,KAAKF,2EAA2EE,KAAKe,gBAAgB4+B,kCAE9I3/B,KAAKF,uBACHE,KAAKe,gBAAgB4+B,6BAA+B,KAG1D3/B,KAAKgB,WAAahB,KAAKe,gBAAgBC,YAAc,KACrDW,QAAQqP,IACN,oDAAoDhR,KAAKe,gBAAgBrB,0BAA0BM,KAAKgB,cAEtGhB,KAAKe,gBAAgB6+B,cACvBj+B,QAAQqP,IAAI,GAAGhR,KAAKe,gBAAgB6+B,gBAEtCz9B,EAAQnC,KAAKe,gBAiBf,CACD,GAEL,CAEA,UAAMW,GACJC,QAAQqP,IACN,yCACAhR,KAAKC,YAAYqE,MAAM,KAAK,IAE9B,IAEE,GADAtE,KAAKy+B,iBAAmBz+B,KAAKi/B,oBAAoBj/B,KAAKC,aAClDD,KAAK4+B,aACP,MAAM,IAAIv8B,MACR,+DAIJ,MAAMw9B,EAAWn7B,KAAKgG,UAAU,CAC9BjL,UAAWO,KAAKG,WAChBT,UAAWM,KAAKI,WAChBT,MAAOK,KAAKK,OACZT,mBAAoBI,KAAKM,sBA8C3B,OA5CAN,KAAKy+B,WAAW1T,KAAK8U,SAEf,mDACJ7/B,KAAKy/B,wBACLz/B,KAAKO,SACL,uDAEEP,KAAKQ,wBAA0B,GACjC4B,YAAW,KACTpC,KAAK8/B,sBACL9/B,KAAK6+B,oBAAsB3gB,aAAY,KACrCle,KAAK8/B,qBAAqB,GACM,IAA/B9/B,KAAKQ,wBAA+B,GACtC,KAGLR,KAAKc,mBAAoB,EACzBd,KAAKa,SAAU,EACfb,KAAKy+B,WAAW7W,UAAava,IAC3B,GAA0B,iBAAfA,EAAM3H,KAAmB,CAClC,MAAMq6B,EAAar7B,KAAKC,MAAM0I,EAAM3H,MAEZ,uBAApBq6B,EAAW76B,KACblF,KAAKM,oBAAsBy/B,EAAWngC,mBAGtC+B,QAAQqP,IAAI,oCAAqC+uB,EAErD,MACE//B,KAAKU,gBAAgB2M,EAAM3H,KAC7B,EAGF1F,KAAKy+B,WAAW3Y,QAAWzY,IACzB1L,QAAQwB,MAAM,8BAA+BkK,GAE7CrN,KAAKg/B,UAAU,EAGjBh/B,KAAKy+B,WAAWzT,QAAUhrB,KAAKggC,cAAc34B,KAAKrH,MAE9CA,KAAKY,mBACPZ,KAAKY,kBAAkBZ,KAAKe,iBAEvBf,KAAKe,eACd,CAAE,MAAOoC,GAQP,MANAnD,KAAKg/B,WACLr9B,QAAQwB,MACN,uBACAnD,KAAKC,YAAYqE,MAAM,KAAK,GAC5BnB,GAEIA,CACR,CACF,CAEA,mBAAA28B,GACE,GAAI9/B,KAAKy+B,YAAcz+B,KAAKy+B,WAAW5Y,aAAe8Y,UAAUsB,KAAM,CACpE,MAAMC,EAAiBx7B,KAAKgG,UAAU,CAAExF,KAAM,kBAC9ClF,KAAKy+B,WAAW1T,KAAKmV,EAEvB,CACF,CAEA,aAAAF,CAAc3yB,GACZ,IACGrN,KAAKa,SACNb,KAAKy+B,YACLz+B,KAAKy+B,WAAW5Y,aAAe8Y,UAAUwB,QAOzC,GAJAngC,KAAKg/B,WAIDh/B,KAAKc,kBAAmB,CACtB,CAAC,IAAM,MAAMqE,SAASkI,EAAM+xB,MAC9Bz9B,QAAQkD,KACN,2DAA2DwI,EAAM+xB,UAAU/xB,EAAMtH,iCAGnFpE,QAAQkD,KACN,0DACAwI,EAAM+xB,KACN/xB,EAAMtH,QAIV,IAAIvD,EAAQ,EACZ,MAAM49B,EAAY,IACZC,EAAW,IACXC,EAAY,GAEZC,EAAYp6B,UAEhB,GAAInG,KAAKa,QACPc,QAAQC,KAAK,qDAIf,IACED,QAAQkD,KACN,mBAAmB7E,KAAKC,YAAYqE,MAAM,KAAK,gBAAgB9B,YAG3DxC,KAAK0B,aAKL,IAAIQ,SAASC,GAAYC,WAAWD,EAAS,OAG/CnC,KAAK6qB,gBACPlpB,QAAQC,KAAK,6CACb5B,KAAKy+B,WAAW1T,KAAK/qB,KAAK6qB,eAC1B7qB,KAAK6qB,cAAgB,MAEvBlpB,QAAQkD,KACN,sCAAsC7E,KAAKC,wCAGzCD,KAAKY,mBACPZ,KAAKY,kBAAkBZ,KAAKe,gBAEhC,CAAE,MAAO4S,GACP,GAAI,GAAGA,IAAIxO,SAAS,2BAOlB,OANAxD,QAAQkD,KAAK,+BAAgC8O,GAE7C3T,KAAKa,SAAU,OACXb,KAAKW,sBACPX,KAAKW,qBAAqB,gCAAgCgT,MAGvD,GAAI,GAAGA,IAAIxO,SAAS,wBASzB,OARAxD,QAAQwB,MACN,GAAGwQ,uNAGL3T,KAAKa,SAAU,OACXb,KAAKW,sBACPX,KAAKW,qBAAqB,mBAAmBgT,MAMlC,iBAAXA,EAAE9M,MAA2B8M,EAAEvQ,QAAQ+B,SAAS,WAClDxD,QAAQwB,MAAM,sCAAsCwQ,EAAEvQ,WAE3C,iBAAXuQ,EAAE9M,MACF8M,EAAEvQ,QAAQ+B,SAAS,WAEnBxD,QAAQwB,MACN,2CAA2CwQ,EAAEvQ,WAG/CzB,QAAQwB,MACN,yCAAyCwQ,EAAEvQ,WAK/C,MAAMC,EAAQC,KAAKC,IAAI68B,EAAY98B,KAAKE,IAAI,EAAGhB,GAAQ69B,GAEjDG,GAA0B,EAAhBl9B,KAAK0f,SAAe,GAAKsd,EAAYj9B,EAC/Co9B,EAAan9B,KAAK2lB,IAAI,IAAK5lB,EAAQm9B,GAEzC7+B,QAAQoK,MACN,YAAY00B,EAAa,KAAMh9B,QAAQ,wCAIzC,MAAMgG,EAAYrH,YAAW+D,UAC3BnG,KAAK8+B,oBAAoB4B,OAAOj3B,GAI9BzJ,KAAKy+B,YACLz+B,KAAKy+B,WAAW5Y,aAAe8Y,UAAUsB,KAEzCt+B,QAAQC,KAAK,kCAKX5B,KAAKa,QACPc,QAAQC,KAAK,iDAIfY,GAAS,EACLA,EAAQ67B,gBACJkC,KAEN5+B,QAAQwB,MACN,6BAA6Bk7B,kCAG/Br+B,KAAKa,SAAU,EAEXb,KAAKW,sBACPX,KAAKW,qBACH,uCAON,GACC8/B,GACHzgC,KAAK8+B,oBAAoB6B,IAAIl3B,EAC/B,GAEF82B,GACF,OAGAvgC,KAAKg/B,WACDh/B,KAAKW,sBACPX,KAAKW,qBAAqB0M,EAAMtH,OAGtC,CAEA,kBAAMJ,CAAaD,GACjB,GAAI1F,KAAKa,QACP,MAAM,IAAIwB,MAAM,wBAEbrC,KAAKy+B,YAAcz+B,KAAKy+B,WAAW5Y,aAAe8Y,UAAUsB,YACzDjgC,KAAK0B,OAEb,IACE1B,KAAK6qB,cAAgBnlB,EACrB1F,KAAKy+B,WAAW1T,KAAKrlB,GACrB1F,KAAK6qB,cAAgB,IACvB,CAAE,MAAOI,GAEP,MADAtpB,QAAQwB,MAAM,+BAA+B8nB,KACvCA,CACR,CACF,CAEA,UAAAnlB,CAAWC,GACT/F,KAAKa,SAAU,EACfb,KAAK6qB,cAAgB,KAGnB7qB,KAAKy+B,YACLz+B,KAAKy+B,WAAW5Y,aAAe8Y,UAAUwB,QACzCngC,KAAKy+B,WAAW5Y,aAAe8Y,UAAUiC,SAEzC5gC,KAAKy+B,WAAWxrB,MAAM,IAAMlN,GAG9B/F,KAAKg/B,WACLr9B,QAAQC,KAAK,sCAAsCmE,KACrD,EAGF,SAASC,mBAAmBxG,GAC1B,IAAKA,EAAY,MAAM,IAAI6C,MAAM,0BAQjC,OAPI7C,EAAWyG,WAAW,WACxBzG,EACEA,EAAWU,QAAQ,UAAW,SAASA,QAAQ,MAAO,IAAM,MACrDV,EAAWyG,WAAW,cAC/BzG,EACEA,EAAWU,QAAQ,WAAY,UAAUA,QAAQ,MAAO,IAAM,OAE3DV,CACT,CAgBO2G,eAAe06B,MAAMx6B,GAC1B,MAAMoO,EAAapO,EAAOy6B,kBAAoB,qBACxCphC,EAAY2G,EAAO3G,UACnBqhC,EAAa16B,EAAO06B,WACpBlhC,EAAUwG,EAAO26B,eAAiB,GAClCh2B,EAAW3E,EAAO46B,eAClBC,EAAU76B,EAAO66B,QACjB1C,EAAqBn4B,EAAOm4B,mBAC5B2C,EAAY96B,EAAO86B,WAAa,YAEhCv4B,QAAew4B,gBAAgB,CACnCv6B,KAAM,uBACNrH,WAAY6G,EAAO7G,WACnBg/B,mBAAoBA,EACpB2C,UAAWA,IAEb,IACE,MAAMrsB,QAAYlM,EAAOd,WAAW2M,GAEpC,IAAItD,EAWJ,OAZA,mDAAO2D,EAAK,oCAAoCL,KAG9CtD,EADEzR,QACcoV,EAAI/S,MAAM,CAAErC,YAAWqhC,aAAYlkB,UAAU,UAE7C/H,EAAI/S,QAElBiJ,QACIA,EAASmG,GAEfxP,QAAQqP,IAAI,yCAAyCG,EAAQkwB,mBAElDvsB,EAAIwsB,MAAMnwB,EAAQO,IAAK,CAAE7R,UAASqhC,UAASrkB,UAAU,GACpE,CAAE,MAAO1Z,GACP,MAAMA,CACR,CAAE,cACMyF,EAAO9C,YACf,CACF,CAYOK,eAAeo7B,OAAOl7B,GAC3B,MAAMoO,EAAapO,EAAOy6B,kBAAoB,qBACxC91B,EAAW3E,EAAOm7B,gBAClBhD,EAAqBn4B,EAAOm4B,mBAC5B2C,EAAY96B,EAAO86B,WAAa,YAEhCv4B,QAAew4B,gBAAgB,CACnCv6B,KAAM,wBACNrH,WAAY6G,EAAO7G,WACnBg/B,mBAAoBA,EACpB2C,UAAWA,IAEb,IACE,MAAMrsB,QAAYlM,EAAOd,WAAW2M,GAIpC,IAHA,mDAAOK,EAAK,oCAAoCL,MAG3CK,EAAIysB,OACP,MAAM,IAAIl/B,MACR,8GAKJ,MAAM8O,QAAgB2D,EAAIysB,OAAO,CAAC,GAQlC,OAPIv2B,QACIA,EAASmG,GAEfxP,QAAQqP,IACN,yCAAyCG,EAAQswB,cAG9CtwB,CACT,CAAE,MAAOhO,GACP,MAAMA,CACR,CAAE,cACMyF,EAAO9C,YACf,CACF,CAEAK,eAAeu7B,iBAAiBx6B,EAAIy6B,EAAgB55B,EAAO1B,GAEzD,MAAMu7B,GADNv7B,EAASA,GAAU,CAAC,GACEu7B,OAChBC,EAAgBx7B,EAAOw7B,mBACP7yB,IAAlB3I,EAAOu7B,eAA6Bv7B,EAAOu7B,YAClB5yB,IAAzB3I,EAAOw7B,sBAAoCx7B,EAAOw7B,eACtD,mDACE,MAAC7yB,GAAW,GAAM,EAAO,QAAQ7J,SAASy8B,GAC1C,wCAGF,MAAM9sB,QAAY5N,EAAGY,WAAWC,EAAO1B,GACvC,IAAe,IAAXu7B,GAA8B,SAAXA,EAAmB,CACxC,GAAI9sB,EAAIhH,GAAG3I,SAAS,MAAQ2P,EAAIhH,GAAG3I,SAAS,KAC1C,IAEE,MAAM28B,QAAa,oDAAc56B,EAAIy6B,EAAgBE,GAC/CE,QAAeD,EAAKh6B,WAAWgN,EAAIhH,GAAGxJ,MAAM,KAAK,GAAI+B,GAI3D,OAHA07B,EAAOC,SAAU,EACjBD,EAAOE,MAAQH,EACfC,EAAOG,SAAWptB,EACXitB,CACT,CAAE,MAAOpuB,GACPhS,QAAQkD,KACN,2DACA8O,EAEJ,CAEF,IAAe,IAAXiuB,EACF,MAAM,IAAIv/B,MAAM,uCAEpB,CACA,OAAOyS,CACT,CAEO3O,eAAei7B,gBAAgB/6B,GAGpC,GAAkB,UADAA,EAAO86B,WAAa,aAEpC,aAAa,mDAAoB96B,GAG/BA,EAAOuC,SACTvC,EAAO7G,WAAa6G,EAAO7G,YAAc6G,EAAOuC,OAAOrG,IACvD8D,EAAOk4B,eACLl4B,EAAOk4B,gBAAkBl4B,EAAOuC,OAAO21B,gBAE3C,IAAIj4B,EAAWD,EAAO5G,UACjB6G,IACHA,GAAW,qDACXD,EAAO5G,UAAY6G,GAEc,IAA/B4B,OAAO6I,KAAK1K,GAAQrB,SACC,oBAAZ2I,SAA2BA,QAAQwuB,KAE5C91B,EAAO7G,WAAamO,QAAQwuB,IAAIgG,iBAChC97B,EAAO1G,MAAQgO,QAAQwuB,IAAIiG,YAC3B/7B,EAAO5G,UAAYkO,QAAQwuB,IAAIkG,gBAC/Bh8B,EAAO3G,UAAYiO,QAAQwuB,IAAImG,iBACN,oBAATtqB,MAAwBA,KAAKmkB,KAE7C91B,EAAO7G,WAAawY,KAAKmkB,IAAIgG,iBAC7B97B,EAAO1G,MAAQqY,KAAKmkB,IAAIiG,YACxB/7B,EAAO5G,UAAYuY,KAAKmkB,IAAIkG,gBAC5Bh8B,EAAO3G,UAAYsY,KAAKmkB,IAAImG,iBACG,oBAAfC,YAA8BA,WAAWpG,MAEzD91B,EAAO7G,WAAa+iC,WAAWpG,IAAIgG,iBACnC97B,EAAO1G,MAAQ4iC,WAAWpG,IAAIiG,YAC9B/7B,EAAO5G,UAAY8iC,WAAWpG,IAAIkG,gBAClCh8B,EAAO3G,UAAY6iC,WAAWpG,IAAImG,kBAItC,IAAI9iC,EAAawG,mBAAmBK,EAAO7G,YAEvCgH,EAAa,IAAI83B,uBACnB9+B,EACA8G,EACAD,EAAO3G,UACP2G,EAAO1G,MACP0G,EAAOzG,mBACPyG,EAAOI,gBAAkB,GACzBJ,EAAOk4B,eACPl4B,EAAOvG,uBACPuG,EAAOm4B,oBAET,MAAMz9B,QAAwByF,EAAW9E,OAQzC,IAPA,mDACEX,EACA,uOAGI,IAAImB,SAASC,GAAYC,WAAWD,EAAS,QAE9CqE,EAAWxF,WAAY,CAC1BW,QAAQkD,KAAK,8CAGb,MAAM29B,EAAc,IACdC,EAAgB,IAChBC,EAAY1gC,KAAKC,MAEvB,MAAQuE,EAAWxF,YAAcgB,KAAKC,MAAQygC,EAAYF,SAClD,IAAItgC,SAASC,GAAYC,WAAWD,EAASsgC,KAGrD,IAAKj8B,EAAWxF,WAEd,MADAW,QAAQwB,MAAM,0CACR,IAAId,MAAM,wCAEhBV,QAAQC,KAAK,iCAAiC4E,EAAWxF,aAE7D,CACA,GAAIqF,EAAO3G,WAAaqB,EAAgBrB,YAAc2G,EAAO3G,UAC3D,MAAM,IAAI2C,MACR,qCAAqCtB,EAAgBrB,wBAAwB2G,EAAO3G,aAIxF,MAAMA,EAAYqB,EAAgBrB,UAC5BgH,EAAM,IAAI,uCAAIF,EAAY,CAC9B/G,UAAW6G,EACX5G,YACAiH,gBAAiB,CAAEC,gBAAiB,aACpCC,KAAMR,EAAOQ,KACbJ,eAAgBJ,EAAOI,eACvBK,OAAQT,EAAOS,OACfC,gBAAiBhG,EAAgBiG,gBACjCiF,wBAAyB5F,EAAO4F,gCAE5BvF,EAAIO,QAAQ,sBAAuBZ,EAAOI,gBAAkB,KAClE,MAAMS,QAAWR,EAAIS,oBAAoB,CACvCtH,QAASwG,EAAOI,eAChBW,gBAAiB,QACjBwN,iBAAkBvO,EAAOuO,mBAAoB,IAwM/C,GAtMA1N,EAAGR,IAAMA,EA8BL3F,IACFmG,EAAGb,OAAS6B,OAAOC,OAAOjB,EAAGb,OAAQtF,IAEvCmG,EAAGy7B,QAAS,oDA/BZx8B,eAAuBoP,GACrBA,EAAIzH,GAAK,UACTyH,EAAI1O,KAAO0O,EAAI1O,MAAQR,EAAOQ,MAAQ0O,EAAIzH,GAC1CyH,EAAIjO,YAAciO,EAAIjO,aAAejB,EAAOiB,kBACtCZ,EAAIgB,iBAAiB6N,EAAK,CAAE3D,WAAW,GAC/C,GA0BoC,CAClC/K,KAAM,SACNS,YAAa,kBACbC,WAAY,CACVC,WAAY,CAAE+N,IAAK,CAAEjO,YAAa,oBAAqBpC,KAAM,WAC7D0C,SAAU,CAAC,OACX1C,KAAM,YAGVgC,EAAG07B,QAAS,oDAjCZz8B,eAAsBG,GAUpB,OATAA,EAAWA,GAAY,KACvB,oDAAQA,EAASnB,SAAS,KAAM,mCAC3BmB,EAASnB,SAAS,OACrBmB,EAAWvF,EAAgBrB,UAAY,IAAM4G,IAE/C,mDACiC,IAA/BA,EAAShC,MAAM,KAAKU,OACpB,0DAEWkC,EAAGY,WAAW,GAAGxB,YAChC,GAsBmC,CACjCO,KAAM,SACNS,YAAa,eACbC,WAAY,CACVC,WAAY,CACVlB,SAAU,CAAEu8B,QAAS,IAAKv7B,YAAa,eAAgBpC,KAAM,WAE/DA,KAAM,YAGVgC,EAAG47B,UAAW,oDA9Bd38B,eAAwBwM,GACtBA,EAAKA,GAAMjT,GACX,oDAAQiT,EAAGxN,SAAS,KAAM,qCAC1B,oDAAQwN,EAAGxN,SAAS,KAAM,oCAC1B,MAAM4C,EAAQ,CAAErI,UAAWiT,EAAI8B,WAAY,WAC3C,aAAavN,EAAG67B,aAAah7B,EAC/B,GAwBuC,CACrClB,KAAM,WACNS,YAAa,iBACbC,WAAY,CACVC,WAAY,CACV9H,UAAW,CACTmjC,QAASnjC,EACT4H,YAAa,gBACbpC,KAAM,WAGVA,KAAM,YAGVgC,EAAGpB,YAAa,mDAAeY,EAAIZ,WAAWuB,KAAKX,GAAM,CACvDG,KAAM,aACNS,YAAa,8BACbC,WAAY,CAAErC,KAAM,SAAUsC,WAAY,CAAC,EAAGI,SAAU,MAE1DV,EAAGwlB,eAAgB,mDAAehmB,EAAIuK,eAAe5J,KAAKX,GAAM,CAC9DG,KAAM,gBACNS,YAAa,6CACbC,WAAY,CACVrC,KAAM,SACNsC,WAAY,CACV2Y,MAAO,CACLjb,KAAM,SACNoC,YAAa,oBACbE,WAAY,CACVX,KAAM,CAAE3B,KAAM,UACdA,KAAM,CAAC,EACPkb,QAAS,CAAElb,KAAM,YACjBrB,QAAS,CAAEqB,KAAM,kBAO3BgC,EAAG6U,MAAO,mDAAerV,EAAIqV,KAAK1U,KAAKX,GAAM,CAC3CG,KAAM,OACNS,YAAa,kBACbC,WAAY,CACVC,WAAY,CAAE9B,KAAM,CAAE4B,YAAa,mBAAoBpC,KAAM,WAC7D0C,SAAU,CAAC,QACX1C,KAAM,YAIVgC,EAAGkB,IAAK,mDAAe1B,EAAI0B,GAAGf,KAAKX,GAAM,CACvCG,KAAM,KACNS,YAAa,8BACbC,WAAY,CACVC,WAAY,CACV6F,MAAO,CAAE/F,YAAa,yBAA0BpC,KAAM,UACtD9D,QAAS,CAAEkG,YAAa,uBAAwBpC,KAAM,aAExD0C,SAAU,CAAC,QAAS,WACpB1C,KAAM,YAIVgC,EAAG0M,KAAM,mDAAelN,EAAIkN,IAAIvM,KAAKX,GAAM,CACzCG,KAAM,MACNS,YAAa,4BACbC,WAAY,CACVC,WAAY,CACV6F,MAAO,CAAE/F,YAAa,sBAAuBpC,KAAM,UACnD9D,QAAS,CAAEkG,YAAa,uBAAwBpC,KAAM,aAExD0C,SAAU,CAAC,QAAS,WACpB1C,KAAM,YAIVgC,EAAG4hB,MAAO,mDAAepiB,EAAIoiB,KAAKzhB,KAAKX,GAAM,CAC3CG,KAAM,OACNS,YAAa,uCACbC,WAAY,CACVC,WAAY,CACV6F,MAAO,CAAE/F,YAAa,yBAA0BpC,KAAM,UACtD9D,QAAS,CAAEkG,YAAa,uBAAwBpC,KAAM,aAExD0C,SAAU,CAAC,QAAS,WACpB1C,KAAM,YAIVgC,EAAG87B,kBAAmB,mDAAet8B,EAAIwP,mBAAoB,CAC3DrP,KAAM,mBACNS,YAAa,0BACbC,WAAY,CACVC,WAAY,CACVG,QAAS,CACPL,YAAa,gCACbpC,KAAM,WAGV0C,SAAU,CAAC,WACX1C,KAAM,YAIVgC,EAAGO,iBAAkB,mDAAef,EAAIgB,iBAAiBL,KAAKX,GAAM,CAClEG,KAAM,kBACNS,YAAa,sBACbC,WAAY,CACVC,WAAY,CACVG,QAAS,CAAEL,YAAa,0BAA2BpC,KAAM,UACzD+9B,MAAO,CACLJ,SAAS,EACTv7B,YAAa,gCACbpC,KAAM,YAGV0C,SAAU,CAAC,WACX1C,KAAM,YAGVgC,EAAGgQ,mBAAoB,mDAAexQ,EAAIuQ,mBAAmB5P,KAAKX,GAAM,CACtEG,KAAM,oBACNS,YAAa,wBACbC,WAAY,CACVC,WAAY,CACVG,QAAS,CACPL,YAAa,+BACbpC,KAAM,UAERkR,OAAQ,CACNysB,SAAS,EACTv7B,YAAa,+BACbpC,KAAM,YAGV0C,SAAU,CAAC,WACX1C,KAAM,YAGNsB,EAAWxF,YACb0F,EAAI0B,GAAG,cAAcjC,MAAO/C,IACtBA,EAAQiF,OAAS,KAAO7B,EAAWxF,aACrCW,QAAQqP,IAAI,qCAAsC5N,EAAQ2C,cACpDW,EAAIZ,aACZ,IAGAO,EAAOu7B,OAAQ,OACX,oDAAmB16B,EAAI,GAAGZ,QAAgBD,EAAOw7B,eAEvD,MAAMqB,EAAMh7B,OAAOC,OAAO,CAAC,EAAGjB,GACxBI,EAAc47B,EAAIp7B,WAAWE,WAAWV,YAExCC,EAAa27B,EAAIp7B,WAAWE,WAAWT,WAC7CL,EAAGY,YAAa,mDACd45B,iBAAiBr6B,KAAK,KAAM67B,EAAK,GAAGxjC,KAAa4G,SACjD,CACEO,KAAM,aACNS,cACAC,eAIJL,EAAGikB,eAAgB,mDAAe,iDAAc9jB,KAAK,KAAMH,GAAK,CAC9DL,KAAM,gBACNS,YAAa,wDACbC,WAAY,CACVC,WAAY,CACVnB,OAAQ,CACNiB,YAAa,oCACbpC,KAAM,WAGV0C,SAAU,CAAC,UACX1C,KAAM,WAGZ,KAAO,CACL,MAAM2C,EAAcX,EAAGY,WACvBZ,EAAGY,WAAa,CAACC,EAAO1B,IAEfwB,EAAYE,EADnB1B,EAASA,GAAU,CAAC,GAGtBa,EAAGY,WAAWE,WAAaH,EAAYG,UACzC,CA0BA,OAfAd,EAAGi8B,gBAAiB,oDATpBh9B,eAA8Bi9B,GAM5B,OALAA,EAAOt1B,GAAK,SACZs1B,EAAOv8B,KAAO,SACdu8B,EAAO/8B,OAAS,CAAE2H,WAAY,UAC9Bo1B,EAAOl+B,KAAO,SACdk+B,EAAO97B,YAAc,yBAAyB9H,KAAcE,mDAC/CwH,EAAGO,gBAAgB27B,EAAQ,CAAExxB,WAAW,GACvD,GAEmD,CACjD/K,KAAM,iBACNS,YAAa,0BACbC,WAAY,CACVC,WAAY,CACV47B,OAAQ,CACN97B,YACE,sHACFpC,KAAM,WAGV0C,SAAU,CAAC,UACX1C,KAAM,YAGHgC,CACT,CAEOf,eAAek9B,iBAAiB76B,EAAYnC,EAAS,CAAC,GAC3D,MAAM,UAAEE,EAAS,UAAE7G,EAAS,SAAE4G,EAAQ,UAAEmC,EAAS,MAAEC,IACjD,mDAAgBF,GACZG,EAAgB,GAAGjJ,KAAa4G,KAAYmC,KAAaC,IAE/D,GAAIrC,EAAOE,WACLF,EAAOE,YAAcA,EACvB,MAAM,IAAIlE,MACR,iEAINgE,EAAOE,UAAYA,EACnB,MAAMqC,QAAew4B,gBAAgB/6B,GACrC,aAAauC,EAAOd,WAAWa,EACjC,CAEO,MAAM26B,eACX,WAAA/jC,CAAYgD,EAAK9C,EAAWC,GAC1BM,KAAKuC,IAAMA,EACXvC,KAAK8qB,OAAS,OACd9qB,KAAK4nB,UAAY,OACjB5nB,KAAKgrB,QAAU,OACfhrB,KAAK8lB,QAAU,OACf9lB,KAAKP,UAAYA,EACjBO,KAAKN,UAAYA,EACjB,MAAMyR,EAA4B,oBAAX1D,OAAyBA,OAASuK,KACnDurB,EAA6B,oBAAX91B,OAuCxB,GAtCAzN,KAAK8nB,YAAe1kB,IACdmgC,EACF91B,OAAOsQ,OAAO+J,YAAY1kB,EAAS,KAEnC4U,KAAK8P,YAAY1kB,EACnB,EAGFpD,KAAK6lB,WAAa8Y,UAAU6E,WAC5BryB,EAAQvD,iBACN,WACCP,IACC,MAAM,KAAEnI,EAAI,KAAEQ,EAAI,GAAEgN,GAAOrF,EAAM3H,KACjC,GAAIgN,IAAO1S,KAAKP,UAIhB,OAAQyF,GACN,IAAK,UACClF,KAAK6lB,aAAe8Y,UAAUsB,MAAQjgC,KAAK4nB,WAC7C5nB,KAAK4nB,UAAU,CAAEliB,KAAMA,IAEzB,MACF,IAAK,YACH1F,KAAK6lB,WAAa8Y,UAAUsB,KAC5BjgC,KAAK8qB,OAAOzd,GACZ,MACF,IAAK,SACHrN,KAAK6lB,WAAa8Y,UAAUwB,OAC5BngC,KAAKgrB,QAAQ3d,GAIjB,IAEF,IAGGrN,KAAKP,UAAW,MAAM,IAAI4C,MAAM,yBACrC,IAAKrC,KAAKN,UAAW,MAAM,IAAI2C,MAAM,yBACrCrC,KAAK8nB,YAAY,CACf5iB,KAAM,UACN3C,IAAKvC,KAAKuC,IACV8F,KAAMrI,KAAKP,UACXC,UAAWM,KAAKN,WAEpB,CAEA,IAAAqrB,CAAKrlB,GACC1F,KAAK6lB,aAAe8Y,UAAUsB,MAChCjgC,KAAK8nB,YAAY,CACf5iB,KAAM,UACNQ,KAAMA,EACN2C,KAAMrI,KAAKP,UACXC,UAAWM,KAAKN,WAGtB,CAEA,KAAAuT,GACEjT,KAAK6lB,WAAa8Y,UAAUiC,QAC5B5gC,KAAK8nB,YAAY,CACf5iB,KAAM,QACNmD,KAAMrI,KAAKP,UACXC,UAAWM,KAAKN,YAElBM,KAAKgrB,SACP,CAEA,gBAAApd,CAAiB1I,EAAMu+B,GACR,YAATv+B,IACFlF,KAAK4nB,UAAY6b,GAEN,SAATv+B,IACFlF,KAAK8qB,OAAS2Y,GAEH,UAATv+B,IACFlF,KAAKgrB,QAAUyY,GAEJ,UAATv+B,IACFlF,KAAK8lB,QAAU2d,EAEnB,EAGK,SAASC,kBAAiB,kBACZ,EAAK,SACb,OAEX,OAAO,IAAIxhC,SAAQ,CAACC,QAASqH,UAC3B,MAAM2H,QAA4B,oBAAX1D,OAAyBA,OAASuK,KACnDurB,SAA6B,oBAAX91B,OACxB0D,QAAQvD,iBACN,WACCP,QACC,MAAM,KACA,WACM,UACD,UACA,MACJ,eACS,KACV,QAEFA,MAAM3H,KAEV,GAAa,0BAATR,KAAkC,CACpC,IAAK1F,aAAeE,YAAcD,UAEhC,YADAkC,QAAQwB,MAAM,sDAIhB,IAAK3D,WAAWyG,WAAW,+BAIzB,YAHAtE,QAAQwB,MACN,4DAKJ,MAAMwgC,4BAA4BL,eAChC,WAAA/jC,CAAYgD,GAEV2J,MAAM3J,EAAK9C,UAAWC,UACxB,EAEF0hC,gBAAgB,CACd5hC,WACAE,UACAD,UACAE,MACA8G,eACAI,KACA03B,eAAgBoF,sBACfj6B,MAAKvD,MAAOyC,SACb25B,WAAWhtB,IAAM3M,OACjB,IAEE,GAAI26B,UAAYK,iBAAkB,CAChC,SAASC,EAAWC,GAClB,OAAO,IAAI5hC,SAAQ,CAACC,EAASqH,KAC3B,MAAMu6B,EAAgBve,SAASC,cAAc,UAC7Cse,EAAcC,UAAYF,EAAOG,QACjCF,EAAcG,KAAOJ,EAAOI,KAE5BH,EAAcpe,OAAS,IAAMxjB,IAC7B4hC,EAAcje,QAAWnS,GAAMnK,EAAOmK,GAEtC6R,SAASO,KAAKC,YAAY+d,EAAc,GAE5C,CACA,GAAI19B,OAAO89B,QAAU99B,OAAO89B,OAAOn/B,OAAS,EAC1C,IAAK,MAAMo/B,KAAS/9B,OAAO89B,OAAQ,CACjC,MAAME,EAAe7e,SAASC,cAAc,SAC5C4e,EAAaL,UAAYI,EAAMH,QAC/BI,EAAaH,KAAOE,EAAMF,KAC1B1e,SAASO,KAAKC,YAAYqe,EAC5B,CAEF,GAAIh+B,OAAOi+B,OAASj+B,OAAOi+B,MAAMt/B,OAAS,EACxC,IAAK,MAAMu/B,KAAQl+B,OAAOi+B,MAAO,CAC/B,MAAME,EAAchf,SAASC,cAAc,KAC3C+e,EAAYne,KAAOke,EAAKhiC,IACxBiiC,EAAYC,UAAYF,EAAKxhC,KAC7ByiB,SAAS7hB,KAAKqiB,YAAYwe,EAC5B,CAEF,GAAIn+B,OAAOq+B,SAAWr+B,OAAOq+B,QAAQ1/B,OAAS,EAC5C,IAAK,MAAM2/B,KAAKt+B,OAAOq+B,QAAS,CAC9Blf,SAAS7hB,KAAKqgC,UAAYW,EAAEV,QAC5B,KACF,CAEF,GAAI59B,OAAOu+B,SAAWv+B,OAAOu+B,QAAQ5/B,OAAS,EAC5C,IAAK,MAAM8+B,KAAUz9B,OAAOu+B,QAAS,CACnC,GAAoB,eAAhBd,EAAOI,KACT,MAAM,IAAI7hC,MAAM,+CACZwhC,EAAWC,EACnB,CAEJ,MAEK,IACFP,UACDK,kBACAv9B,OAAOu+B,SACPv+B,OAAOu+B,QAAQ5/B,OAAS,EAExB,IAAK,MAAM8+B,UAAUz9B,OAAOu+B,QAAS,CACnC,GAAoB,eAAhBd,OAAOI,KACT,MAAM,IAAI7hC,MAAM,yCAClB4kB,KAAK6c,OAAOG,QACd,CAGEY,gBACIA,SAASj8B,OAAQvC,QAEzBlE,QAAQyG,OACV,CAAE,MAAO+K,GACPnK,OAAOmK,EACT,IAEJ,KAEF,GAEE4vB,SACF91B,OAAOsQ,OAAO+J,YAAY,CAAE5iB,KAAM,oBAAsB,KAExD8S,KAAK8P,YAAY,CAAE5iB,KAAM,oBAC3B,GAEJ,C","sources":["webpack://hypha-rpc/./src/http-client.js","webpack://hypha-rpc/./src/rpc.js","webpack://hypha-rpc/./src/utils/index.js","webpack://hypha-rpc/./src/utils/schema.js","webpack://hypha-rpc/./src/webrtc-client.js","webpack://hypha-rpc/./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs","webpack://hypha-rpc/./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs","webpack://hypha-rpc/./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs","webpack://hypha-rpc/./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs","webpack://hypha-rpc/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs","webpack://hypha-rpc/./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs","webpack://hypha-rpc/./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs","webpack://hypha-rpc/./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs","webpack://hypha-rpc/./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs","webpack://hypha-rpc/./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs","webpack://hypha-rpc/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs","webpack://hypha-rpc/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs","webpack://hypha-rpc/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs","webpack://hypha-rpc/webpack/bootstrap","webpack://hypha-rpc/webpack/runtime/define property getters","webpack://hypha-rpc/webpack/runtime/hasOwnProperty shorthand","webpack://hypha-rpc/./src/websocket-client.js"],"sourcesContent":["/**\n * HTTP Streaming RPC Client for Hypha.\n *\n * This module provides HTTP-based RPC transport as an alternative to WebSocket.\n * It uses:\n * - HTTP GET with streaming (NDJSON/msgpack) for server-to-client messages\n * - HTTP POST for client-to-server messages\n *\n * This is more resilient to network issues than WebSocket because:\n * 1. Each POST request is independent (stateless)\n * 2. GET stream can be easily reconnected\n * 3. Works through more proxies and firewalls\n *\n * ## Performance Optimizations\n *\n * Modern browsers automatically provide optimal HTTP performance:\n *\n * ### Automatic HTTP/2 Support\n * - Browsers negotiate HTTP/2 when server supports it\n * - Multiplexing: Multiple requests over single TCP connection\n * - Header compression: HPACK reduces overhead\n * - Server push: Pre-emptive resource delivery\n *\n * ### Connection Pooling\n * - Browsers maintain connection pools per origin\n * - Automatic keep-alive for HTTP/1.1\n * - Connection reuse reduces latency\n * - No manual configuration needed\n *\n * ### Fetch API Optimizations\n * - `keepalive: true` flag ensures connection reuse\n * - Streaming responses with backpressure handling\n * - Efficient binary data transfer (ArrayBuffer/Uint8Array)\n *\n * ### Server-Side Configuration\n * For optimal performance, ensure server has:\n * - Keep-alive timeout: 300s (matches typical browser defaults)  CONFIGURED\n * - Fast compression: gzip level 1 (2-5x faster than level 5)  CONFIGURED\n * - Uvicorn connection limits optimized  CONFIGURED\n *\n * ### HTTP/2 Support\n * - Uvicorn does NOT natively support HTTP/2 (as of 2026)\n * - In production, use nginx/Caddy/ALB as reverse proxy for HTTP/2\n * - Reverse proxy handles HTTP/2  HTTP/1.1 translation\n * - Browsers automatically use HTTP/2 when reverse proxy supports it\n * - Current HTTP/1.1 implementation is already optimal\n *\n * ### Performance Results\n * With properly configured server, HTTP transport achieves:\n * - 10-12 MB/s throughput for large payloads (4-15 MB)\n * - 2-3x faster than before optimization\n * - 3-28x faster than WebSocket for data transfer\n * - 31% improvement in connection reuse efficiency\n */\n\nimport { RPC } from \"./rpc.js\";\nimport { assert, randId, waitFor, parseServiceUrl } from \"./utils/index.js\";\nimport { schemaFunction } from \"./utils/schema.js\";\nimport {\n  encode as msgpackEncode,\n  decode as msgpackDecode,\n} from \"@msgpack/msgpack\";\n\nconst MAX_RETRY = 1000000;\n\n/**\n * HTTP Streaming RPC Connection.\n *\n * Uses HTTP GET with streaming for receiving messages and HTTP POST for sending messages.\n * Supports two formats:\n * - NDJSON (default): JSON lines for text-based messages\n * - msgpack: Binary format with length-prefixed frames for binary data support\n */\nexport class HTTPStreamingRPCConnection {\n  /**\n   * Initialize HTTP streaming connection.\n   *\n   * @param {string} server_url - The server URL (http:// or https://)\n   * @param {string} client_id - Unique client identifier\n   * @param {string} workspace - Target workspace (optional)\n   * @param {string} token - Authentication token (optional)\n   * @param {string} reconnection_token - Token for reconnection (optional)\n   * @param {number} timeout - Request timeout in seconds (default: 60)\n   * @param {number} token_refresh_interval - Interval for token refresh (default: 2 hours)\n   * @param {string} format - Stream format - \"json\" (NDJSON) or \"msgpack\" (default: \"json\")\n   */\n  constructor(\n    server_url,\n    client_id,\n    workspace = null,\n    token = null,\n    reconnection_token = null,\n    timeout = 60,\n    token_refresh_interval = 2 * 60 * 60,\n    format = \"json\",\n  ) {\n    assert(server_url && client_id, \"server_url and client_id are required\");\n    this._server_url = server_url.replace(/\\/$/, \"\");\n    this._client_id = client_id;\n    this._workspace = workspace;\n    this._token = token;\n    this._reconnection_token = reconnection_token;\n    this._timeout = timeout;\n    this._token_refresh_interval = token_refresh_interval;\n    this._format = format;\n\n    this._handle_message = null;\n    this._handle_disconnected = null;\n    this._handle_connected = null;\n\n    this._closed = false;\n    this._enable_reconnect = false;\n    this.connection_info = null;\n    this.manager_id = null;\n\n    this._stream_reader = null;\n    this._stream_controller = null;\n  }\n\n  /**\n   * Register message handler.\n   */\n  on_message(handler) {\n    assert(handler, \"handler is required\");\n    this._handle_message = handler;\n  }\n\n  /**\n   * Register disconnection handler.\n   */\n  on_disconnected(handler) {\n    this._handle_disconnected = handler;\n  }\n\n  /**\n   * Register connection handler.\n   */\n  on_connected(handler) {\n    this._handle_connected = handler;\n  }\n\n  /**\n   * Get HTTP headers with authentication.\n   *\n   * @param {boolean} for_stream - If true, set Accept header based on format preference\n   * @returns {Object} Headers object\n   */\n  _get_headers(for_stream = false) {\n    const headers = {\n      \"Content-Type\": \"application/msgpack\",\n    };\n    if (for_stream) {\n      if (this._format === \"msgpack\") {\n        headers[\"Accept\"] = \"application/x-msgpack-stream\";\n      } else {\n        headers[\"Accept\"] = \"application/x-ndjson\";\n      }\n    }\n    if (this._token) {\n      headers[\"Authorization\"] = `Bearer ${this._token}`;\n    }\n    return headers;\n  }\n\n  /**\n   * Open the streaming connection.\n   */\n  async open() {\n    console.info(\n      `Opening HTTP streaming connection to ${this._server_url} (format=${this._format})`,\n    );\n\n    // Build stream URL\n    let stream_url = `${this._server_url}/rpc?client_id=${this._client_id}`;\n    if (this._workspace) {\n      stream_url += `&workspace=${this._workspace}`;\n    }\n    if (this._format === \"msgpack\") {\n      stream_url += \"&format=msgpack\";\n    }\n\n    // Start streaming in background\n    this._startStreamLoop(stream_url);\n\n    // Wait for connection info (first message)\n    const start = Date.now();\n    while (this.connection_info === null) {\n      await new Promise((resolve) => setTimeout(resolve, 100));\n      if (Date.now() - start > this._timeout * 1000) {\n        throw new Error(\"Timeout waiting for connection info\");\n      }\n      if (this._closed) {\n        throw new Error(\"Connection closed during setup\");\n      }\n    }\n\n    this.manager_id = this.connection_info.manager_id;\n    if (this._workspace) {\n      const actual_ws = this.connection_info.workspace;\n      if (actual_ws !== this._workspace) {\n        throw new Error(\n          `Connected to wrong workspace: ${actual_ws}, expected: ${this._workspace}`,\n        );\n      }\n    }\n    this._workspace = this.connection_info.workspace;\n\n    if (this._handle_connected) {\n      await this._handle_connected();\n    }\n\n    return this.connection_info;\n  }\n\n  /**\n   * Start the streaming loop.\n   *\n   * OPTIMIZATION: Modern browsers automatically:\n   * - Negotiate HTTP/2 when server supports it\n   * - Use connection pooling for multiple requests to same origin\n   * - Handle keep-alive for persistent connections\n   * - Stream responses efficiently with backpressure handling\n   */\n  async _startStreamLoop(url) {\n    let retry = 0;\n\n    while (!this._closed && retry < MAX_RETRY) {\n      try {\n        // OPTIMIZATION: Browser fetch automatically streams responses\n        // and negotiates HTTP/2 when available for better performance\n        const response = await fetch(url, {\n          method: \"GET\",\n          headers: this._get_headers(true),\n          // keepalive flag for connection reuse (important for reconnections)\n          keepalive: true,\n        });\n\n        if (!response.ok) {\n          const error_text = await response.text();\n          throw new Error(\n            `Stream failed with status ${response.status}: ${error_text}`,\n          );\n        }\n\n        retry = 0; // Reset retry counter on successful connection\n\n        if (this._format === \"msgpack\") {\n          // Binary msgpack stream with 4-byte length prefix\n          await this._processMsgpackStream(response);\n        } else {\n          // NDJSON stream (line-based)\n          await this._processNdjsonStream(response);\n        }\n      } catch (error) {\n        if (this._closed) break;\n        console.error(`Connection error: ${error.message}`);\n\n        if (!this._enable_reconnect) {\n          break;\n        }\n      }\n\n      // Reconnection logic\n      if (!this._closed && this._enable_reconnect) {\n        retry += 1;\n        // Exponential backoff with max 30 seconds\n        const delay = Math.min(Math.pow(2, retry) * 0.1, 30);\n        console.info(`Reconnecting in ${delay.toFixed(1)}s (attempt ${retry})`);\n        await new Promise((resolve) => setTimeout(resolve, delay * 1000));\n      } else {\n        break;\n      }\n    }\n\n    if (!this._closed && this._handle_disconnected) {\n      this._handle_disconnected(\"Stream ended\");\n    }\n  }\n\n  /**\n   * Process NDJSON (line-based JSON) stream.\n   */\n  async _processNdjsonStream(response) {\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    let buffer = \"\";\n\n    while (!this._closed) {\n      const { done, value } = await reader.read();\n\n      if (done) break;\n\n      buffer += decoder.decode(value, { stream: true });\n      const lines = buffer.split(\"\\n\");\n      buffer = lines.pop() || \"\";\n\n      for (const line of lines) {\n        if (!line.trim()) continue;\n\n        try {\n          const message = JSON.parse(line);\n          await this._handleStreamMessage(message);\n        } catch (error) {\n          console.warn(`Failed to parse JSON message: ${error.message}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if frame data is a control message and decode it.\n   *\n   * Control messages vs RPC messages:\n   * - Control messages: Single msgpack object with \"type\" field (connection_info, ping, etc.)\n   * - RPC messages: May contain multiple concatenated msgpack objects (main message + extra data)\n   *\n   * We only need to decode the first object to check if it's a control message.\n   * RPC messages are passed as raw bytes to the handler.\n   *\n   * @param {Uint8Array} frame_data - The msgpack frame data\n   * @returns {Object|null} Decoded control message or null\n   */\n  _tryDecodeControlMessage(frame_data) {\n    // Quick check: Control messages are small (< 10KB typically)\n    // RPC messages with extra data are often larger\n    if (frame_data.length > 10000) {\n      return null; // Likely an RPC message with large payload\n    }\n\n    try {\n      // Use decodeMulti to handle frames with multiple msgpack objects\n      // This returns an array of decoded objects\n      const decoded = msgpackDecode(frame_data);\n\n      // Control messages are simple objects with a \"type\" field\n      if (typeof decoded === \"object\" && decoded !== null && decoded.type) {\n        const controlTypes = [\n          \"connection_info\",\n          \"ping\",\n          \"pong\",\n          \"reconnection_token\",\n          \"error\",\n        ];\n        if (controlTypes.includes(decoded.type)) {\n          return decoded;\n        }\n      }\n\n      // Not a control message\n      return null;\n    } catch {\n      // Decode failed or has extra data - this is an RPC message\n      return null;\n    }\n  }\n\n  /**\n   * Process msgpack stream with 4-byte length prefix.\n   */\n  async _processMsgpackStream(response) {\n    const reader = response.body.getReader();\n    let buffer = new Uint8Array(0);\n\n    while (!this._closed) {\n      const { done, value } = await reader.read();\n\n      if (done) break;\n\n      // Append new chunk to buffer\n      const newBuffer = new Uint8Array(buffer.length + value.length);\n      newBuffer.set(buffer);\n      newBuffer.set(value, buffer.length);\n      buffer = newBuffer;\n\n      // Process complete frames from buffer\n      while (buffer.length >= 4) {\n        // Read 4-byte length prefix (big-endian)\n        const length =\n          (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];\n\n        if (buffer.length < 4 + length) {\n          // Incomplete frame, wait for more data\n          break;\n        }\n\n        // Extract the frame\n        const frame_data = buffer.slice(4, 4 + length);\n        buffer = buffer.slice(4 + length);\n\n        // Try to decode as control message first\n        const controlMsg = this._tryDecodeControlMessage(frame_data);\n        if (controlMsg) {\n          const msg_type = controlMsg.type;\n          if (msg_type === \"connection_info\") {\n            this.connection_info = controlMsg;\n            continue;\n          } else if (msg_type === \"ping\" || msg_type === \"pong\") {\n            continue;\n          } else if (msg_type === \"reconnection_token\") {\n            this._reconnection_token = controlMsg.reconnection_token;\n            continue;\n          } else if (msg_type === \"error\") {\n            console.error(`Server error: ${controlMsg.message}`);\n            continue;\n          }\n        }\n\n        // For RPC messages (or unrecognized control messages), pass raw frame data to handler\n        if (this._handle_message) {\n          try {\n            await this._handle_message(frame_data);\n          } catch (error) {\n            console.error(`Error in message handler: ${error.message}`);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Handle a decoded stream message.\n   */\n  async _handleStreamMessage(message) {\n    // Handle connection info\n    if (message.type === \"connection_info\") {\n      this.connection_info = message;\n      return;\n    }\n\n    // Handle ping (keep-alive)\n    if (message.type === \"ping\") {\n      return;\n    }\n\n    // Handle reconnection token refresh\n    if (message.type === \"reconnection_token\") {\n      this._reconnection_token = message.reconnection_token;\n      return;\n    }\n\n    // Handle errors\n    if (message.type === \"error\") {\n      console.error(`Server error: ${message.message}`);\n      return;\n    }\n\n    // Pass to message handler (convert to msgpack for RPC)\n    if (this._handle_message) {\n      const data = msgpackEncode(message);\n      await this._handle_message(data);\n    }\n  }\n\n  /**\n   * Send a message to the server via HTTP POST.\n   *\n   * OPTIMIZATION: Uses keepalive flag for connection reuse.\n   * Modern browsers automatically:\n   * - Use HTTP/2 when available (multiplexing, header compression)\n   * - Manage connection pooling with HTTP/1.1 keep-alive\n   * - Reuse connections for same-origin requests\n   */\n  async emit_message(data) {\n    if (this._closed) {\n      throw new Error(\"Connection is closed\");\n    }\n\n    // Build POST URL - use the connected workspace\n    let post_url = `${this._server_url}/rpc?client_id=${this._client_id}`;\n    if (this._workspace) {\n      post_url += `&workspace=${this._workspace}`;\n    }\n\n    // Ensure data is Uint8Array\n    const body = data instanceof Uint8Array ? data : new Uint8Array(data);\n\n    // OPTIMIZATION: keepalive flag hints to browser to reuse connections\n    // This is particularly important for rapid successive requests\n    const response = await fetch(post_url, {\n      method: \"POST\",\n      headers: this._get_headers(false),\n      body: body,\n      keepalive: true,  // Enable connection reuse\n    });\n\n    if (!response.ok) {\n      const error_text = await response.text();\n      throw new Error(\n        `POST failed with status ${response.status}: ${error_text}`,\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Set reconnection flag.\n   */\n  set_reconnection(value) {\n    this._enable_reconnect = value;\n  }\n\n  /**\n   * Close the connection.\n   */\n  async disconnect(reason = \"client disconnect\") {\n    if (this._closed) return;\n\n    this._closed = true;\n\n    if (this._handle_disconnected) {\n      this._handle_disconnected(reason);\n    }\n  }\n}\n\n/**\n * Normalize server URL for HTTP transport.\n */\nexport function normalizeServerUrl(server_url) {\n  if (!server_url) {\n    throw new Error(\"server_url is required\");\n  }\n\n  // Convert ws:// to http://\n  if (server_url.startsWith(\"ws://\")) {\n    server_url = server_url.replace(\"ws://\", \"http://\");\n  } else if (server_url.startsWith(\"wss://\")) {\n    server_url = server_url.replace(\"wss://\", \"https://\");\n  }\n\n  // Remove /ws suffix if present (WebSocket endpoint)\n  if (server_url.endsWith(\"/ws\")) {\n    server_url = server_url.slice(0, -3);\n  }\n\n  return server_url.replace(/\\/$/, \"\");\n}\n\n/**\n * Internal function to establish HTTP streaming connection.\n */\nexport async function _connectToServerHTTP(config) {\n  let clientId = config.clientId || config.client_id;\n  if (!clientId) {\n    clientId = randId();\n  }\n\n  const server_url = normalizeServerUrl(config.serverUrl || config.server_url);\n\n  const connection = new HTTPStreamingRPCConnection(\n    server_url,\n    clientId,\n    config.workspace,\n    config.token,\n    config.reconnection_token,\n    config.method_timeout || 30,\n    config.token_refresh_interval || 2 * 60 * 60,\n    // Default to msgpack for full binary support and proper RPC message handling\n    config.format || \"msgpack\",\n  );\n\n  const connection_info = await connection.open();\n  assert(connection_info, \"Failed to connect to server\");\n\n  await new Promise((resolve) => setTimeout(resolve, 100));\n\n  const workspace = connection_info.workspace;\n\n  const rpc = new RPC(connection, {\n    client_id: clientId,\n    workspace,\n    default_context: { connection_type: \"http_streaming\" },\n    name: config.name,\n    method_timeout: config.method_timeout,\n    app_id: config.app_id,\n    server_base_url: connection_info.public_base_url,\n  });\n\n  await rpc.waitFor(\"services_registered\", config.method_timeout || 120);\n\n  const wm = await rpc.get_manager_service({\n    timeout: config.method_timeout || 30,\n    case_conversion: \"camel\",\n  });\n  wm.rpc = rpc;\n\n  // Add standard methods\n  wm.disconnect = schemaFunction(rpc.disconnect.bind(rpc), {\n    name: \"disconnect\",\n    description: \"Disconnect from server\",\n    parameters: { properties: {}, type: \"object\" },\n  });\n\n  wm.registerService = schemaFunction(rpc.register_service.bind(rpc), {\n    name: \"registerService\",\n    description: \"Register a service\",\n    parameters: {\n      properties: {\n        service: { description: \"Service to register\", type: \"object\" },\n      },\n      required: [\"service\"],\n      type: \"object\",\n    },\n  });\n\n  const _getService = wm.getService;\n  wm.getService = async (query, config = {}) => {\n    return await _getService(query, config);\n  };\n  if (_getService.__schema__) {\n    wm.getService.__schema__ = _getService.__schema__;\n  }\n\n  async function serve() {\n    await new Promise(() => {}); // Wait forever\n  }\n\n  wm.serve = schemaFunction(serve, {\n    name: \"serve\",\n    description: \"Run event loop forever\",\n    parameters: { type: \"object\", properties: {} },\n  });\n\n  if (connection_info) {\n    wm.config = Object.assign(wm.config || {}, connection_info);\n  }\n\n  // Handle force-exit from manager\n  if (connection.manager_id) {\n    rpc.on(\"force-exit\", async (message) => {\n      if (message.from === \"*/\" + connection.manager_id) {\n        console.info(`Disconnecting from server: ${message.reason}`);\n        await rpc.disconnect();\n      }\n    });\n  }\n\n  return wm;\n}\n\n/**\n * Connect to server using HTTP streaming transport.\n *\n * This is an alternative to WebSocket connection that's more resilient\n * to network issues.\n *\n * @param {Object} config - Configuration object\n * @returns {Promise<Object>} Connected workspace manager\n */\nexport async function connectToServerHTTP(config = {}) {\n  return await _connectToServerHTTP(config);\n}\n\n/**\n * Get a remote service using HTTP transport.\n */\nexport async function getRemoteServiceHTTP(serviceUri, config = {}) {\n  const { serverUrl, workspace, clientId, serviceId, appId } =\n    parseServiceUrl(serviceUri);\n  const fullServiceId = `${workspace}/${clientId}:${serviceId}@${appId}`;\n\n  if (config.serverUrl) {\n    if (config.serverUrl !== serverUrl) {\n      throw new Error(\"server_url mismatch\");\n    }\n  }\n  config.serverUrl = serverUrl;\n\n  const server = await connectToServerHTTP(config);\n  return await server.getService(fullServiceId);\n}\n","/**\n * Contains the RPC object used both by the application\n * site, and by each plugin\n */\nimport {\n  randId,\n  typedArrayToDtype,\n  dtypeToTypedArray,\n  MessageEmitter,\n  assert,\n  waitFor,\n  convertCase,\n  expandKwargs,\n  Semaphore,\n  isAsyncGenerator,\n  isGenerator,\n} from \"./utils/index.js\";\nimport { schemaFunction } from \"./utils/schema.js\";\n\nimport { encode as msgpack_packb, decodeMulti } from \"@msgpack/msgpack\";\n\nexport const API_VERSION = 3;\nconst CHUNK_SIZE = 1024 * 256;\nconst CONCURRENCY_LIMIT = 30;\n\nconst ArrayBufferView = Object.getPrototypeOf(\n  Object.getPrototypeOf(new Uint8Array()),\n).constructor;\n\nfunction _appendBuffer(buffer1, buffer2) {\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n}\n\n/**\n * Wrap a promise with a timeout.\n * @param {Promise} promise - The promise to wrap.\n * @param {number} timeoutMs - The timeout in milliseconds.\n * @param {string} message - Optional error message for timeout.\n * @returns {Promise} - The wrapped promise that will reject on timeout.\n */\nfunction withTimeout(promise, timeoutMs, message = \"Operation timed out\") {\n  return new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject(new Error(`TimeoutError: ${message}`));\n    }, timeoutMs);\n\n    promise\n      .then((result) => {\n        clearTimeout(timeoutId);\n        resolve(result);\n      })\n      .catch((error) => {\n        clearTimeout(timeoutId);\n        reject(error);\n      });\n  });\n}\n\nfunction indexObject(obj, is) {\n  if (!is) throw new Error(\"undefined index\");\n  if (typeof is === \"string\") return indexObject(obj, is.split(\".\"));\n  else if (is.length === 0) return obj;\n  else return indexObject(obj[is[0]], is.slice(1));\n}\n\n// Simple fallback schema generation - no docstring parsing for JS\n\nfunction _get_schema(obj, name = null, skipContext = false) {\n  if (Array.isArray(obj)) {\n    return obj.map((v, i) => _get_schema(v, null, skipContext));\n  } else if (typeof obj === \"object\" && obj !== null) {\n    let schema = {};\n    for (let k in obj) {\n      schema[k] = _get_schema(obj[k], k, skipContext);\n    }\n    return schema;\n  } else if (typeof obj === \"function\") {\n    if (obj.__schema__) {\n      const schema = JSON.parse(JSON.stringify(obj.__schema__));\n      if (name) {\n        schema.name = name;\n        obj.__schema__.name = name;\n      }\n      if (skipContext) {\n        if (schema.parameters && schema.parameters.properties) {\n          delete schema.parameters.properties[\"context\"];\n        }\n        if (schema.parameters && schema.parameters.required) {\n          const contextIndex = schema.parameters.required.indexOf(\"context\");\n          if (contextIndex > -1) {\n            schema.parameters.required.splice(contextIndex, 1);\n          }\n        }\n      }\n      return { type: \"function\", function: schema };\n    } else {\n      // Simple fallback for JavaScript - just return basic function schema with name\n      const funcName = name || obj.name || \"function\";\n      return {\n        type: \"function\",\n        function: {\n          name: funcName,\n        },\n      };\n    }\n  } else if (typeof obj === \"number\") {\n    return { type: \"number\" };\n  } else if (typeof obj === \"string\") {\n    return { type: \"string\" };\n  } else if (typeof obj === \"boolean\") {\n    return { type: \"boolean\" };\n  } else if (obj === null) {\n    return { type: \"null\" };\n  } else {\n    return {};\n  }\n}\n\nfunction _annotate_service(service, serviceTypeInfo) {\n  function validateKeys(serviceDict, schemaDict, path = \"root\") {\n    // Validate that all keys in schemaDict exist in serviceDict\n    for (let key in schemaDict) {\n      if (!serviceDict.hasOwnProperty(key)) {\n        throw new Error(`Missing key '${key}' in service at path '${path}'`);\n      }\n    }\n\n    // Check for any unexpected keys in serviceDict\n    for (let key in serviceDict) {\n      if (key !== \"type\" && !schemaDict.hasOwnProperty(key)) {\n        throw new Error(`Unexpected key '${key}' in service at path '${path}'`);\n      }\n    }\n  }\n\n  function annotateRecursive(newService, schemaInfo, path = \"root\") {\n    if (typeof newService === \"object\" && !Array.isArray(newService)) {\n      validateKeys(newService, schemaInfo, path);\n      for (let k in newService) {\n        let v = newService[k];\n        let newPath = `${path}.${k}`;\n        if (typeof v === \"object\" && !Array.isArray(v)) {\n          annotateRecursive(v, schemaInfo[k], newPath);\n        } else if (typeof v === \"function\") {\n          if (schemaInfo.hasOwnProperty(k)) {\n            newService[k] = schemaFunction(v, {\n              name: schemaInfo[k][\"name\"],\n              description: schemaInfo[k].description || \"\",\n              parameters: schemaInfo[k][\"parameters\"],\n            });\n          } else {\n            throw new Error(\n              `Missing schema for function '${k}' at path '${newPath}'`,\n            );\n          }\n        }\n      }\n    } else if (Array.isArray(newService)) {\n      if (newService.length !== schemaInfo.length) {\n        throw new Error(`Length mismatch at path '${path}'`);\n      }\n      newService.forEach((v, i) => {\n        let newPath = `${path}[${i}]`;\n        if (typeof v === \"object\" && !Array.isArray(v)) {\n          annotateRecursive(v, schemaInfo[i], newPath);\n        } else if (typeof v === \"function\") {\n          if (schemaInfo.hasOwnProperty(i)) {\n            newService[i] = schemaFunction(v, {\n              name: schemaInfo[i][\"name\"],\n              description: schemaInfo[i].description || \"\",\n              parameters: schemaInfo[i][\"parameters\"],\n            });\n          } else {\n            throw new Error(\n              `Missing schema for function at index ${i} in path '${newPath}'`,\n            );\n          }\n        }\n      });\n    }\n  }\n\n  validateKeys(service, serviceTypeInfo[\"definition\"]);\n  annotateRecursive(service, serviceTypeInfo[\"definition\"]);\n  return service;\n}\n\nfunction getFunctionInfo(func) {\n  const funcString = func.toString();\n\n  // Extract function name\n  const nameMatch = funcString.match(/function\\s*(\\w*)/);\n  const name = (nameMatch && nameMatch[1]) || \"\";\n\n  // Extract function parameters, excluding comments\n  const paramsMatch = funcString.match(/\\(([^)]*)\\)/);\n  let params = \"\";\n  if (paramsMatch) {\n    params = paramsMatch[1]\n      .split(\",\")\n      .map((p) =>\n        p\n          .replace(/\\/\\*.*?\\*\\//g, \"\") // Remove block comments\n          .replace(/\\/\\/.*$/g, \"\"),\n      ) // Remove line comments\n      .filter((p) => p.trim().length > 0) // Remove empty strings after removing comments\n      .map((p) => p.trim()) // Trim remaining whitespace\n      .join(\", \");\n  }\n\n  // Extract function docstring (block comment)\n  let docMatch = funcString.match(/\\)\\s*\\{\\s*\\/\\*([\\s\\S]*?)\\*\\//);\n  const docstringBlock = (docMatch && docMatch[1].trim()) || \"\";\n\n  // Extract function docstring (line comment)\n  docMatch = funcString.match(/\\)\\s*\\{\\s*(\\/\\/[\\s\\S]*?)\\n\\s*[^\\s\\/]/);\n  const docstringLine =\n    (docMatch &&\n      docMatch[1]\n        .split(\"\\n\")\n        .map((s) => s.replace(/^\\/\\/\\s*/, \"\").trim())\n        .join(\"\\n\")) ||\n    \"\";\n\n  const docstring = docstringBlock || docstringLine;\n  return (\n    name &&\n    params.length > 0 && {\n      name: name,\n      sig: params,\n      doc: docstring,\n    }\n  );\n}\n\nfunction concatArrayBuffers(buffers) {\n  var buffersLengths = buffers.map(function (b) {\n      return b.byteLength;\n    }),\n    totalBufferlength = buffersLengths.reduce(function (p, c) {\n      return p + c;\n    }, 0),\n    unit8Arr = new Uint8Array(totalBufferlength);\n  buffersLengths.reduce(function (p, c, i) {\n    unit8Arr.set(new Uint8Array(buffers[i]), p);\n    return p + c;\n  }, 0);\n  return unit8Arr.buffer;\n}\n\nclass Timer {\n  constructor(timeout, callback, args, label) {\n    this._timeout = timeout;\n    this._callback = callback;\n    this._args = args;\n    this._label = label || \"timer\";\n    this._task = null;\n    this.started = false;\n  }\n\n  start() {\n    if (this.started) {\n      this.reset();\n    } else {\n      this._task = setTimeout(() => {\n        this._callback.apply(this, this._args);\n      }, this._timeout * 1000);\n      this.started = true;\n    }\n  }\n\n  clear() {\n    if (this._task && this.started) {\n      clearTimeout(this._task);\n      this._task = null;\n      this.started = false;\n    } else {\n      console.warn(`Clearing a timer (${this._label}) which is not started`);\n    }\n  }\n\n  reset() {\n    if (this._task) {\n      clearTimeout(this._task);\n    }\n    this._task = setTimeout(() => {\n      this._callback.apply(this, this._args);\n    }, this._timeout * 1000);\n    this.started = true;\n  }\n}\n\nclass RemoteService extends Object {}\n\n/**\n * RPC object represents a single site in the\n * communication protocol between the application and the plugin\n *\n * @param {Object} connection a special object allowing to send\n * and receive messages from the opposite site (basically it\n * should only provide send() and onMessage() methods)\n */\nexport class RPC extends MessageEmitter {\n  constructor(\n    connection,\n    {\n      client_id = null,\n      default_context = null,\n      name = null,\n      codecs = null,\n      method_timeout = null,\n      max_message_buffer_size = 0,\n      debug = false,\n      workspace = null,\n      silent = false,\n      app_id = null,\n      server_base_url = null,\n      long_message_chunk_size = null,\n    },\n  ) {\n    super(debug);\n    this._codecs = codecs || {};\n    assert(client_id && typeof client_id === \"string\");\n    assert(client_id, \"client_id is required\");\n    this._client_id = client_id;\n    this._name = name;\n    this._app_id = app_id || \"*\";\n    this._local_workspace = workspace;\n    this._silent = silent;\n    this.default_context = default_context || {};\n    this._method_annotations = new WeakMap();\n    this._max_message_buffer_size = max_message_buffer_size;\n    this._chunk_store = {};\n    this._method_timeout = method_timeout || 30;\n    this._server_base_url = server_base_url;\n    this._long_message_chunk_size = long_message_chunk_size || CHUNK_SIZE;\n\n    // make sure there is an execute function\n    this._services = {};\n    this._object_store = {\n      services: this._services,\n    };\n\n    // Track background tasks for proper cleanup\n    this._background_tasks = new Set();\n\n    // Set up global unhandled promise rejection handler for RPC-related errors\n    const handleUnhandledRejection = (event) => {\n      const reason = event.reason;\n      if (reason && typeof reason === \"object\") {\n        // Check if this is a \"Method not found\" or \"Session not found\" error that we can ignore\n        const reasonStr = reason.toString();\n        if (\n          reasonStr.includes(\"Method not found\") ||\n          reasonStr.includes(\"Session not found\") ||\n          reasonStr.includes(\"Method expired\") ||\n          reasonStr.includes(\"Session not found\")\n        ) {\n          console.debug(\n            \"Ignoring expected method/session not found error:\",\n            reason,\n          );\n          event.preventDefault(); // Prevent the default unhandled rejection behavior\n          return;\n        }\n      }\n      console.warn(\"Unhandled RPC promise rejection:\", reason);\n    };\n\n    // Only set the handler if we haven't already set one for this RPC instance\n    if (typeof window !== \"undefined\" && !window._hypha_rejection_handler_set) {\n      window.addEventListener(\"unhandledrejection\", handleUnhandledRejection);\n      window._hypha_rejection_handler_set = true;\n    } else if (\n      typeof process !== \"undefined\" &&\n      !process._hypha_rejection_handler_set\n    ) {\n      process.on(\"unhandledRejection\", (reason, promise) => {\n        handleUnhandledRejection({ reason, promise, preventDefault: () => {} });\n      });\n      process._hypha_rejection_handler_set = true;\n    }\n\n    if (connection) {\n      this.add_service({\n        id: \"built-in\",\n        type: \"built-in\",\n        name: `Built-in services for ${this._local_workspace}/${this._client_id}`,\n        config: {\n          require_context: true,\n          visibility: \"public\",\n          api_version: API_VERSION,\n        },\n        ping: this._ping.bind(this),\n        get_service: this.get_local_service.bind(this),\n        message_cache: {\n          create: this._create_message.bind(this),\n          append: this._append_message.bind(this),\n          set: this._set_message.bind(this),\n          process: this._process_message.bind(this),\n          remove: this._remove_message.bind(this),\n        },\n      });\n      this.on(\"method\", this._handle_method.bind(this));\n      this.on(\"error\", console.error);\n\n      assert(connection.emit_message && connection.on_message);\n      assert(\n        connection.manager_id !== undefined,\n        \"Connection must have manager_id\",\n      );\n      this._emit_message = connection.emit_message.bind(connection);\n      connection.on_message(this._on_message.bind(this));\n      this._connection = connection;\n      const onConnected = async (connectionInfo) => {\n        if (!this._silent && this._connection.manager_id) {\n          console.debug(\"Connection established, reporting services...\");\n          try {\n            // Retry getting manager service with exponential backoff\n            const manager = await this._get_manager_with_retry();\n            const services = Object.values(this._services);\n            const servicesCount = services.length;\n            let registeredCount = 0;\n            const failedServices = [];\n\n            // Use timeout for service registration to prevent hanging\n            const serviceRegistrationTimeout = this._method_timeout || 30000;\n\n            for (let service of services) {\n              try {\n                const serviceInfo = this._extract_service_info(service);\n                await withTimeout(\n                  manager.registerService(serviceInfo),\n                  serviceRegistrationTimeout,\n                  `Timeout registering service ${service.id || \"unknown\"}`,\n                );\n                registeredCount++;\n                console.debug(\n                  `Successfully registered service: ${service.id || \"unknown\"}`,\n                );\n              } catch (serviceError) {\n                failedServices.push(service.id || \"unknown\");\n                if (\n                  serviceError.message &&\n                  serviceError.message.includes(\"TimeoutError\")\n                ) {\n                  console.error(\n                    `Timeout registering service ${service.id || \"unknown\"}`,\n                  );\n                } else {\n                  console.error(\n                    `Failed to register service ${service.id || \"unknown\"}: ${serviceError}`,\n                  );\n                }\n              }\n            }\n\n            if (registeredCount === servicesCount) {\n              console.info(\n                `Successfully registered all ${registeredCount} services with the server`,\n              );\n            } else {\n              console.warn(\n                `Only registered ${registeredCount} out of ${servicesCount} services with the server. Failed services: ${failedServices.join(\", \")}`,\n              );\n            }\n\n            // Fire event with registration status\n            this._fire(\"services_registered\", {\n              total: servicesCount,\n              registered: registeredCount,\n              failed: failedServices,\n            });\n\n            // Subscribe to client_disconnected events if the manager supports it\n            try {\n              if (\n                manager.subscribe &&\n                typeof manager.subscribe === \"function\"\n              ) {\n                console.debug(\"Subscribing to client_disconnected events\");\n\n                const handleClientDisconnected = async (event) => {\n                  // The client ID is in event.data.id based on the event structure\n                  const clientId = event.data?.id || event.client;\n                  const workspace = event.data?.workspace;\n                  if (clientId && workspace) {\n                    // Construct the full client path with workspace prefix\n                    const fullClientId = `${workspace}/${clientId}`;\n                    console.debug(\n                      `Client ${fullClientId} disconnected, cleaning up sessions`,\n                    );\n                    await this._handleClientDisconnected(fullClientId);\n                  } else if (clientId) {\n                    console.debug(\n                      `Client ${clientId} disconnected, cleaning up sessions`,\n                    );\n                    await this._handleClientDisconnected(clientId);\n                  }\n                };\n\n                // Subscribe to the event topic first with timeout\n                this._clientDisconnectedSubscription = await withTimeout(\n                  manager.subscribe([\"client_disconnected\"]),\n                  serviceRegistrationTimeout,\n                  \"Timeout subscribing to client_disconnected events\",\n                );\n\n                // Then register the local event handler\n                this.on(\"client_disconnected\", handleClientDisconnected);\n\n                console.debug(\n                  \"Successfully subscribed to client_disconnected events\",\n                );\n              } else {\n                console.debug(\n                  \"Manager does not support subscribe method, skipping client_disconnected handling\",\n                );\n                this._clientDisconnectedSubscription = null;\n              }\n            } catch (subscribeError) {\n              console.warn(\n                `Failed to subscribe to client_disconnected events: ${subscribeError}`,\n              );\n              this._clientDisconnectedSubscription = null;\n            }\n          } catch (managerError) {\n            console.error(\n              `Failed to get manager service for registering services: ${managerError}`,\n            );\n            // Fire event with error status\n            this._fire(\"services_registration_failed\", {\n              error: managerError.toString(),\n              total_services: Object.keys(this._services).length,\n            });\n          }\n        } else {\n          // console.debug(\"Connection established\", connectionInfo);\n        }\n        if (connectionInfo) {\n          if (connectionInfo.public_base_url) {\n            this._server_base_url = connectionInfo.public_base_url;\n          }\n          this._fire(\"connected\", connectionInfo);\n        }\n      };\n      connection.on_connected(onConnected);\n      onConnected();\n    } else {\n      this._emit_message = function () {\n        console.log(\"No connection to emit message\");\n      };\n    }\n  }\n\n  register_codec(config) {\n    if (!config[\"name\"] || (!config[\"encoder\"] && !config[\"decoder\"])) {\n      throw new Error(\n        \"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\",\n      );\n    } else {\n      if (config.type) {\n        for (let k of Object.keys(this._codecs)) {\n          if (this._codecs[k].type === config.type || k === config.name) {\n            delete this._codecs[k];\n            console.warn(\"Remove duplicated codec: \" + k);\n          }\n        }\n      }\n      this._codecs[config[\"name\"]] = config;\n    }\n  }\n\n  async _ping(msg, context) {\n    assert(msg == \"ping\");\n    return \"pong\";\n  }\n\n  async ping(client_id, timeout) {\n    let method = this._generate_remote_method({\n      _rserver: this._server_base_url,\n      _rtarget: client_id,\n      _rmethod: \"services.built-in.ping\",\n      _rpromise: true,\n      _rdoc: \"Ping a remote client\",\n    });\n    assert((await method(\"ping\", timeout)) == \"pong\");\n  }\n\n  _create_message(key, heartbeat, overwrite, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n      this._object_store[key][\"timer\"].reset();\n    }\n\n    if (!this._object_store[\"message_cache\"]) {\n      this._object_store[\"message_cache\"] = {};\n    }\n    if (!overwrite && this._object_store[\"message_cache\"][key]) {\n      throw new Error(\n        `Message with the same key (${key}) already exists in the cache store, please use overwrite=true or remove it first.`,\n      );\n    }\n    this._object_store[\"message_cache\"][key] = [];\n  }\n\n  _append_message(key, data, heartbeat, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n      this._object_store[key][\"timer\"].reset();\n    }\n    const cache = this._object_store[\"message_cache\"];\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n    assert(data instanceof ArrayBufferView);\n    cache[key].push(data);\n  }\n\n  _set_message(key, index, data, heartbeat, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n      this._object_store[key][\"timer\"].reset();\n    }\n    const cache = this._object_store[\"message_cache\"];\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n    assert(data instanceof ArrayBufferView);\n    cache[key][index] = data;\n  }\n\n  _remove_message(key, context) {\n    const cache = this._object_store[\"message_cache\"];\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n    delete cache[key];\n  }\n\n  _process_message(key, heartbeat, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n      this._object_store[key][\"timer\"].reset();\n    }\n    const cache = this._object_store[\"message_cache\"];\n    assert(!!context, \"Context is required\");\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n    cache[key] = concatArrayBuffers(cache[key]);\n    // console.debug(`Processing message ${key} (bytes=${cache[key].byteLength})`);\n    let unpacker = decodeMulti(cache[key]);\n    const { done, value } = unpacker.next();\n    const main = value;\n    // Make sure the fields are from trusted source\n    Object.assign(main, {\n      from: context.from,\n      to: context.to,\n      ws: context.ws,\n      user: context.user,\n    });\n    main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n    Object.assign(main[\"ctx\"], this.default_context);\n    if (!done) {\n      let extra = unpacker.next();\n      Object.assign(main, extra.value);\n    }\n    this._fire(main[\"type\"], main);\n    // console.debug(\n    //   this._client_id,\n    //   `Processed message ${key} (bytes=${cache[key].byteLength})`,\n    // );\n    delete cache[key];\n  }\n\n  _on_message(message) {\n    if (typeof message === \"string\") {\n      const main = JSON.parse(message);\n      // Add trusted context to the method call\n      main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n      Object.assign(main[\"ctx\"], this.default_context);\n      this._fire(main[\"type\"], main);\n    } else if (message instanceof ArrayBuffer || ArrayBuffer.isView(message)) {\n      // Handle both ArrayBuffer (WebSocket) and Uint8Array/ArrayBufferView (HTTP transport)\n      let unpacker = decodeMulti(message);\n      const { done, value } = unpacker.next();\n      const main = value;\n      // Add trusted context to the method call\n      main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n      Object.assign(main[\"ctx\"], this.default_context);\n      if (!done) {\n        let extra = unpacker.next();\n        Object.assign(main, extra.value);\n      }\n      this._fire(main[\"type\"], main);\n    } else if (typeof message === \"object\") {\n      // Add trusted context to the method call\n      message[\"ctx\"] = JSON.parse(JSON.stringify(message));\n      Object.assign(message[\"ctx\"], this.default_context);\n      this._fire(message[\"type\"], message);\n    } else {\n      throw new Error(\"Invalid message format\");\n    }\n  }\n\n  reset() {\n    this._event_handlers = {};\n    this._services = {};\n  }\n\n  close() {\n    // Clean up all pending sessions before closing\n    this._cleanupOnDisconnect();\n\n    // Clear all heartbeat intervals\n    for (const session_id in this._object_store) {\n      if (this._object_store.hasOwnProperty(session_id)) {\n        const session = this._object_store[session_id];\n        if (session && session.heartbeat_task) {\n          clearInterval(session.heartbeat_task);\n        }\n        if (session && session.timer) {\n          session.timer.clear();\n        }\n      }\n    }\n\n    // Unsubscribe from client_disconnected events if subscribed\n    if (this._clientDisconnectedSubscription) {\n      try {\n        // Get the manager service to unsubscribe (non-blocking)\n        if (this._connection && this._connection.manager_id) {\n          this.get_remote_service(\"*/\" + this._connection.manager_id)\n            .then((manager) => {\n              if (\n                manager.unsubscribe &&\n                typeof manager.unsubscribe === \"function\"\n              ) {\n                return manager.unsubscribe(\"client_disconnected\");\n              }\n            })\n            .catch((e) => {\n              console.debug(\n                `Error unsubscribing from client_disconnected: ${e}`,\n              );\n            });\n        }\n        // Remove the local event handler\n        this.off(\"client_disconnected\");\n      } catch (e) {\n        console.debug(`Error unsubscribing from client_disconnected: ${e}`);\n      }\n    }\n\n    // Clean up background tasks\n    try {\n      // Cancel all background tasks\n      for (const task of this._background_tasks) {\n        if (task && typeof task.cancel === \"function\") {\n          try {\n            task.cancel();\n          } catch (e) {\n            console.debug(`Error canceling background task: ${e}`);\n          }\n        }\n      }\n      this._background_tasks.clear();\n    } catch (e) {\n      console.debug(`Error cleaning up background tasks: ${e}`);\n    }\n\n    // Clean up connection references to prevent circular references\n    try {\n      // Clear connection reference to break circular references\n      this._connection = null;\n\n      // Replace emit_message with a no-op to prevent further calls\n      this._emit_message = function () {\n        console.debug(\"RPC connection closed, ignoring message\");\n        return Promise.reject(new Error(\"Connection is closed\"));\n      };\n    } catch (e) {\n      console.debug(`Error during connection cleanup: ${e}`);\n    }\n\n    this._fire(\"disconnected\");\n  }\n\n  async _handleClientDisconnected(clientId) {\n    try {\n      console.debug(`Handling disconnection for client: ${clientId}`);\n\n      // Clean up all sessions for the disconnected client\n      const sessionsCleaned = this._cleanupSessionsForClient(clientId);\n\n      if (sessionsCleaned > 0) {\n        console.debug(\n          `Cleaned up ${sessionsCleaned} sessions for disconnected client: ${clientId}`,\n        );\n      }\n\n      // Fire an event to notify about the client disconnection\n      this._fire(\"remote_client_disconnected\", {\n        client_id: clientId,\n        sessions_cleaned: sessionsCleaned,\n      });\n    } catch (e) {\n      console.error(\n        `Error handling client disconnection for ${clientId}: ${e}`,\n      );\n    }\n  }\n\n  _cleanupSessionsForClient(clientId) {\n    let sessionsCleaned = 0;\n\n    // Iterate through all top-level session keys\n    for (const sessionKey of Object.keys(this._object_store)) {\n      if (sessionKey === \"services\" || sessionKey === \"message_cache\") {\n        continue;\n      }\n\n      const session = this._object_store[sessionKey];\n      if (!session || typeof session !== \"object\") {\n        continue;\n      }\n\n      // Check if this session belongs to the disconnected client\n      // Sessions have a target_id property that identifies which client they're calling\n      if (session.target_id === clientId) {\n        // Reject any pending promises in this session\n        if (session.reject && typeof session.reject === \"function\") {\n          console.debug(`Rejecting session ${sessionKey}`);\n          try {\n            session.reject(new Error(`Client disconnected: ${clientId}`));\n          } catch (e) {\n            console.warn(`Error rejecting session ${sessionKey}: ${e}`);\n          }\n        }\n\n        if (session.resolve && typeof session.resolve === \"function\") {\n          console.debug(`Resolving session ${sessionKey} with error`);\n          try {\n            session.resolve(new Error(`Client disconnected: ${clientId}`));\n          } catch (e) {\n            console.warn(`Error resolving session ${sessionKey}: ${e}`);\n          }\n        }\n\n        // Clear any timers\n        if (session.timer && typeof session.timer.clear === \"function\") {\n          try {\n            session.timer.clear();\n          } catch (e) {\n            console.warn(`Error clearing timer for ${sessionKey}: ${e}`);\n          }\n        }\n\n        // Clear heartbeat tasks\n        if (session.heartbeat_task) {\n          try {\n            clearInterval(session.heartbeat_task);\n          } catch (e) {\n            console.warn(`Error clearing heartbeat for ${sessionKey}: ${e}`);\n          }\n        }\n\n        // Remove the entire session\n        delete this._object_store[sessionKey];\n        sessionsCleaned++;\n        console.debug(`Cleaned up session: ${sessionKey}`);\n      }\n    }\n\n    return sessionsCleaned;\n  }\n\n  _cleanupOnDisconnect() {\n    try {\n      console.debug(\"Cleaning up all sessions due to local RPC disconnection\");\n\n      // Get all keys to delete after cleanup\n      const keysToDelete = [];\n\n      for (const key of Object.keys(this._object_store)) {\n        if (key === \"services\") {\n          continue;\n        }\n\n        const value = this._object_store[key];\n\n        if (typeof value === \"object\" && value !== null) {\n          // Reject any pending promises\n          if (value.reject && typeof value.reject === \"function\") {\n            try {\n              value.reject(new Error(\"RPC connection closed\"));\n            } catch (e) {\n              console.debug(`Error rejecting promise during cleanup: ${e}`);\n            }\n          }\n\n          // Clean up timers and tasks\n          if (value.heartbeat_task) {\n            clearInterval(value.heartbeat_task);\n          }\n          if (value.timer && typeof value.timer.clear === \"function\") {\n            try {\n              value.timer.clear();\n            } catch (e) {\n              console.debug(`Error clearing timer: ${e}`);\n            }\n          }\n        }\n\n        // Mark ALL keys for deletion except services\n        keysToDelete.push(key);\n      }\n\n      // Delete all marked sessions\n      for (const key of keysToDelete) {\n        delete this._object_store[key];\n      }\n    } catch (e) {\n      console.error(`Error during cleanup on disconnect: ${e}`);\n    }\n  }\n\n  async disconnect() {\n    // Store connection reference before closing\n    const connection = this._connection;\n    this.close();\n\n    // Disconnect the underlying connection if it exists\n    if (connection) {\n      try {\n        await connection.disconnect();\n      } catch (e) {\n        console.debug(`Error disconnecting underlying connection: ${e}`);\n      }\n    }\n  }\n\n  async _get_manager_with_retry(maxRetries = 20) {\n    const baseDelay = 500;\n    const maxDelay = 10000;\n    let lastError = null;\n\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n      try {\n        const svc = await this.get_remote_service(\n          `*/${this._connection.manager_id}:default`,\n          { timeout: 20, case_conversion: \"camel\" },\n        );\n        return svc;\n      } catch (e) {\n        lastError = e;\n        console.warn(\n          `Failed to get manager service (attempt ${attempt + 1}/${maxRetries}): ${e.message}`,\n        );\n        if (attempt < maxRetries - 1) {\n          // Exponential backoff with maximum delay\n          const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    // If we get here, all retries failed\n    throw lastError;\n  }\n\n  async get_manager_service(config) {\n    config = config || {};\n\n    // Add retry logic\n    const maxRetries = 20;\n    const retryDelay = 500; // 500ms\n\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n      if (!this._connection.manager_id) {\n        if (attempt < maxRetries - 1) {\n          console.warn(\n            `Manager ID not set, retrying in ${retryDelay}ms (attempt ${attempt + 1}/${maxRetries})`,\n          );\n          await new Promise((resolve) => setTimeout(resolve, retryDelay));\n          continue;\n        } else {\n          throw new Error(\"Manager ID not set after maximum retries\");\n        }\n      }\n\n      try {\n        const svc = await this.get_remote_service(\n          `*/${this._connection.manager_id}:default`,\n          config,\n        );\n        return svc;\n      } catch (e) {\n        if (attempt < maxRetries - 1) {\n          console.warn(\n            `Failed to get manager service, retrying in ${retryDelay}ms: ${e.message}`,\n          );\n          await new Promise((resolve) => setTimeout(resolve, retryDelay));\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n\n  get_all_local_services() {\n    return this._services;\n  }\n  get_local_service(service_id, context) {\n    assert(service_id);\n    assert(context, \"Context is required\");\n\n    const [ws, client_id] = context[\"to\"].split(\"/\");\n    assert(\n      client_id === this._client_id,\n      \"Services can only be accessed locally\",\n    );\n\n    const service = this._services[service_id];\n    if (!service) {\n      throw new Error(\"Service not found: \" + service_id);\n    }\n\n    // Note: Do NOT mutate service.config.workspace here!\n    // Doing so would corrupt the stored service config when called from\n    // a different workspace (e.g., \"public\"), causing reconnection to fail\n    // because _extract_service_info would use the wrong workspace value.\n\n    // allow access for the same workspace\n    if (\n      service.config.visibility == \"public\" ||\n      service.config.visibility == \"unlisted\"\n    ) {\n      return service;\n    }\n\n    // allow access for the same workspace\n    if (context[\"ws\"] === ws) {\n      return service;\n    }\n\n    // Check if user is from an authorized workspace\n    const authorized_workspaces = service.config.authorized_workspaces;\n    if (\n      authorized_workspaces &&\n      authorized_workspaces.includes(context[\"ws\"])\n    ) {\n      return service;\n    }\n\n    throw new Error(\n      `Permission denied for getting protected service: ${service_id}, workspace mismatch: ${ws} != ${context[\"ws\"]}`,\n    );\n  }\n  async get_remote_service(service_uri, config) {\n    let { timeout, case_conversion, kwargs_expansion } = config || {};\n    timeout = timeout === undefined ? this._method_timeout : timeout;\n    if (!service_uri && this._connection.manager_id) {\n      service_uri = \"*/\" + this._connection.manager_id;\n    } else if (!service_uri.includes(\":\")) {\n      service_uri = this._client_id + \":\" + service_uri;\n    }\n    const provider = service_uri.split(\":\")[0];\n    let service_id = service_uri.split(\":\")[1];\n    if (service_id.includes(\"@\")) {\n      service_id = service_id.split(\"@\")[0];\n      const app_id = service_uri.split(\"@\")[1];\n      if (this._app_id && this._app_id !== \"*\")\n        assert(\n          app_id === this._app_id,\n          `Invalid app id: ${app_id} != ${this._app_id}`,\n        );\n    }\n    assert(provider, `Invalid service uri: ${service_uri}`);\n\n    try {\n      const method = this._generate_remote_method({\n        _rserver: this._server_base_url,\n        _rtarget: provider,\n        _rmethod: \"services.built-in.get_service\",\n        _rpromise: true,\n        _rdoc: \"Get a remote service\",\n      });\n      let svc = await waitFor(\n        method(service_id),\n        timeout,\n        \"Timeout Error: Failed to get remote service: \" + service_uri,\n      );\n      svc.id = `${provider}:${service_id}`;\n      if (kwargs_expansion) {\n        svc = expandKwargs(svc);\n      }\n      if (case_conversion)\n        return Object.assign(\n          new RemoteService(),\n          convertCase(svc, case_conversion),\n        );\n      else return Object.assign(new RemoteService(), svc);\n    } catch (e) {\n      console.warn(\"Failed to get remote service: \" + service_uri, e);\n      throw e;\n    }\n  }\n  _annotate_service_methods(\n    aObject,\n    object_id,\n    require_context,\n    run_in_executor,\n    visibility,\n    authorized_workspaces,\n  ) {\n    if (typeof aObject === \"function\") {\n      // mark the method as a remote method that requires context\n      let method_name = object_id.split(\".\")[1];\n      this._method_annotations.set(aObject, {\n        require_context: Array.isArray(require_context)\n          ? require_context.includes(method_name)\n          : !!require_context,\n        run_in_executor: run_in_executor,\n        method_id: \"services.\" + object_id,\n        visibility: visibility,\n        authorized_workspaces: authorized_workspaces,\n      });\n    } else if (aObject instanceof Array || aObject instanceof Object) {\n      for (let key of Object.keys(aObject)) {\n        let val = aObject[key];\n        if (typeof val === \"function\" && val.__rpc_object__) {\n          let client_id = val.__rpc_object__._rtarget;\n          if (client_id.includes(\"/\")) {\n            client_id = client_id.split(\"/\")[1];\n          }\n          if (this._client_id === client_id) {\n            if (aObject instanceof Array) {\n              aObject = aObject.slice();\n            }\n            // recover local method\n            aObject[key] = indexObject(\n              this._object_store,\n              val.__rpc_object__._rmethod,\n            );\n            val = aObject[key]; // make sure it's annotated later\n          } else {\n            throw new Error(\n              `Local method not found: ${val.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${client_id}`,\n            );\n          }\n        }\n        this._annotate_service_methods(\n          val,\n          object_id + \".\" + key,\n          require_context,\n          run_in_executor,\n          visibility,\n          authorized_workspaces,\n        );\n      }\n    }\n  }\n  add_service(api, overwrite) {\n    if (!api || Array.isArray(api)) throw new Error(\"Invalid service object\");\n    if (api.constructor === Object) {\n      api = Object.assign({}, api);\n    } else {\n      const normApi = {};\n      const props = Object.getOwnPropertyNames(api).concat(\n        Object.getOwnPropertyNames(Object.getPrototypeOf(api)),\n      );\n      for (let k of props) {\n        if (k !== \"constructor\") {\n          if (typeof api[k] === \"function\") normApi[k] = api[k].bind(api);\n          else normApi[k] = api[k];\n        }\n      }\n      // For class instance, we need set a default id\n      api.id = api.id || \"default\";\n      api = normApi;\n    }\n    assert(\n      api.id && typeof api.id === \"string\",\n      `Service id not found: ${api}`,\n    );\n    if (!api.name) {\n      api.name = api.id;\n    }\n    if (!api.config) {\n      api.config = {};\n    }\n    if (!api.type) {\n      api.type = \"generic\";\n    }\n    // require_context only applies to the top-level functions\n    let require_context = false,\n      run_in_executor = false;\n    if (api.config.require_context)\n      require_context = api.config.require_context;\n    if (api.config.run_in_executor) run_in_executor = true;\n    const visibility = api.config.visibility || \"protected\";\n    assert([\"protected\", \"public\", \"unlisted\"].includes(visibility));\n\n    // Validate authorized_workspaces\n    const authorized_workspaces = api.config.authorized_workspaces;\n    if (authorized_workspaces !== undefined) {\n      if (visibility !== \"protected\") {\n        throw new Error(\n          `authorized_workspaces can only be set when visibility is 'protected', got visibility='${visibility}'`,\n        );\n      }\n      if (!Array.isArray(authorized_workspaces)) {\n        throw new Error(\n          \"authorized_workspaces must be an array of workspace ids\",\n        );\n      }\n      for (const ws_id of authorized_workspaces) {\n        if (typeof ws_id !== \"string\") {\n          throw new Error(\n            `Each workspace id in authorized_workspaces must be a string, got ${typeof ws_id}`,\n          );\n        }\n      }\n    }\n    this._annotate_service_methods(\n      api,\n      api[\"id\"],\n      require_context,\n      run_in_executor,\n      visibility,\n      authorized_workspaces,\n    );\n\n    if (this._services[api.id]) {\n      if (overwrite) {\n        delete this._services[api.id];\n      } else {\n        throw new Error(\n          `Service already exists: ${api.id}, please specify a different id (not ${api.id}) or overwrite=true`,\n        );\n      }\n    }\n    this._services[api.id] = api;\n    return api;\n  }\n\n  _extract_service_info(service) {\n    const config = service.config || {};\n    config.workspace =\n      config.workspace || this._local_workspace || this._connection.workspace;\n    if (!config.workspace) {\n      throw new Error(\n        \"Workspace is not set. Please ensure the connection has a workspace or set local_workspace.\",\n      );\n    }\n    const skipContext = config.require_context;\n    const excludeKeys = [\n      \"id\",\n      \"config\",\n      \"name\",\n      \"description\",\n      \"type\",\n      \"docs\",\n      \"app_id\",\n      \"service_schema\",\n    ];\n    const filteredService = {};\n    for (const key of Object.keys(service)) {\n      if (!excludeKeys.includes(key)) {\n        filteredService[key] = service[key];\n      }\n    }\n    const serviceSchema = _get_schema(filteredService, null, skipContext);\n    const serviceInfo = {\n      config: config,\n      id: `${config.workspace}/${this._client_id}:${service[\"id\"]}`,\n      name: service.name || service[\"id\"],\n      description: service.description || \"\",\n      type: service.type || \"generic\",\n      docs: service.docs || null,\n      app_id: this._app_id,\n      service_schema: serviceSchema,\n    };\n    return serviceInfo;\n  }\n\n  async get_service_schema(service) {\n    const skipContext = service.config.require_context;\n    return _get_schema(service, null, skipContext);\n  }\n\n  async register_service(api, config) {\n    let { check_type, notify, overwrite } = config || {};\n    notify = notify === undefined ? true : notify;\n    let manager;\n    if (check_type && api.type) {\n      try {\n        manager = await this.get_manager_service({\n          timeout: 10,\n          case_conversion: \"camel\",\n        });\n        const type_info = await manager.get_service_type(api.type);\n        api = _annotate_service(api, type_info);\n      } catch (e) {\n        throw new Error(`Failed to get service type ${api.type}, error: ${e}`);\n      }\n    }\n\n    const service = this.add_service(api, overwrite);\n    const serviceInfo = this._extract_service_info(service);\n    if (notify) {\n      try {\n        manager =\n          manager ||\n          (await this.get_manager_service({\n            timeout: 10,\n            case_conversion: \"camel\",\n          }));\n        await manager.registerService(serviceInfo);\n      } catch (e) {\n        throw new Error(`Failed to notify workspace manager: ${e}`);\n      }\n    }\n    return serviceInfo;\n  }\n\n  async unregister_service(service, notify) {\n    notify = notify === undefined ? true : notify;\n    let service_id;\n    if (typeof service === \"string\") {\n      service_id = service;\n    } else {\n      service_id = service.id;\n    }\n    assert(\n      service_id && typeof service_id === \"string\",\n      `Invalid service id: ${service_id}`,\n    );\n    if (service_id.includes(\":\")) {\n      service_id = service_id.split(\":\")[1];\n    }\n    if (service_id.includes(\"@\")) {\n      service_id = service_id.split(\"@\")[0];\n    }\n    if (!this._services[service_id]) {\n      throw new Error(`Service not found: ${service_id}`);\n    }\n    if (notify) {\n      const manager = await this.get_manager_service({\n        timeout: 10,\n        case_conversion: \"camel\",\n      });\n      await manager.unregisterService(service_id);\n    }\n    delete this._services[service_id];\n  }\n\n  _ndarray(typedArray, shape, dtype) {\n    const _dtype = typedArrayToDtype(typedArray);\n    if (dtype && dtype !== _dtype) {\n      throw (\n        \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype\n      );\n    }\n    shape = shape || [typedArray.length];\n    return {\n      _rtype: \"ndarray\",\n      _rvalue: typedArray.buffer,\n      _rshape: shape,\n      _rdtype: _dtype,\n    };\n  }\n\n  _encode_callback(\n    name,\n    callback,\n    session_id,\n    clear_after_called,\n    timer,\n    local_workspace,\n    description,\n  ) {\n    let method_id = `${session_id}.${name}`;\n    let encoded = {\n      _rtype: \"method\",\n      _rtarget: local_workspace\n        ? `${local_workspace}/${this._client_id}`\n        : this._client_id,\n      _rmethod: method_id,\n      _rpromise: false,\n    };\n\n    const self = this;\n    let wrapped_callback = function () {\n      try {\n        callback.apply(null, Array.prototype.slice.call(arguments));\n      } catch (error) {\n        console.error(\n          `Error in callback(${method_id}, ${description}): ${error}`,\n        );\n      } finally {\n        // Clear the timer first if it exists\n        if (timer && timer.started) {\n          timer.clear();\n        }\n\n        // Clean up the entire session when resolve/reject is called\n        if (clear_after_called && self._object_store[session_id]) {\n          // For promise callbacks (resolve/reject), clean up the entire session\n          if (name === \"resolve\" || name === \"reject\") {\n            delete self._object_store[session_id];\n          } else {\n            // For other callbacks, just clean up this specific callback\n            self._cleanup_session_if_needed(session_id, name);\n          }\n        }\n      }\n    };\n    wrapped_callback.__name__ = `callback(${method_id})`;\n    return [encoded, wrapped_callback];\n  }\n\n  _cleanup_session_if_needed(session_id, callback_name) {\n    /**\n     * Clean session management - all logic in one place.\n     */\n    if (!session_id) {\n      console.debug(\"Cannot cleanup session: session_id is empty\");\n      return;\n    }\n\n    try {\n      const store = this._get_session_store(session_id, false);\n      if (!store) {\n        console.debug(`Session ${session_id} not found for cleanup`);\n        return;\n      }\n\n      let should_cleanup = false;\n\n      // Promise sessions: let the promise manager decide cleanup\n      if (store._promise_manager) {\n        try {\n          const promise_manager = store._promise_manager;\n          if (\n            promise_manager.should_cleanup_on_callback &&\n            promise_manager.should_cleanup_on_callback(callback_name)\n          ) {\n            if (promise_manager.settle) {\n              promise_manager.settle();\n            }\n            should_cleanup = true;\n            console.debug(\n              `Promise session ${session_id} settled and marked for cleanup`,\n            );\n          }\n        } catch (e) {\n          console.warn(\n            `Error in promise manager cleanup for session ${session_id}:`,\n            e,\n          );\n        }\n      } else {\n        // Regular sessions: only cleanup temporary method call sessions\n        // Don't cleanup service registration sessions or persistent sessions\n        // Only cleanup sessions that are clearly temporary promises for method calls\n        if (\n          (callback_name === \"resolve\" || callback_name === \"reject\") &&\n          store._callbacks &&\n          Object.keys(store._callbacks).includes(callback_name)\n        ) {\n          should_cleanup = true;\n          console.debug(\n            `Regular session ${session_id} marked for cleanup after ${callback_name}`,\n          );\n        }\n      }\n\n      if (should_cleanup) {\n        this._cleanup_session_completely(session_id);\n      }\n    } catch (error) {\n      console.warn(`Error during session cleanup for ${session_id}:`, error);\n    }\n  }\n\n  _cleanup_session_completely(session_id) {\n    /**\n     * Complete session cleanup with resource management.\n     */\n    try {\n      const store = this._get_session_store(session_id, false);\n      if (!store) {\n        console.debug(`Session ${session_id} already cleaned up`);\n        return;\n      }\n\n      // Clean up resources before removing session\n      if (store.timer && typeof store.timer.clear === \"function\") {\n        try {\n          store.timer.clear();\n        } catch (error) {\n          console.warn(\n            `Error clearing timer for session ${session_id}:`,\n            error,\n          );\n        }\n      }\n\n      if (\n        store.heartbeat_task &&\n        typeof store.heartbeat_task.cancel === \"function\"\n      ) {\n        try {\n          store.heartbeat_task.cancel();\n        } catch (error) {\n          console.warn(\n            `Error canceling heartbeat for session ${session_id}:`,\n            error,\n          );\n        }\n      }\n\n      // Navigate and clean session path\n      const levels = session_id.split(\".\");\n      let current_store = this._object_store;\n\n      // Navigate to parent of target level\n      for (let i = 0; i < levels.length - 1; i++) {\n        const level = levels[i];\n        if (!current_store[level]) {\n          console.debug(\n            `Session path ${session_id} not found at level ${level}`,\n          );\n          return;\n        }\n        current_store = current_store[level];\n      }\n\n      // Delete the final level\n      const final_key = levels[levels.length - 1];\n      if (current_store[final_key]) {\n        delete current_store[final_key];\n        console.debug(`Cleaned up session ${session_id}`);\n\n        // Clean up empty parent containers\n        this._cleanup_empty_containers(levels.slice(0, -1));\n      }\n    } catch (error) {\n      console.warn(\n        `Error in complete session cleanup for ${session_id}:`,\n        error,\n      );\n    }\n  }\n\n  _cleanup_empty_containers(path_levels) {\n    /**\n     * Clean up empty parent containers to prevent memory leaks.\n     */\n    try {\n      // Work backwards from the deepest level\n      for (let depth = path_levels.length - 1; depth >= 0; depth--) {\n        let current_store = this._object_store;\n\n        // Navigate to parent of current depth\n        for (let i = 0; i < depth; i++) {\n          current_store = current_store[path_levels[i]];\n          if (!current_store) return; // Path doesn't exist\n        }\n\n        // Check if container at current depth is empty\n        const container_key = path_levels[depth];\n        const container = current_store[container_key];\n\n        if (\n          container &&\n          typeof container === \"object\" &&\n          Object.keys(container).length === 0\n        ) {\n          delete current_store[container_key];\n          console.debug(\n            `Cleaned up empty container at depth ${depth}: ${path_levels.slice(0, depth + 1).join(\".\")}`,\n          );\n        } else {\n          // Container is not empty, stop cleanup\n          break;\n        }\n      }\n    } catch (error) {\n      console.warn(\"Error cleaning up empty containers:\", error);\n    }\n  }\n\n  get_session_stats() {\n    /**\n     * Get detailed session statistics.\n     */\n    const stats = {\n      total_sessions: 0,\n      promise_sessions: 0,\n      regular_sessions: 0,\n      sessions_with_timers: 0,\n      sessions_with_heartbeat: 0,\n      system_stores: {},\n      session_ids: [],\n      memory_usage: 0,\n    };\n\n    if (!this._object_store) {\n      return stats;\n    }\n\n    for (const key in this._object_store) {\n      const value = this._object_store[key];\n\n      if ([\"services\", \"message_cache\"].includes(key)) {\n        // System stores - don't count these as sessions\n        stats.system_stores[key] = {\n          size:\n            typeof value === \"object\" && value ? Object.keys(value).length : 0,\n        };\n        continue;\n      }\n\n      // Count all non-system non-empty objects as sessions\n      if (value && typeof value === \"object\") {\n        const sessionKeys = Object.keys(value);\n\n        // Only skip completely empty objects\n        if (sessionKeys.length > 0) {\n          stats.total_sessions++;\n          stats.session_ids.push(key);\n\n          if (value._promise_manager) {\n            stats.promise_sessions++;\n          } else {\n            stats.regular_sessions++;\n          }\n\n          if (value._timer || value.timer) stats.sessions_with_timers++;\n          if (value._heartbeat || value.heartbeat)\n            stats.sessions_with_heartbeat++;\n\n          // Estimate memory usage\n          stats.memory_usage += JSON.stringify(value).length;\n        }\n      }\n    }\n\n    return stats;\n  }\n\n  _force_cleanup_all_sessions() {\n    /**\n     * Force cleanup all sessions (for testing purposes).\n     */\n    if (!this._object_store) {\n      console.debug(\"Force cleaning up 0 sessions\");\n      return;\n    }\n\n    let cleaned_count = 0;\n    const keys_to_delete = [];\n\n    for (const key in this._object_store) {\n      // Don't delete system stores\n      if (![\"services\", \"message_cache\"].includes(key)) {\n        const value = this._object_store[key];\n        if (\n          value &&\n          typeof value === \"object\" &&\n          Object.keys(value).length > 0\n        ) {\n          keys_to_delete.push(key);\n          cleaned_count++;\n        }\n      }\n    }\n\n    // Delete the sessions\n    for (const key of keys_to_delete) {\n      delete this._object_store[key];\n    }\n\n    console.debug(`Force cleaning up ${cleaned_count} sessions`);\n  }\n\n  // Clean helper to identify promise method calls by session type\n  _is_promise_method_call(method_path) {\n    const session_id = method_path.split(\".\")[0];\n    const session = this._get_session_store(session_id, false);\n    return session && session._promise_manager;\n  }\n\n  // Simplified Promise Manager - enhanced version\n  _create_promise_manager() {\n    /**\n     * Create a promise manager to track promise state and decide cleanup.\n     */\n    return {\n      should_cleanup_on_callback: (callback_name) => {\n        return [\"resolve\", \"reject\"].includes(callback_name);\n      },\n      settle: () => {\n        // Promise is settled (resolved or rejected)\n        console.debug(\"Promise settled\");\n      },\n    };\n  }\n\n  async _encode_promise(\n    resolve,\n    reject,\n    session_id,\n    clear_after_called,\n    timer,\n    local_workspace,\n    description,\n  ) {\n    let store = this._get_session_store(session_id, true);\n    if (!store) {\n      console.warn(\n        `Failed to create session store ${session_id}, session management may be impaired`,\n      );\n      store = {};\n    }\n\n    // Clean promise lifecycle management - TYPE-BASED, not string-based\n    store._promise_manager = this._create_promise_manager();\n\n    let encoded = {};\n\n    if (timer && reject && this._method_timeout) {\n      [encoded.heartbeat, store.heartbeat] = this._encode_callback(\n        \"heartbeat\",\n        timer.reset.bind(timer),\n        session_id,\n        false,\n        null,\n        local_workspace,\n      );\n      store.timer = timer;\n      encoded.interval = this._method_timeout / 2;\n    } else {\n      timer = null;\n    }\n\n    [encoded.resolve, store.resolve] = this._encode_callback(\n      \"resolve\",\n      resolve,\n      session_id,\n      clear_after_called,\n      timer,\n      local_workspace,\n      `resolve (${description})`,\n    );\n    [encoded.reject, store.reject] = this._encode_callback(\n      \"reject\",\n      reject,\n      session_id,\n      clear_after_called,\n      timer,\n      local_workspace,\n      `reject (${description})`,\n    );\n    return encoded;\n  }\n\n  async _send_chunks(data, target_id, session_id) {\n    // 1) Get the remote service\n    const remote_services = await this.get_remote_service(\n      `${target_id}:built-in`,\n    );\n    if (!remote_services.message_cache) {\n      throw new Error(\n        \"Remote client does not support message caching for large messages.\",\n      );\n    }\n\n    const message_cache = remote_services.message_cache;\n    const message_id = session_id || randId();\n    const total_size = data.length;\n    const start_time = Date.now(); // measure time\n    const chunk_num = Math.ceil(total_size / this._long_message_chunk_size);\n    if (remote_services.config.api_version >= 3) {\n      await message_cache.create(message_id, !!session_id);\n      const semaphore = new Semaphore(CONCURRENCY_LIMIT);\n\n      const tasks = [];\n      for (let idx = 0; idx < chunk_num; idx++) {\n        const startByte = idx * this._long_message_chunk_size;\n        const chunk = data.slice(\n          startByte,\n          startByte + this._long_message_chunk_size,\n        );\n\n        const taskFn = async () => {\n          await message_cache.set(message_id, idx, chunk, !!session_id);\n          // console.debug(\n          //   `Sending chunk ${idx + 1}/${chunk_num} (total=${total_size} bytes)`,\n          // );\n        };\n\n        // Push into an array, each one runs under the semaphore\n        tasks.push(semaphore.run(taskFn));\n      }\n\n      // Wait for all chunk uploads to finish\n      try {\n        await Promise.all(tasks);\n      } catch (error) {\n        // If any chunk fails, clean up the message cache\n        try {\n          await message_cache.remove(message_id);\n        } catch (cleanupError) {\n          console.error(\n            `Failed to clean up message cache after error: ${cleanupError}`,\n          );\n        }\n        throw error;\n      }\n    } else {\n      // 3) Legacy version (sequential appends):\n      await message_cache.create(message_id, !!session_id);\n      for (let idx = 0; idx < chunk_num; idx++) {\n        const startByte = idx * this._long_message_chunk_size;\n        const chunk = data.slice(\n          startByte,\n          startByte + this._long_message_chunk_size,\n        );\n        await message_cache.append(message_id, chunk, !!session_id);\n        // console.debug(\n        //   `Sending chunk ${idx + 1}/${chunk_num} (total=${total_size} bytes)`,\n        // );\n      }\n    }\n    await message_cache.process(message_id, !!session_id);\n    const durationSec = ((Date.now() - start_time) / 1000).toFixed(2);\n    // console.debug(`All chunks (${total_size} bytes) sent in ${durationSec} s`);\n  }\n\n  emit(main_message, extra_data) {\n    assert(\n      typeof main_message === \"object\" && main_message.type,\n      \"Invalid message, must be an object with a `type` fields.\",\n    );\n    if (!main_message.to) {\n      this._fire(main_message.type, main_message);\n      return;\n    }\n    let message_package = msgpack_packb(main_message);\n    if (extra_data) {\n      const extra = msgpack_packb(extra_data);\n      message_package = new Uint8Array([...message_package, ...extra]);\n    }\n    const total_size = message_package.length;\n    if (total_size > this._long_message_chunk_size + 1024) {\n      console.warn(`Sending large message (size=${total_size})`);\n    }\n    return this._emit_message(message_package);\n  }\n\n  _generate_remote_method(\n    encoded_method,\n    remote_parent,\n    local_parent,\n    remote_workspace,\n    local_workspace,\n  ) {\n    let target_id = encoded_method._rtarget;\n    if (remote_workspace && !target_id.includes(\"/\")) {\n      // Don't modify target_id if it starts with */ (workspace manager service)\n      if (!target_id.startsWith(\"*/\")) {\n        if (remote_workspace !== target_id) {\n          target_id = remote_workspace + \"/\" + target_id;\n        }\n        // Fix the target id to be an absolute id\n        encoded_method._rtarget = target_id;\n      }\n    }\n    let method_id = encoded_method._rmethod;\n    let with_promise = encoded_method._rpromise || false;\n    const description = `method: ${method_id}, docs: ${encoded_method._rdoc}`;\n    const self = this;\n\n    function remote_method() {\n      return new Promise(async (resolve, reject) => {\n        let local_session_id = randId();\n        if (local_parent) {\n          // Store the children session under the parent\n          local_session_id = local_parent + \".\" + local_session_id;\n        }\n        let store = self._get_session_store(local_session_id, true);\n        if (!store) {\n          reject(\n            new Error(\n              `Runtime Error: Failed to get session store ${local_session_id} (context: ${description})`,\n            ),\n          );\n          return;\n        }\n        store[\"target_id\"] = target_id;\n        const args = await self._encode(\n          Array.prototype.slice.call(arguments),\n          local_session_id,\n          local_workspace,\n        );\n        const argLength = args.length;\n        // if the last argument is an object, mark it as kwargs\n        const withKwargs =\n          argLength > 0 &&\n          typeof args[argLength - 1] === \"object\" &&\n          args[argLength - 1] !== null &&\n          args[argLength - 1]._rkwargs;\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\n\n        let from_client;\n        if (!self._local_workspace) {\n          from_client = self._client_id;\n        } else {\n          from_client = self._local_workspace + \"/\" + self._client_id;\n        }\n\n        let main_message = {\n          type: \"method\",\n          from: from_client,\n          to: target_id,\n          method: method_id,\n        };\n        let extra_data = {};\n        if (args) {\n          extra_data[\"args\"] = args;\n        }\n        if (withKwargs) {\n          extra_data[\"with_kwargs\"] = withKwargs;\n        }\n\n        // console.log(\n        //   `Calling remote method ${target_id}:${method_id}, session: ${local_session_id}`\n        // );\n        if (remote_parent) {\n          // Set the parent session\n          // Note: It's a session id for the remote, not the current client\n          main_message[\"parent\"] = remote_parent;\n        }\n\n        let timer = null;\n        if (with_promise) {\n          // Only pass the current session id to the remote\n          // if we want to received the result\n          // I.e. the session id won't be passed for promises themselves\n          main_message[\"session\"] = local_session_id;\n          let method_name = `${target_id}:${method_id}`;\n\n          // Create a timer that gets reset by heartbeat\n          // Methods can run indefinitely as long as heartbeat keeps resetting the timer\n          // IMPORTANT: When timeout occurs, we must clean up the session to prevent memory leaks\n          const timeoutCallback = function (error_msg) {\n            // First reject the promise\n            reject(error_msg);\n            // Then clean up the entire session to stop all callbacks\n            if (self._object_store[local_session_id]) {\n              delete self._object_store[local_session_id];\n              console.debug(\n                `Cleaned up session ${local_session_id} after timeout`,\n              );\n            }\n          };\n\n          timer = new Timer(\n            self._method_timeout,\n            timeoutCallback,\n            [`Method call timed out: ${method_name}, context: ${description}`],\n            method_name,\n          );\n          // By default, hypha will clear the session after the method is called\n          // However, if the args contains _rintf === true, we will not clear the session\n\n          // Helper function to recursively check for _rintf objects\n          function hasInterfaceObject(obj) {\n            if (!obj || typeof obj !== \"object\") return false;\n            if (obj._rintf === true) return true;\n            if (Array.isArray(obj)) {\n              return obj.some((item) => hasInterfaceObject(item));\n            }\n            if (obj.constructor === Object) {\n              return Object.values(obj).some((value) =>\n                hasInterfaceObject(value),\n              );\n            }\n            return false;\n          }\n\n          let clear_after_called = !hasInterfaceObject(args);\n\n          const promiseData = await self._encode_promise(\n            resolve,\n            reject,\n            local_session_id,\n            clear_after_called,\n            timer,\n            local_workspace,\n            description,\n          );\n\n          if (with_promise === true) {\n            extra_data[\"promise\"] = promiseData;\n          } else if (with_promise === \"*\") {\n            extra_data[\"promise\"] = \"*\";\n            extra_data[\"t\"] = self._method_timeout / 2;\n          } else {\n            throw new Error(`Unsupported promise type: ${with_promise}`);\n          }\n        }\n        // The message consists of two segments, the main message and extra data\n        let message_package = msgpack_packb(main_message);\n        if (extra_data) {\n          const extra = msgpack_packb(extra_data);\n          message_package = new Uint8Array([...message_package, ...extra]);\n        }\n        const total_size = message_package.length;\n        if (\n          total_size <= self._long_message_chunk_size + 1024 ||\n          remote_method.__no_chunk__\n        ) {\n          self\n            ._emit_message(message_package)\n            .then(function () {\n              if (timer) {\n                // Start the timer after message is sent successfully\n                timer.start();\n              }\n            })\n            .catch(function (err) {\n              const error_msg = `Failed to send the request when calling method (${target_id}:${method_id}), error: ${err}`;\n              if (reject) {\n                reject(new Error(error_msg));\n              } else {\n                // No reject callback available, log the error to prevent unhandled promise rejections\n                console.warn(\"Unhandled RPC method call error:\", error_msg);\n              }\n              if (timer) {\n                timer.clear();\n              }\n            });\n        } else {\n          // send chunk by chunk\n          self\n            ._send_chunks(message_package, target_id, remote_parent)\n            .then(function () {\n              if (timer) {\n                // Start the timer after message is sent successfully\n                timer.start();\n              }\n            })\n            .catch(function (err) {\n              const error_msg = `Failed to send the request when calling method (${target_id}:${method_id}), error: ${err}`;\n              if (reject) {\n                reject(new Error(error_msg));\n              } else {\n                // No reject callback available, log the error to prevent unhandled promise rejections\n                console.warn(\"Unhandled RPC method call error:\", error_msg);\n              }\n              if (timer) {\n                timer.clear();\n              }\n            });\n        }\n      });\n    }\n\n    // Generate debugging information for the method\n    remote_method.__rpc_object__ = encoded_method;\n    const parts = method_id.split(\".\");\n\n    remote_method.__name__ = encoded_method._rname || parts[parts.length - 1];\n    if (remote_method.__name__.includes(\"#\")) {\n      remote_method.__name__ = remote_method.__name__.split(\"#\")[1];\n    }\n    remote_method.__doc__ =\n      encoded_method._rdoc || `Remote method: ${method_id}`;\n    remote_method.__schema__ = encoded_method._rschema;\n    // Prevent circular chunk sending\n    remote_method.__no_chunk__ =\n      encoded_method._rmethod === \"services.built-in.message_cache.append\";\n    return remote_method;\n  }\n\n  get_client_info() {\n    const services = [];\n    for (let service of Object.values(this._services)) {\n      services.push(this._extract_service_info(service));\n    }\n\n    return {\n      id: this._client_id,\n      services: services,\n    };\n  }\n\n  async _handle_method(data) {\n    let reject = null;\n    let heartbeat_task = null;\n    try {\n      assert(data.method && data.ctx && data.from);\n      const method_name = data.from + \":\" + data.method;\n      const remote_workspace = data.from.split(\"/\")[0];\n      const remote_client_id = data.from.split(\"/\")[1];\n      // Make sure the target id is an absolute id\n      data[\"to\"] = data[\"to\"].includes(\"/\")\n        ? data[\"to\"]\n        : remote_workspace + \"/\" + data[\"to\"];\n      data[\"ctx\"][\"to\"] = data[\"to\"];\n      let local_workspace;\n      if (!this._local_workspace) {\n        local_workspace = data[\"to\"].split(\"/\")[0];\n      } else {\n        if (this._local_workspace && this._local_workspace !== \"*\") {\n          assert(\n            data[\"to\"].split(\"/\")[0] === this._local_workspace,\n            \"Workspace mismatch: \" +\n              data[\"to\"].split(\"/\")[0] +\n              \" != \" +\n              this._local_workspace,\n          );\n        }\n        local_workspace = this._local_workspace;\n      }\n      const local_parent = data.parent;\n\n      let resolve, reject;\n      if (data.promise) {\n        // Decode the promise with the remote session id\n        // Such that the session id will be passed to the remote as a parent session id\n        const promise = await this._decode(\n          data.promise === \"*\" ? this._expand_promise(data) : data.promise,\n          data.session,\n          local_parent,\n          remote_workspace,\n          local_workspace,\n        );\n        resolve = promise.resolve;\n        reject = promise.reject;\n        if (promise.heartbeat && promise.interval) {\n          async function heartbeat() {\n            try {\n              // console.debug(\"Reset heartbeat timer: \" + data.method);\n              await promise.heartbeat();\n            } catch (err) {\n              console.error(err);\n            }\n          }\n          heartbeat_task = setInterval(heartbeat, promise.interval * 1000);\n          // Store the heartbeat task in the session store for cleanup\n          if (data.session) {\n            const session_store = this._get_session_store(data.session, false);\n            if (session_store) {\n              session_store.heartbeat_task = heartbeat_task;\n            }\n          }\n        }\n      }\n\n      let method;\n\n      try {\n        method = indexObject(this._object_store, data[\"method\"]);\n      } catch (e) {\n        // Clean promise method detection - TYPE-BASED, not string-based\n        if (this._is_promise_method_call(data[\"method\"])) {\n          console.debug(\n            `Promise method ${data[\"method\"]} not available (detected by session type), ignoring: ${method_name}`,\n          );\n          return;\n        }\n\n        // Check if this is a session-based method call that might have expired\n        const method_parts = data[\"method\"].split(\".\");\n        if (method_parts.length > 1) {\n          const session_id = method_parts[0];\n          // Check if the session exists but the specific method doesn't\n          if (session_id in this._object_store) {\n            console.debug(\n              `Session ${session_id} exists but method ${data[\"method\"]} not found, likely expired callback: ${method_name}`,\n            );\n            // For expired callbacks, don't throw an exception, just log and return\n            if (typeof reject === \"function\") {\n              reject(new Error(`Method expired or not found: ${method_name}`));\n            }\n            return;\n          } else {\n            console.debug(\n              `Session ${session_id} not found for method ${data[\"method\"]}, likely cleaned up: ${method_name}`,\n            );\n            // For cleaned up sessions, just log and return without throwing\n            if (typeof reject === \"function\") {\n              reject(new Error(`Session not found: ${method_name}`));\n            }\n            return;\n          }\n        }\n\n        console.debug(\n          `Failed to find method ${method_name} at ${this._client_id}`,\n        );\n        const error = new Error(\n          `Method not found: ${method_name} at ${this._client_id}`,\n        );\n        if (typeof reject === \"function\") {\n          reject(error);\n        } else {\n          // Log the error instead of throwing to prevent unhandled exceptions\n          console.warn(\n            \"Method not found and no reject callback:\",\n            error.message,\n          );\n        }\n        return;\n      }\n\n      assert(\n        method && typeof method === \"function\",\n        \"Invalid method: \" + method_name,\n      );\n\n      // Check permission\n      if (this._method_annotations.has(method)) {\n        // For services, it should not be protected\n        if (this._method_annotations.get(method).visibility === \"protected\") {\n          // Allow access from same workspace\n          if (local_workspace === remote_workspace) {\n            // Access granted\n          }\n          // Check if remote workspace is in authorized_workspaces list\n          else if (\n            this._method_annotations.get(method).authorized_workspaces &&\n            this._method_annotations\n              .get(method)\n              .authorized_workspaces.includes(remote_workspace)\n          ) {\n            // Access granted\n          }\n          // Allow manager access\n          else if (\n            remote_workspace === \"*\" &&\n            remote_client_id === this._connection.manager_id\n          ) {\n            // Access granted\n          } else {\n            throw new Error(\n              \"Permission denied for invoking protected method \" +\n                method_name +\n                \", workspace mismatch: \" +\n                local_workspace +\n                \" != \" +\n                remote_workspace,\n            );\n          }\n        }\n      } else {\n        // For sessions, the target_id should match exactly\n        let session_target_id =\n          this._object_store[data.method.split(\".\")[0]].target_id;\n        if (\n          local_workspace === remote_workspace &&\n          session_target_id &&\n          session_target_id.indexOf(\"/\") === -1\n        ) {\n          session_target_id = local_workspace + \"/\" + session_target_id;\n        }\n        if (session_target_id !== data.from) {\n          throw new Error(\n            \"Access denied for method call (\" +\n              method_name +\n              \") from \" +\n              data.from +\n              \" to target \" +\n              session_target_id,\n          );\n        }\n      }\n\n      // Make sure the parent session is still open\n      if (local_parent) {\n        // The parent session should be a session that generate the current method call\n        assert(\n          this._get_session_store(local_parent, true) !== null,\n          \"Parent session was closed: \" + local_parent,\n        );\n      }\n      let args;\n      if (data.args) {\n        args = await this._decode(\n          data.args,\n          data.session,\n          null,\n          remote_workspace,\n          null,\n        );\n      } else {\n        args = [];\n      }\n      if (\n        this._method_annotations.has(method) &&\n        this._method_annotations.get(method).require_context\n      ) {\n        // if args.length + 1 is less than the required number of arguments we will pad with undefined\n        // so we make sure the last argument is the context\n        if (args.length + 1 < method.length) {\n          for (let i = args.length; i < method.length - 1; i++) {\n            args.push(undefined);\n          }\n        }\n        args.push(data.ctx);\n        // assert(\n        //   args.length === method.length,\n        //   `Runtime Error: Invalid number of arguments for method ${method_name}, expected ${method.length} but got ${args.length}`,\n        // );\n      }\n      // console.debug(`Executing method: ${method_name} (${data.method})`);\n      if (data.promise) {\n        const result = method.apply(null, args);\n        if (result instanceof Promise) {\n          result\n            .then((result) => {\n              resolve(result);\n              clearInterval(heartbeat_task);\n            })\n            .catch((err) => {\n              reject(err);\n              clearInterval(heartbeat_task);\n            });\n        } else {\n          resolve(result);\n          clearInterval(heartbeat_task);\n        }\n      } else {\n        method.apply(null, args);\n        clearInterval(heartbeat_task);\n      }\n    } catch (err) {\n      if (reject) {\n        reject(err);\n        // console.debug(\"Error during calling method: \", err);\n      } else {\n        console.error(\"Error during calling method: \", err);\n      }\n      // make sure we clear the heartbeat timer\n      clearInterval(heartbeat_task);\n    }\n  }\n\n  encode(aObject, session_id) {\n    return this._encode(aObject, session_id);\n  }\n\n  _get_session_store(session_id, create) {\n    if (!session_id) {\n      return null;\n    }\n    let store = this._object_store;\n    const levels = session_id.split(\".\");\n    if (create) {\n      const last_index = levels.length - 1;\n      for (let level of levels.slice(0, last_index)) {\n        if (!store[level]) {\n          // Instead of returning null, create intermediate sessions as needed\n          store[level] = {};\n        }\n        store = store[level];\n      }\n      // Create the last level\n      if (!store[levels[last_index]]) {\n        store[levels[last_index]] = {};\n      }\n      return store[levels[last_index]];\n    } else {\n      for (let level of levels) {\n        if (!store[level]) {\n          return null;\n        }\n        store = store[level];\n      }\n      return store;\n    }\n  }\n\n  /**\n   * Prepares the provided set of remote method arguments for\n   * sending to the remote site, replaces all the callbacks with\n   * identifiers\n   *\n   * @param {Array} args to wrap\n   *\n   * @returns {Array} wrapped arguments\n   */\n  async _encode(aObject, session_id, local_workspace) {\n    const aType = typeof aObject;\n    if (\n      aType === \"number\" ||\n      aType === \"string\" ||\n      aType === \"boolean\" ||\n      aObject === null ||\n      aObject === undefined ||\n      aObject instanceof Uint8Array\n    ) {\n      return aObject;\n    }\n    if (aObject instanceof ArrayBuffer) {\n      return {\n        _rtype: \"memoryview\",\n        _rvalue: new Uint8Array(aObject),\n      };\n    }\n    // Reuse the remote object\n    if (aObject.__rpc_object__) {\n      const _server = aObject.__rpc_object__._rserver || this._server_base_url;\n      if (_server === this._server_base_url) {\n        return aObject.__rpc_object__;\n      } // else {\n      //   console.debug(\n      //     `Encoding remote function from a different server ${_server}, current server: ${this._server_base_url}`,\n      //   );\n      // }\n    }\n\n    let bObject;\n\n    // skip if already encoded\n    if (aObject.constructor instanceof Object && aObject._rtype) {\n      // make sure the interface functions are encoded\n      const temp = aObject._rtype;\n      delete aObject._rtype;\n      bObject = await this._encode(aObject, session_id, local_workspace);\n      bObject._rtype = temp;\n      return bObject;\n    }\n\n    if (isGenerator(aObject) || isAsyncGenerator(aObject)) {\n      // Handle generator functions and generator objects\n      assert(\n        session_id && typeof session_id === \"string\",\n        \"Session ID is required for generator encoding\",\n      );\n      const object_id = randId();\n\n      // Get the session store\n      const store = this._get_session_store(session_id, true);\n      assert(\n        store !== null,\n        `Failed to create session store ${session_id} due to invalid parent`,\n      );\n\n      // Check if it's an async generator\n      const isAsync = isAsyncGenerator(aObject);\n\n      // Define method to get next item from the generator\n      const nextItemMethod = async () => {\n        if (isAsync) {\n          const iterator = aObject;\n          const result = await iterator.next();\n          if (result.done) {\n            delete store[object_id];\n            return { _rtype: \"stop_iteration\" };\n          }\n          return result.value;\n        } else {\n          const iterator = aObject;\n          const result = iterator.next();\n          if (result.done) {\n            delete store[object_id];\n            return { _rtype: \"stop_iteration\" };\n          }\n          return result.value;\n        }\n      };\n\n      // Store the next_item method in the session\n      store[object_id] = nextItemMethod;\n\n      // Create a method that will be used to fetch the next item from the generator\n      bObject = {\n        _rtype: \"generator\",\n        _rserver: this._server_base_url,\n        _rtarget: this._client_id,\n        _rmethod: `${session_id}.${object_id}`,\n        _rpromise: \"*\",\n        _rdoc: \"Remote generator\",\n      };\n      return bObject;\n    } else if (typeof aObject === \"function\") {\n      if (this._method_annotations.has(aObject)) {\n        let annotation = this._method_annotations.get(aObject);\n        bObject = {\n          _rtype: \"method\",\n          _rserver: this._server_base_url,\n          _rtarget: this._client_id,\n          _rmethod: annotation.method_id,\n          _rpromise: \"*\",\n          _rname: aObject.name,\n        };\n      } else {\n        assert(typeof session_id === \"string\");\n        let object_id;\n        if (aObject.__name__) {\n          object_id = `${randId()}#${aObject.__name__}`;\n        } else {\n          object_id = randId();\n        }\n        bObject = {\n          _rtype: \"method\",\n          _rserver: this._server_base_url,\n          _rtarget: this._client_id,\n          _rmethod: `${session_id}.${object_id}`,\n          _rpromise: \"*\",\n          _rname: aObject.name,\n        };\n        let store = this._get_session_store(session_id, true);\n        assert(\n          store !== null,\n          `Failed to create session store ${session_id} due to invalid parent`,\n        );\n        store[object_id] = aObject;\n      }\n      bObject._rdoc = aObject.__doc__;\n      if (!bObject._rdoc) {\n        try {\n          const funcInfo = getFunctionInfo(aObject);\n          if (funcInfo && !bObject._rdoc) {\n            bObject._rdoc = `${funcInfo.doc}`;\n          }\n        } catch (e) {\n          console.error(\"Failed to extract function docstring:\", aObject);\n        }\n      }\n      bObject._rschema = aObject.__schema__;\n      return bObject;\n    }\n    const isarray = Array.isArray(aObject);\n\n    for (let tp of Object.keys(this._codecs)) {\n      const codec = this._codecs[tp];\n      if (codec.encoder && aObject instanceof codec.type) {\n        // TODO: what if multiple encoders found\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name;\n        // encode the functions in the interface object\n        if (typeof encodedObj === \"object\") {\n          const temp = encodedObj._rtype;\n          delete encodedObj._rtype;\n          encodedObj = await this._encode(\n            encodedObj,\n            session_id,\n            local_workspace,\n          );\n          encodedObj._rtype = temp;\n        }\n        bObject = encodedObj;\n        return bObject;\n      }\n    }\n\n    if (\n      /*global tf*/\n      typeof tf !== \"undefined\" &&\n      tf.Tensor &&\n      aObject instanceof tf.Tensor\n    ) {\n      const v_buffer = aObject.dataSync();\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: new Uint8Array(v_buffer.buffer),\n        _rshape: aObject.shape,\n        _rdtype: aObject.dtype,\n      };\n    } else if (\n      /*global nj*/\n      typeof nj !== \"undefined\" &&\n      nj.NdArray &&\n      aObject instanceof nj.NdArray\n    ) {\n      if (!aObject.selection || !aObject.selection.data) {\n        throw new Error(\"Invalid NumJS array: missing selection or data\");\n      }\n      const dtype = typedArrayToDtype(aObject.selection.data);\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: new Uint8Array(aObject.selection.data.buffer),\n        _rshape: aObject.shape,\n        _rdtype: dtype,\n      };\n    } else if (aObject instanceof Error) {\n      console.error(aObject);\n      bObject = {\n        _rtype: \"error\",\n        _rvalue: aObject.toString(),\n        _rtrace: aObject.stack,\n      };\n    }\n    // send objects supported by structure clone algorithm\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n    else if (\n      aObject !== Object(aObject) ||\n      aObject instanceof Boolean ||\n      aObject instanceof String ||\n      aObject instanceof Date ||\n      aObject instanceof RegExp ||\n      (typeof ImageData !== \"undefined\" && aObject instanceof ImageData) ||\n      (typeof FileList !== \"undefined\" && aObject instanceof FileList) ||\n      (typeof FileSystemDirectoryHandle !== \"undefined\" &&\n        aObject instanceof FileSystemDirectoryHandle) ||\n      (typeof FileSystemFileHandle !== \"undefined\" &&\n        aObject instanceof FileSystemFileHandle) ||\n      (typeof FileSystemHandle !== \"undefined\" &&\n        aObject instanceof FileSystemHandle) ||\n      (typeof FileSystemWritableFileStream !== \"undefined\" &&\n        aObject instanceof FileSystemWritableFileStream)\n    ) {\n      bObject = aObject;\n      // TODO: avoid object such as DynamicPlugin instance.\n    } else if (aObject instanceof Blob) {\n      let _current_pos = 0;\n      async function read(length) {\n        let blob;\n        if (length) {\n          blob = aObject.slice(_current_pos, _current_pos + length);\n        } else {\n          blob = aObject.slice(_current_pos);\n        }\n        const ret = new Uint8Array(await blob.arrayBuffer());\n        _current_pos = _current_pos + ret.byteLength;\n        return ret;\n      }\n      function seek(pos) {\n        _current_pos = pos;\n      }\n      bObject = {\n        _rtype: \"iostream\",\n        _rnative: \"js:blob\",\n        type: aObject.type,\n        name: aObject.name,\n        size: aObject.size,\n        path: aObject._path || aObject.webkitRelativePath,\n        read: await this._encode(read, session_id, local_workspace),\n        seek: await this._encode(seek, session_id, local_workspace),\n      };\n    } else if (aObject instanceof ArrayBufferView) {\n      const dtype = typedArrayToDtype(aObject);\n      bObject = {\n        _rtype: \"typedarray\",\n        _rvalue: new Uint8Array(aObject.buffer),\n        _rdtype: dtype,\n      };\n    } else if (aObject instanceof DataView) {\n      bObject = {\n        _rtype: \"memoryview\",\n        _rvalue: new Uint8Array(aObject.buffer),\n      };\n    } else if (aObject instanceof Set) {\n      bObject = {\n        _rtype: \"set\",\n        _rvalue: await this._encode(\n          Array.from(aObject),\n          session_id,\n          local_workspace,\n        ),\n      };\n    } else if (aObject instanceof Map) {\n      bObject = {\n        _rtype: \"orderedmap\",\n        _rvalue: await this._encode(\n          Array.from(aObject),\n          session_id,\n          local_workspace,\n        ),\n      };\n    } else if (\n      aObject.constructor === Object ||\n      Array.isArray(aObject) ||\n      aObject instanceof RemoteService\n    ) {\n      bObject = isarray ? [] : {};\n      const keys = Object.keys(aObject);\n      for (let k of keys) {\n        bObject[k] = await this._encode(\n          aObject[k],\n          session_id,\n          local_workspace,\n        );\n      }\n    } else {\n      throw `hypha-rpc: Unsupported data type: ${aObject}, you can register a custom codec to encode/decode the object.`;\n    }\n\n    if (!bObject) {\n      throw new Error(\"Failed to encode object\");\n    }\n    return bObject;\n  }\n\n  async decode(aObject) {\n    return await this._decode(aObject);\n  }\n\n  async _decode(\n    aObject,\n    remote_parent,\n    local_parent,\n    remote_workspace,\n    local_workspace,\n  ) {\n    if (!aObject) {\n      return aObject;\n    }\n    let bObject;\n    if (aObject._rtype) {\n      if (\n        this._codecs[aObject._rtype] &&\n        this._codecs[aObject._rtype].decoder\n      ) {\n        const temp = aObject._rtype;\n        delete aObject._rtype;\n        aObject = await this._decode(\n          aObject,\n          remote_parent,\n          local_parent,\n          remote_workspace,\n          local_workspace,\n        );\n        aObject._rtype = temp;\n\n        bObject = await Promise.resolve(\n          this._codecs[aObject._rtype].decoder(aObject),\n        );\n      } else if (aObject._rtype === \"method\") {\n        bObject = this._generate_remote_method(\n          aObject,\n          remote_parent,\n          local_parent,\n          remote_workspace,\n          local_workspace,\n        );\n      } else if (aObject._rtype === \"generator\") {\n        // Create a method to fetch next items from the remote generator\n        const gen_method = this._generate_remote_method(\n          aObject,\n          remote_parent,\n          local_parent,\n          remote_workspace,\n          local_workspace,\n        );\n\n        // Create an async generator proxy\n        async function* asyncGeneratorProxy() {\n          while (true) {\n            try {\n              const next_item = await gen_method();\n              // Check for StopIteration signal\n              if (next_item && next_item._rtype === \"stop_iteration\") {\n                break;\n              }\n              yield next_item;\n            } catch (error) {\n              console.error(\"Error in generator:\", error);\n              throw error;\n            }\n          }\n        }\n        bObject = asyncGeneratorProxy();\n      } else if (aObject._rtype === \"ndarray\") {\n        /*global nj tf*/\n        //create build array/tensor if used in the plugin\n        if (typeof nj !== \"undefined\" && nj.array) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n          bObject = nj\n            .array(new Uint8(aObject._rvalue), aObject._rdtype)\n            .reshape(aObject._rshape);\n        } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n          const arraytype = dtypeToTypedArray[aObject._rdtype];\n          bObject = tf.tensor(\n            new arraytype(aObject._rvalue),\n            aObject._rshape,\n            aObject._rdtype,\n          );\n        } else {\n          //keep it as regular if transfered to the main app\n          bObject = aObject;\n        }\n      } else if (aObject._rtype === \"error\") {\n        bObject = new Error(\n          \"RemoteError: \" + aObject._rvalue + \"\\n\" + (aObject._rtrace || \"\"),\n        );\n      } else if (aObject._rtype === \"typedarray\") {\n        const arraytype = dtypeToTypedArray[aObject._rdtype];\n        if (!arraytype)\n          throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n        const buffer = aObject._rvalue.buffer.slice(\n          aObject._rvalue.byteOffset,\n          aObject._rvalue.byteOffset + aObject._rvalue.byteLength,\n        );\n        bObject = new arraytype(buffer);\n      } else if (aObject._rtype === \"memoryview\") {\n        bObject = aObject._rvalue.buffer.slice(\n          aObject._rvalue.byteOffset,\n          aObject._rvalue.byteOffset + aObject._rvalue.byteLength,\n        ); // ArrayBuffer\n      } else if (aObject._rtype === \"iostream\") {\n        if (aObject._rnative === \"js:blob\") {\n          const read = await this._generate_remote_method(\n            aObject.read,\n            remote_parent,\n            local_parent,\n            remote_workspace,\n            local_workspace,\n          );\n          const bytes = await read();\n          bObject = new Blob([bytes], {\n            type: aObject.type,\n            name: aObject.name,\n          });\n        } else {\n          bObject = {};\n          for (let k of Object.keys(aObject)) {\n            if (!k.startsWith(\"_\")) {\n              bObject[k] = await this._decode(\n                aObject[k],\n                remote_parent,\n                local_parent,\n                remote_workspace,\n                local_workspace,\n              );\n            }\n          }\n        }\n        bObject[\"__rpc_object__\"] = aObject;\n      } else if (aObject._rtype === \"orderedmap\") {\n        bObject = new Map(\n          await this._decode(\n            aObject._rvalue,\n            remote_parent,\n            local_parent,\n            remote_workspace,\n            local_workspace,\n          ),\n        );\n      } else if (aObject._rtype === \"set\") {\n        bObject = new Set(\n          await this._decode(\n            aObject._rvalue,\n            remote_parent,\n            local_parent,\n            remote_workspace,\n            local_workspace,\n          ),\n        );\n      } else {\n        const temp = aObject._rtype;\n        delete aObject._rtype;\n        bObject = await this._decode(\n          aObject,\n          remote_parent,\n          local_parent,\n          remote_workspace,\n          local_workspace,\n        );\n        bObject._rtype = temp;\n      }\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n      const isarray = Array.isArray(aObject);\n      bObject = isarray ? [] : {};\n      for (let k of Object.keys(aObject)) {\n        if (isarray || aObject.hasOwnProperty(k)) {\n          const v = aObject[k];\n          bObject[k] = await this._decode(\n            v,\n            remote_parent,\n            local_parent,\n            remote_workspace,\n            local_workspace,\n          );\n        }\n      }\n    } else {\n      bObject = aObject;\n    }\n    if (bObject === undefined) {\n      throw new Error(\"Failed to decode object\");\n    }\n    return bObject;\n  }\n\n  _expand_promise(data) {\n    return {\n      heartbeat: {\n        _rtype: \"method\",\n        _rtarget: data.from.split(\"/\")[1],\n        _rmethod: data.session + \".heartbeat\",\n        _rdoc: `heartbeat callback for method: ${data.method}`,\n      },\n      resolve: {\n        _rtype: \"method\",\n        _rtarget: data.from.split(\"/\")[1],\n        _rmethod: data.session + \".resolve\",\n        _rdoc: `resolve callback for method: ${data.method}`,\n      },\n      reject: {\n        _rtype: \"method\",\n        _rtarget: data.from.split(\"/\")[1],\n        _rmethod: data.session + \".reject\",\n        _rdoc: `reject callback for method: ${data.method}`,\n      },\n      interval: data.t,\n    };\n  }\n}\n","export function randId() {\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\n}\n\nexport function toCamelCase(str) {\n  // Check if the string is already in camelCase\n  if (!str.includes(\"_\")) {\n    return str;\n  }\n  // Convert from snake_case to camelCase\n  return str.replace(/_./g, (match) => match[1].toUpperCase());\n}\n\nexport function toSnakeCase(str) {\n  // Convert from camelCase to snake_case\n  return str.replace(/([A-Z])/g, \"_$1\").toLowerCase();\n}\n\nexport function expandKwargs(obj) {\n  if (typeof obj !== \"object\" || obj === null) {\n    return obj; // Return the value if obj is not an object\n  }\n\n  const newObj = Array.isArray(obj) ? [] : {};\n\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      const value = obj[key];\n\n      if (typeof value === \"function\") {\n        newObj[key] = (...args) => {\n          if (args.length === 0) {\n            throw new Error(`Function \"${key}\" expects at least one argument.`);\n          }\n\n          // Check if the last argument is an object\n          const lastArg = args[args.length - 1];\n          let kwargs = {};\n\n          if (\n            typeof lastArg === \"object\" &&\n            lastArg !== null &&\n            !Array.isArray(lastArg)\n          ) {\n            // Extract kwargs from the last argument\n            kwargs = { ...lastArg, _rkwarg: true };\n            args = args.slice(0, -1); // Remove the last argument from args\n          }\n\n          // Call the original function with positional args followed by kwargs\n          return value(...args, kwargs);\n        };\n\n        // Preserve metadata like __name__ and __schema__\n        newObj[key].__name__ = key;\n        if (value.__schema__) {\n          newObj[key].__schema__ = { ...value.__schema__ };\n          newObj[key].__schema__.name = key;\n        }\n      } else {\n        newObj[key] = expandKwargs(value); // Recursively process nested objects\n      }\n    }\n  }\n\n  return newObj;\n}\n\nexport function convertCase(obj, caseType) {\n  if (typeof obj !== \"object\" || obj === null || !caseType) {\n    return obj; // Return the value if obj is not an object\n  }\n\n  const newObj = Array.isArray(obj) ? [] : {};\n\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      const value = obj[key];\n      const camelKey = toCamelCase(key);\n      const snakeKey = toSnakeCase(key);\n\n      if (caseType === \"camel\") {\n        newObj[camelKey] = convertCase(value, caseType);\n        if (typeof value === \"function\") {\n          newObj[camelKey].__name__ = camelKey;\n          if (value.__schema__) {\n            newObj[camelKey].__schema__ = { ...value.__schema__ };\n            newObj[camelKey].__schema__.name = camelKey;\n          }\n        }\n      } else if (caseType === \"snake\") {\n        newObj[snakeKey] = convertCase(value, caseType);\n        if (typeof value === \"function\") {\n          newObj[snakeKey].__name__ = snakeKey;\n          if (value.__schema__) {\n            newObj[snakeKey].__schema__ = { ...value.__schema__ };\n            newObj[snakeKey].__schema__.name = snakeKey;\n          }\n        }\n      } else {\n        // TODO handle schema for camel + snake\n        if (caseType.includes(\"camel\")) {\n          newObj[camelKey] = convertCase(value, \"camel\");\n        }\n        if (caseType.includes(\"snake\")) {\n          newObj[snakeKey] = convertCase(value, \"snake\");\n        }\n      }\n    }\n  }\n\n  return newObj;\n}\n\nexport function parseServiceUrl(url) {\n  // Ensure no trailing slash\n  url = url.replace(/\\/$/, \"\");\n\n  // Regex pattern to match the URL structure\n  const pattern = new RegExp(\n    \"^(https?:\\\\/\\\\/[^/]+)\" + // server_url (http or https followed by domain)\n      \"\\\\/([a-z0-9_-]+)\" + // workspace (lowercase letters, numbers, - or _)\n      \"\\\\/services\\\\/\" + // static part of the URL\n      \"(?:(?<clientId>[a-zA-Z0-9_-]+):)?\" + // optional client_id\n      \"(?<serviceId>[a-zA-Z0-9_-]+)\" + // service_id\n      \"(?:@(?<appId>[a-zA-Z0-9_-]+))?\", // optional app_id\n  );\n\n  const match = url.match(pattern);\n  if (!match) {\n    throw new Error(\"URL does not match the expected pattern\");\n  }\n\n  const serverUrl = match[1];\n  const workspace = match[2];\n  const clientId = match.groups?.clientId || \"*\";\n  const serviceId = match.groups?.serviceId;\n  const appId = match.groups?.appId || \"*\";\n\n  return { serverUrl, workspace, clientId, serviceId, appId };\n}\n\nexport const dtypeToTypedArray = {\n  int8: Int8Array,\n  int16: Int16Array,\n  int32: Int32Array,\n  uint8: Uint8Array,\n  uint16: Uint16Array,\n  uint32: Uint32Array,\n  float32: Float32Array,\n  float64: Float64Array,\n  array: Array,\n};\n\nexport async function loadRequirementsInWindow(requirements) {\n  function _importScript(url) {\n    //url is URL of external file, implementationCode is the code\n    //to be called from the file, location is the location to\n    //insert the <script> element\n    return new Promise((resolve, reject) => {\n      var scriptTag = document.createElement(\"script\");\n      scriptTag.src = url;\n      scriptTag.type = \"text/javascript\";\n      scriptTag.onload = resolve;\n      scriptTag.onreadystatechange = function () {\n        if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n          resolve();\n        }\n      };\n      scriptTag.onerror = reject;\n      document.head.appendChild(scriptTag);\n    });\n  }\n\n  // support importScripts outside web worker\n  async function importScripts() {\n    var args = Array.prototype.slice.call(arguments),\n      len = args.length,\n      i = 0;\n    for (; i < len; i++) {\n      await _importScript(args[i]);\n    }\n  }\n\n  if (\n    requirements &&\n    (Array.isArray(requirements) || typeof requirements === \"string\")\n  ) {\n    try {\n      var link_node;\n      requirements =\n        typeof requirements === \"string\" ? [requirements] : requirements;\n      if (Array.isArray(requirements)) {\n        for (var i = 0; i < requirements.length; i++) {\n          if (\n            requirements[i].toLowerCase().endsWith(\".css\") ||\n            requirements[i].startsWith(\"css:\")\n          ) {\n            if (requirements[i].startsWith(\"css:\")) {\n              requirements[i] = requirements[i].slice(4);\n            }\n            link_node = document.createElement(\"link\");\n            link_node.rel = \"stylesheet\";\n            link_node.href = requirements[i];\n            document.head.appendChild(link_node);\n          } else if (\n            requirements[i].toLowerCase().endsWith(\".mjs\") ||\n            requirements[i].startsWith(\"mjs:\")\n          ) {\n            // import esmodule\n            if (requirements[i].startsWith(\"mjs:\")) {\n              requirements[i] = requirements[i].slice(4);\n            }\n            await import(/* webpackIgnore: true */ requirements[i]);\n          } else if (\n            requirements[i].toLowerCase().endsWith(\".js\") ||\n            requirements[i].startsWith(\"js:\")\n          ) {\n            if (requirements[i].startsWith(\"js:\")) {\n              requirements[i] = requirements[i].slice(3);\n            }\n            await importScripts(requirements[i]);\n          } else if (requirements[i].startsWith(\"http\")) {\n            await importScripts(requirements[i]);\n          } else if (requirements[i].startsWith(\"cache:\")) {\n            //ignore cache\n          } else {\n            console.log(\"Unprocessed requirements url: \" + requirements[i]);\n          }\n        }\n      } else {\n        throw \"unsupported requirements definition\";\n      }\n    } catch (e) {\n      throw \"failed to import required scripts: \" + requirements.toString();\n    }\n  }\n}\n\nexport async function loadRequirementsInWebworker(requirements) {\n  if (\n    requirements &&\n    (Array.isArray(requirements) || typeof requirements === \"string\")\n  ) {\n    try {\n      if (!Array.isArray(requirements)) {\n        requirements = [requirements];\n      }\n      for (var i = 0; i < requirements.length; i++) {\n        if (\n          requirements[i].toLowerCase().endsWith(\".css\") ||\n          requirements[i].startsWith(\"css:\")\n        ) {\n          throw \"unable to import css in a webworker\";\n        } else if (\n          requirements[i].toLowerCase().endsWith(\".js\") ||\n          requirements[i].startsWith(\"js:\")\n        ) {\n          if (requirements[i].startsWith(\"js:\")) {\n            requirements[i] = requirements[i].slice(3);\n          }\n          importScripts(requirements[i]);\n        } else if (requirements[i].startsWith(\"http\")) {\n          importScripts(requirements[i]);\n        } else if (requirements[i].startsWith(\"cache:\")) {\n          //ignore cache\n        } else {\n          console.log(\"Unprocessed requirements url: \" + requirements[i]);\n        }\n      }\n    } catch (e) {\n      throw \"failed to import required scripts: \" + requirements.toString();\n    }\n  }\n}\n\nexport function loadRequirements(requirements) {\n  if (\n    typeof WorkerGlobalScope !== \"undefined\" &&\n    self instanceof WorkerGlobalScope\n  ) {\n    return loadRequirementsInWebworker(requirements);\n  } else {\n    return loadRequirementsInWindow(requirements);\n  }\n}\n\nexport function normalizeConfig(config) {\n  config.version = config.version || \"0.1.0\";\n  config.description =\n    config.description || `[TODO: add description for ${config.name} ]`;\n  config.type = config.type || \"rpc-window\";\n  config.id = config.id || randId();\n  config.target_origin = config.target_origin || \"*\";\n  config.allow_execution = config.allow_execution || false;\n  // remove functions\n  config = Object.keys(config).reduce((p, c) => {\n    if (typeof config[c] !== \"function\") p[c] = config[c];\n    return p;\n  }, {});\n  return config;\n}\nexport const typedArrayToDtypeMapping = {\n  Int8Array: \"int8\",\n  Int16Array: \"int16\",\n  Int32Array: \"int32\",\n  Uint8Array: \"uint8\",\n  Uint16Array: \"uint16\",\n  Uint32Array: \"uint32\",\n  Float32Array: \"float32\",\n  Float64Array: \"float64\",\n  Array: \"array\",\n};\n\nconst typedArrayToDtypeKeys = [];\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n  typedArrayToDtypeKeys.push(eval(arrType));\n}\n\nexport function typedArrayToDtype(obj) {\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n  if (!dtype) {\n    const pt = Object.getPrototypeOf(obj);\n    for (const arrType of typedArrayToDtypeKeys) {\n      if (pt instanceof arrType) {\n        dtype = typedArrayToDtypeMapping[arrType.name];\n        break;\n      }\n    }\n  }\n  return dtype;\n}\n\nfunction cacheUrlInServiceWorker(url) {\n  return new Promise(function (resolve, reject) {\n    const message = {\n      command: \"add\",\n      url: url,\n    };\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n      reject(\"Service worker is not supported.\");\n      return;\n    }\n    const messageChannel = new MessageChannel();\n    messageChannel.port1.onmessage = function (event) {\n      if (event.data && event.data.error) {\n        reject(event.data.error);\n      } else {\n        resolve(event.data && event.data.result);\n      }\n    };\n\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n      navigator.serviceWorker.controller.postMessage(message, [\n        messageChannel.port2,\n      ]);\n    } else {\n      reject(\"Service worker controller is not available\");\n    }\n  });\n}\n\nexport async function cacheRequirements(requirements) {\n  requirements = requirements || [];\n  if (!Array.isArray(requirements)) {\n    requirements = [requirements];\n  }\n  for (let req of requirements) {\n    //remove prefix\n    if (req.startsWith(\"js:\")) req = req.slice(3);\n    if (req.startsWith(\"css:\")) req = req.slice(4);\n    if (req.startsWith(\"cache:\")) req = req.slice(6);\n    if (!req.startsWith(\"http\")) continue;\n\n    await cacheUrlInServiceWorker(req).catch((e) => {\n      console.error(e);\n    });\n  }\n}\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\n\n//#Source https://bit.ly/2neWfJ2\nexport function urlJoin(...args) {\n  return args\n    .join(\"/\")\n    .replace(/[\\/]+/g, \"/\")\n    .replace(/^(.+):\\//, \"$1://\")\n    .replace(/^file:/, \"file:/\")\n    .replace(/\\/(\\?|&|#[^!])/g, \"$1\")\n    .replace(/\\?/g, \"&\")\n    .replace(\"&\", \"?\");\n}\n\nexport function waitFor(prom, time, error) {\n  let timer;\n  return Promise.race([\n    prom,\n    new Promise(\n      (_r, rej) =>\n        (timer = setTimeout(() => {\n          rej(error || \"Timeout Error\");\n        }, time * 1000)),\n    ),\n  ]).finally(() => clearTimeout(timer));\n}\n\nexport class MessageEmitter {\n  constructor(debug) {\n    this._event_handlers = {};\n    this._once_handlers = {};\n    this._debug = debug;\n  }\n  emit() {\n    throw new Error(\"emit is not implemented\");\n  }\n  on(event, handler) {\n    if (!this._event_handlers[event]) {\n      this._event_handlers[event] = [];\n    }\n    this._event_handlers[event].push(handler);\n  }\n  once(event, handler) {\n    handler.___event_run_once = true;\n    this.on(event, handler);\n  }\n  off(event, handler) {\n    if (!event && !handler) {\n      // remove all events handlers\n      this._event_handlers = {};\n    } else if (event && !handler) {\n      // remove all hanlders for the event\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\n    } else {\n      // remove a specific handler\n      if (this._event_handlers[event]) {\n        const idx = this._event_handlers[event].indexOf(handler);\n        if (idx >= 0) {\n          this._event_handlers[event].splice(idx, 1);\n        }\n      }\n    }\n  }\n  _fire(event, data) {\n    if (this._event_handlers[event]) {\n      var i = this._event_handlers[event].length;\n      while (i--) {\n        const handler = this._event_handlers[event][i];\n        try {\n          handler(data);\n        } catch (e) {\n          console.error(e);\n        } finally {\n          if (handler.___event_run_once) {\n            this._event_handlers[event].splice(i, 1);\n          }\n        }\n      }\n    } else {\n      if (this._debug) {\n        console.warn(\"unhandled event\", event, data);\n      }\n    }\n  }\n\n  waitFor(event, timeout) {\n    return new Promise((resolve, reject) => {\n      const handler = (data) => {\n        clearTimeout(timer);\n        resolve(data);\n      };\n      this.once(event, handler);\n      const timer = setTimeout(() => {\n        this.off(event, handler);\n        reject(new Error(\"Timeout\"));\n      }, timeout * 1000);\n    });\n  }\n}\n\nexport class Semaphore {\n  constructor(max) {\n    this.max = max;\n    this.queue = [];\n    this.current = 0;\n  }\n  async run(task) {\n    if (this.current >= this.max) {\n      // Wait until a slot is free\n      await new Promise((resolve) => this.queue.push(resolve));\n    }\n    this.current++;\n    try {\n      return await task();\n    } finally {\n      this.current--;\n      if (this.queue.length > 0) {\n        // release one waiter\n        this.queue.shift()();\n      }\n    }\n  }\n}\n\n/**\n * Check if the object is a generator\n * @param {Object} obj - Object to check\n * @returns {boolean} - True if the object is a generator\n */\nexport function isGenerator(obj) {\n  if (!obj) return false;\n\n  return (\n    typeof obj === \"object\" &&\n    typeof obj.next === \"function\" &&\n    typeof obj.throw === \"function\" &&\n    typeof obj.return === \"function\"\n  );\n}\n\n/**\n * Check if an object is an async generator object\n * @param {any} obj - Object to check\n * @returns {boolean} True if object is an async generator object\n */\nexport function isAsyncGenerator(obj) {\n  if (!obj) return false;\n  // Check if it's an async generator object\n  return (\n    typeof obj === \"object\" &&\n    typeof obj.next === \"function\" &&\n    typeof obj.throw === \"function\" &&\n    typeof obj.return === \"function\" &&\n    Symbol.asyncIterator in Object(obj) &&\n    obj[Symbol.toStringTag] === \"AsyncGenerator\"\n  );\n}\n","import { assert } from \"./index.js\";\n\n// Schema builder utility inspired by Zod for consistent API with Python\nexport const z = {\n  object: (properties) => ({\n    type: \"object\",\n    properties,\n    required: Object.keys(properties).filter(\n      (key) => !properties[key]._optional,\n    ),\n  }),\n\n  string: () => ({ type: \"string\", _optional: false }),\n  number: () => ({ type: \"number\", _optional: false }),\n  integer: () => ({ type: \"integer\", _optional: false }),\n  boolean: () => ({ type: \"boolean\", _optional: false }),\n  array: (items) => ({ type: \"array\", items, _optional: false }),\n\n  // Make field optional\n  optional: (schema) => ({ ...schema, _optional: true }),\n};\n\n// Add description method to schema types\n[\"string\", \"number\", \"integer\", \"boolean\", \"array\"].forEach((type) => {\n  z[type] = () => {\n    const schema = {\n      type: type === \"integer\" ? \"integer\" : type,\n      _optional: false,\n    };\n    schema.describe = (description) => ({ ...schema, description });\n    return schema;\n  };\n});\n\nexport function schemaFunction(\n  func,\n  { schema_type = \"auto\", name = null, description = null, parameters = null },\n) {\n  if (!func || typeof func !== \"function\") {\n    throw Error(\"func should be a function\");\n  }\n  assert(schema_type === \"auto\", \"schema_type should be auto\");\n\n  // If no name provided, try to get it from function\n  const funcName = name || func.name;\n  assert(funcName, \"name should not be null\");\n\n  // If parameters is a z.object result, convert it properly\n  let processedParameters = parameters;\n  if (\n    parameters &&\n    typeof parameters === \"object\" &&\n    parameters.type === \"object\"\n  ) {\n    processedParameters = {\n      type: \"object\",\n      properties: parameters.properties || {},\n      required: parameters.required || [],\n    };\n\n    // Clean up internal _optional flags\n    for (const [key, schema] of Object.entries(\n      processedParameters.properties,\n    )) {\n      if (schema._optional !== undefined) {\n        delete schema._optional;\n      }\n    }\n  }\n\n  assert(\n    processedParameters && processedParameters.type === \"object\",\n    \"parameters should be an object schema\",\n  );\n\n  func.__schema__ = {\n    name: funcName,\n    description: description || \"\",\n    parameters: processedParameters,\n  };\n  return func;\n}\n","import { RPC } from \"./rpc.js\";\nimport { assert, randId } from \"./utils/index.js\";\nimport { schemaFunction } from \"./utils/schema.js\";\n\nclass WebRTCConnection {\n  constructor(channel) {\n    this._data_channel = channel;\n    this._handle_message = null;\n    this._reconnection_token = null;\n    this._handle_disconnected = null;\n    this._handle_connected = () => {};\n    this.manager_id = null;\n    this._last_message = null;\n    this._data_channel.onopen = async () => {\n      if (this._last_message) {\n        console.info(\"Resending last message after connection established\");\n        this._data_channel.send(this._last_message);\n        this._last_message = null;\n      }\n      this._handle_connected &&\n        this._handle_connected({ channel: this._data_channel });\n    };\n    this._data_channel.onmessage = async (event) => {\n      let data = event.data;\n      if (data instanceof Blob) {\n        data = await data.arrayBuffer();\n      }\n      this._handle_message(data);\n    };\n    const self = this;\n    this._data_channel.onclose = function () {\n      if (this._handle_disconnected) this._handle_disconnected(\"closed\");\n      console.log(\"websocket closed\");\n      self._data_channel = null;\n    };\n  }\n\n  on_disconnected(handler) {\n    this._handle_disconnected = handler;\n  }\n\n  on_connected(handler) {\n    this._handle_connected = handler;\n  }\n\n  on_message(handler) {\n    assert(handler, \"handler is required\");\n    this._handle_message = handler;\n  }\n\n  async emit_message(data) {\n    assert(this._handle_message, \"No handler for message\");\n    try {\n      this._last_message = data;\n      this._data_channel.send(data);\n      this._last_message = null;\n    } catch (exp) {\n      console.error(`Failed to send data, error: ${exp}`);\n      throw exp;\n    }\n  }\n\n  async disconnect(reason) {\n    this._last_message = null;\n    this._data_channel = null;\n    console.info(`data channel connection disconnected (${reason})`);\n  }\n}\n\nasync function _setupRPC(config) {\n  assert(config.channel, \"No channel provided\");\n  assert(config.workspace, \"No workspace provided\");\n  const channel = config.channel;\n  const clientId = config.client_id || randId();\n  const connection = new WebRTCConnection(channel);\n  config.context = config.context || {};\n  config.context.connection_type = \"webrtc\";\n  config.context.ws = config.workspace;\n  const rpc = new RPC(connection, {\n    client_id: clientId,\n    default_context: config.context,\n    name: config.name,\n    method_timeout: config.method_timeout || 10.0,\n    workspace: config.workspace,\n    app_id: config.app_id,\n    long_message_chunk_size: config.long_message_chunk_size,\n  });\n  return rpc;\n}\n\nasync function _createOffer(params, server, config, onInit, context) {\n  config = config || {};\n  let offer = new RTCSessionDescription({\n    sdp: params.sdp,\n    type: params.type,\n  });\n\n  let pc = new RTCPeerConnection({\n    iceServers: config.ice_servers || [\n      { urls: [\"stun:stun.l.google.com:19302\"] },\n    ],\n    sdpSemantics: \"unified-plan\",\n  });\n\n  if (server) {\n    pc.addEventListener(\"datachannel\", async (event) => {\n      const channel = event.channel;\n      let ctx = null;\n      if (context && context.user) ctx = { user: context.user, ws: context.ws };\n      const rpc = await _setupRPC({\n        channel: channel,\n        client_id: channel.label,\n        workspace: server.config.workspace,\n        context: ctx,\n      });\n      // Map all the local services to the webrtc client\n      rpc._services = server.rpc._services;\n    });\n  }\n\n  if (onInit) {\n    await onInit(pc);\n  }\n\n  await pc.setRemoteDescription(offer);\n\n  let answer = await pc.createAnswer();\n  await pc.setLocalDescription(answer);\n\n  // Wait for ICE candidates to be gathered (important for Firefox)\n  await new Promise((resolveIce) => {\n    if (pc.iceGatheringState === \"complete\") {\n      resolveIce();\n    } else {\n      pc.addEventListener(\"icegatheringstatechange\", () => {\n        if (pc.iceGatheringState === \"complete\") {\n          resolveIce();\n        }\n      });\n      // Don't wait forever for ICE gathering\n      setTimeout(resolveIce, 5000);\n    }\n  });\n\n  return {\n    sdp: pc.localDescription.sdp,\n    type: pc.localDescription.type,\n    workspace: server.config.workspace,\n  };\n}\n\nasync function getRTCService(server, service_id, config) {\n  config = config || {};\n  config.peer_id = config.peer_id || randId();\n\n  const pc = new RTCPeerConnection({\n    iceServers: config.ice_servers || [\n      { urls: [\"stun:stun.l.google.com:19302\"] },\n    ],\n    sdpSemantics: \"unified-plan\",\n  });\n\n  return new Promise(async (resolve, reject) => {\n    let resolved = false;\n    const timeout = setTimeout(() => {\n      if (!resolved) {\n        resolved = true;\n        pc.close();\n        reject(new Error(\"WebRTC Connection timeout\"));\n      }\n    }, 30000); // Increase timeout to 30 seconds\n\n    try {\n      pc.addEventListener(\n        \"connectionstatechange\",\n        () => {\n          console.log(\"WebRTC Connection state: \", pc.connectionState);\n          if (pc.connectionState === \"failed\") {\n            if (!resolved) {\n              resolved = true;\n              clearTimeout(timeout);\n              pc.close();\n              reject(new Error(\"WebRTC Connection failed\"));\n            }\n          } else if (pc.connectionState === \"closed\") {\n            if (!resolved) {\n              resolved = true;\n              clearTimeout(timeout);\n              reject(new Error(\"WebRTC Connection closed\"));\n            }\n          } else if (pc.connectionState === \"connected\") {\n            console.log(\"WebRTC Connection established successfully\");\n          }\n        },\n        false,\n      );\n\n      // Add ICE connection state change handler for better debugging\n      pc.addEventListener(\"iceconnectionstatechange\", () => {\n        console.log(\"ICE Connection state: \", pc.iceConnectionState);\n        if (pc.iceConnectionState === \"failed\") {\n          if (!resolved) {\n            resolved = true;\n            clearTimeout(timeout);\n            pc.close();\n            reject(new Error(\"ICE Connection failed\"));\n          }\n        }\n      });\n\n      if (config.on_init) {\n        await config.on_init(pc);\n        delete config.on_init;\n      }\n\n      let channel = pc.createDataChannel(config.peer_id, { ordered: true });\n      channel.binaryType = \"arraybuffer\";\n\n      // Wait for ICE gathering to complete before creating offer\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n\n      // Wait for ICE candidates to be gathered (important for Firefox)\n      await new Promise((resolveIce) => {\n        if (pc.iceGatheringState === \"complete\") {\n          resolveIce();\n        } else {\n          pc.addEventListener(\"icegatheringstatechange\", () => {\n            if (pc.iceGatheringState === \"complete\") {\n              resolveIce();\n            }\n          });\n          // Don't wait forever for ICE gathering\n          setTimeout(resolveIce, 5000);\n        }\n      });\n\n      const svc = await server.getService(service_id);\n      const answer = await svc.offer({\n        sdp: pc.localDescription.sdp,\n        type: pc.localDescription.type,\n      });\n\n      channel.onopen = () => {\n        config.channel = channel;\n        config.workspace = answer.workspace;\n        // Increase timeout for Firefox compatibility\n        setTimeout(async () => {\n          if (!resolved) {\n            try {\n              const rpc = await _setupRPC(config);\n              pc.rpc = rpc;\n              async function get_service(name, ...args) {\n                assert(\n                  !name.includes(\":\"),\n                  \"WebRTC service name should not contain ':'\",\n                );\n                assert(\n                  !name.includes(\"/\"),\n                  \"WebRTC service name should not contain '/'\",\n                );\n                return await rpc.get_remote_service(\n                  config.workspace + \"/\" + config.peer_id + \":\" + name,\n                  ...args,\n                );\n              }\n              async function disconnect() {\n                await rpc.disconnect();\n                pc.close();\n              }\n              pc.getService = schemaFunction(get_service, {\n                name: \"getService\",\n                description: \"Get a remote service via webrtc\",\n                parameters: {\n                  type: \"object\",\n                  properties: {\n                    service_id: {\n                      type: \"string\",\n                      description:\n                        \"Service ID. This should be a service id in the format: 'workspace/service_id', 'workspace/client_id:service_id' or 'workspace/client_id:service_id@app_id'\",\n                    },\n                    config: {\n                      type: \"object\",\n                      description: \"Options for the service\",\n                    },\n                  },\n                  required: [\"id\"],\n                },\n              });\n              pc.disconnect = schemaFunction(disconnect, {\n                name: \"disconnect\",\n                description: \"Disconnect from the webrtc connection via webrtc\",\n                parameters: { type: \"object\", properties: {} },\n              });\n              pc.registerCodec = schemaFunction(rpc.register_codec, {\n                name: \"registerCodec\",\n                description: \"Register a codec for the webrtc connection\",\n                parameters: {\n                  type: \"object\",\n                  properties: {\n                    codec: {\n                      type: \"object\",\n                      description: \"Codec to register\",\n                      properties: {\n                        name: { type: \"string\" },\n                        type: {},\n                        encoder: { type: \"function\" },\n                        decoder: { type: \"function\" },\n                      },\n                    },\n                  },\n                },\n              });\n              resolved = true;\n              clearTimeout(timeout);\n              resolve(pc);\n            } catch (e) {\n              if (!resolved) {\n                resolved = true;\n                clearTimeout(timeout);\n                reject(e);\n              }\n            }\n          }\n        }, 1000); // Increase timeout to 1 second for Firefox\n      };\n\n      channel.onclose = () => {\n        if (!resolved) {\n          resolved = true;\n          clearTimeout(timeout);\n          reject(new Error(\"Data channel closed\"));\n        }\n      };\n\n      channel.onerror = (error) => {\n        if (!resolved) {\n          resolved = true;\n          clearTimeout(timeout);\n          reject(new Error(`Data channel error: ${error}`));\n        }\n      };\n\n      await pc.setRemoteDescription(\n        new RTCSessionDescription({\n          sdp: answer.sdp,\n          type: answer.type,\n        }),\n      );\n    } catch (e) {\n      if (!resolved) {\n        resolved = true;\n        clearTimeout(timeout);\n        reject(e);\n      }\n    }\n  });\n}\n\nasync function registerRTCService(server, service_id, config) {\n  config = config || {\n    visibility: \"protected\",\n    require_context: true,\n  };\n  const onInit = config.on_init;\n  delete config.on_init;\n  return await server.registerService({\n    id: service_id,\n    config,\n    offer: (params, context) =>\n      _createOffer(params, server, config, onInit, context),\n  });\n}\n\nexport { getRTCService, registerRTCService };\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar DecodeError = /** @class */ (function (_super) {\n    __extends(DecodeError, _super);\n    function DecodeError(message) {\n        var _this = _super.call(this, message) || this;\n        // fix the prototype chain in a cross-platform way\n        var proto = Object.create(DecodeError.prototype);\n        Object.setPrototypeOf(_this, proto);\n        Object.defineProperty(_this, \"name\", {\n            configurable: true,\n            enumerable: false,\n            value: DecodeError.name,\n        });\n        return _this;\n    }\n    return DecodeError;\n}(Error));\nexport { DecodeError };\n//# sourceMappingURL=DecodeError.mjs.map","/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nvar ExtData = /** @class */ (function () {\n    function ExtData(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n    return ExtData;\n}());\nexport { ExtData };\n//# sourceMappingURL=ExtData.mjs.map","// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\nimport { DecodeError } from \"./DecodeError.mjs\";\nimport { getInt64, setInt64 } from \"./utils/int.mjs\";\nexport var EXT_TIMESTAMP = -1;\nvar TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nvar TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\nexport function encodeTimeSpecToTimestamp(_a) {\n    var sec = _a.sec, nsec = _a.nsec;\n    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n        // Here sec >= 0 && nsec >= 0\n        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n            // timestamp 32 = { sec32 (unsigned) }\n            var rv = new Uint8Array(4);\n            var view = new DataView(rv.buffer);\n            view.setUint32(0, sec);\n            return rv;\n        }\n        else {\n            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n            var secHigh = sec / 0x100000000;\n            var secLow = sec & 0xffffffff;\n            var rv = new Uint8Array(8);\n            var view = new DataView(rv.buffer);\n            // nsec30 | secHigh2\n            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n            // secLow32\n            view.setUint32(4, secLow);\n            return rv;\n        }\n    }\n    else {\n        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n        var rv = new Uint8Array(12);\n        var view = new DataView(rv.buffer);\n        view.setUint32(0, nsec);\n        setInt64(view, 4, sec);\n        return rv;\n    }\n}\nexport function encodeDateToTimeSpec(date) {\n    var msec = date.getTime();\n    var sec = Math.floor(msec / 1e3);\n    var nsec = (msec - sec * 1e3) * 1e6;\n    // Normalizes { sec, nsec } to ensure nsec is unsigned.\n    var nsecInSec = Math.floor(nsec / 1e9);\n    return {\n        sec: sec + nsecInSec,\n        nsec: nsec - nsecInSec * 1e9,\n    };\n}\nexport function encodeTimestampExtension(object) {\n    if (object instanceof Date) {\n        var timeSpec = encodeDateToTimeSpec(object);\n        return encodeTimeSpecToTimestamp(timeSpec);\n    }\n    else {\n        return null;\n    }\n}\nexport function decodeTimestampToTimeSpec(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // data may be 32, 64, or 96 bits\n    switch (data.byteLength) {\n        case 4: {\n            // timestamp 32 = { sec32 }\n            var sec = view.getUint32(0);\n            var nsec = 0;\n            return { sec: sec, nsec: nsec };\n        }\n        case 8: {\n            // timestamp 64 = { nsec30, sec34 }\n            var nsec30AndSecHigh2 = view.getUint32(0);\n            var secLow32 = view.getUint32(4);\n            var sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n            var nsec = nsec30AndSecHigh2 >>> 2;\n            return { sec: sec, nsec: nsec };\n        }\n        case 12: {\n            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n            var sec = getInt64(view, 4);\n            var nsec = view.getUint32(0);\n            return { sec: sec, nsec: nsec };\n        }\n        default:\n            throw new DecodeError(\"Unrecognized data size for timestamp (expected 4, 8, or 12): \".concat(data.length));\n    }\n}\nexport function decodeTimestampExtension(data) {\n    var timeSpec = decodeTimestampToTimeSpec(data);\n    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\nexport var timestampExtension = {\n    type: EXT_TIMESTAMP,\n    encode: encodeTimestampExtension,\n    decode: decodeTimestampExtension,\n};\n//# sourceMappingURL=timestamp.mjs.map","// ExtensionCodec to handle MessagePack extensions\nimport { ExtData } from \"./ExtData.mjs\";\nimport { timestampExtension } from \"./timestamp.mjs\";\nvar ExtensionCodec = /** @class */ (function () {\n    function ExtensionCodec() {\n        // built-in extensions\n        this.builtInEncoders = [];\n        this.builtInDecoders = [];\n        // custom extensions\n        this.encoders = [];\n        this.decoders = [];\n        this.register(timestampExtension);\n    }\n    ExtensionCodec.prototype.register = function (_a) {\n        var type = _a.type, encode = _a.encode, decode = _a.decode;\n        if (type >= 0) {\n            // custom extensions\n            this.encoders[type] = encode;\n            this.decoders[type] = decode;\n        }\n        else {\n            // built-in extensions\n            var index = 1 + type;\n            this.builtInEncoders[index] = encode;\n            this.builtInDecoders[index] = decode;\n        }\n    };\n    ExtensionCodec.prototype.tryToEncode = function (object, context) {\n        // built-in extensions\n        for (var i = 0; i < this.builtInEncoders.length; i++) {\n            var encodeExt = this.builtInEncoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = -1 - i;\n                    return new ExtData(type, data);\n                }\n            }\n        }\n        // custom extensions\n        for (var i = 0; i < this.encoders.length; i++) {\n            var encodeExt = this.encoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = i;\n                    return new ExtData(type, data);\n                }\n            }\n        }\n        if (object instanceof ExtData) {\n            // to keep ExtData as is\n            return object;\n        }\n        return null;\n    };\n    ExtensionCodec.prototype.decode = function (data, type, context) {\n        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n        if (decodeExt) {\n            return decodeExt(data, type, context);\n        }\n        else {\n            // decode() does not fail, returns ExtData instead.\n            return new ExtData(type, data);\n        }\n    };\n    ExtensionCodec.defaultCodec = new ExtensionCodec();\n    return ExtensionCodec;\n}());\nexport { ExtensionCodec };\n//# sourceMappingURL=ExtensionCodec.mjs.map","export function prettyByte(byte) {\n    return \"\".concat(byte < 0 ? \"-\" : \"\", \"0x\").concat(Math.abs(byte).toString(16).padStart(2, \"0\"));\n}\n//# sourceMappingURL=prettyByte.mjs.map","import { utf8DecodeJs } from \"./utils/utf8.mjs\";\nvar DEFAULT_MAX_KEY_LENGTH = 16;\nvar DEFAULT_MAX_LENGTH_PER_KEY = 16;\nvar CachedKeyDecoder = /** @class */ (function () {\n    function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {\n        if (maxKeyLength === void 0) { maxKeyLength = DEFAULT_MAX_KEY_LENGTH; }\n        if (maxLengthPerKey === void 0) { maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY; }\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        this.hit = 0;\n        this.miss = 0;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for (var i = 0; i < this.maxKeyLength; i++) {\n            this.caches.push([]);\n        }\n    }\n    CachedKeyDecoder.prototype.canBeCached = function (byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    };\n    CachedKeyDecoder.prototype.find = function (bytes, inputOffset, byteLength) {\n        var records = this.caches[byteLength - 1];\n        FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n            var record = records_1[_i];\n            var recordBytes = record.bytes;\n            for (var j = 0; j < byteLength; j++) {\n                if (recordBytes[j] !== bytes[inputOffset + j]) {\n                    continue FIND_CHUNK;\n                }\n            }\n            return record.str;\n        }\n        return null;\n    };\n    CachedKeyDecoder.prototype.store = function (bytes, value) {\n        var records = this.caches[bytes.length - 1];\n        var record = { bytes: bytes, str: value };\n        if (records.length >= this.maxLengthPerKey) {\n            // `records` are full!\n            // Set `record` to an arbitrary position.\n            records[(Math.random() * records.length) | 0] = record;\n        }\n        else {\n            records.push(record);\n        }\n    };\n    CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {\n        var cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        var str = utf8DecodeJs(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    };\n    return CachedKeyDecoder;\n}());\nexport { CachedKeyDecoder };\n//# sourceMappingURL=CachedKeyDecoder.mjs.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nimport { prettyByte } from \"./utils/prettyByte.mjs\";\nimport { ExtensionCodec } from \"./ExtensionCodec.mjs\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int.mjs\";\nimport { utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD } from \"./utils/utf8.mjs\";\nimport { createDataView, ensureUint8Array } from \"./utils/typedArrays.mjs\";\nimport { CachedKeyDecoder } from \"./CachedKeyDecoder.mjs\";\nimport { DecodeError } from \"./DecodeError.mjs\";\nvar isValidMapKeyType = function (key) {\n    var keyType = typeof key;\n    return keyType === \"string\" || keyType === \"number\";\n};\nvar HEAD_BYTE_REQUIRED = -1;\nvar EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nvar EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n// IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\nexport var DataViewIndexOutOfBoundsError = (function () {\n    try {\n        // IE11: The spec says it should throw RangeError,\n        // IE11: but in IE11 it throws TypeError.\n        EMPTY_VIEW.getInt8(0);\n    }\n    catch (e) {\n        return e.constructor;\n    }\n    throw new Error(\"never reached\");\n})();\nvar MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\nvar sharedCachedKeyDecoder = new CachedKeyDecoder();\nvar Decoder = /** @class */ (function () {\n    function Decoder(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n        if (extensionCodec === void 0) { extensionCodec = ExtensionCodec.defaultCodec; }\n        if (context === void 0) { context = undefined; }\n        if (maxStrLength === void 0) { maxStrLength = UINT32_MAX; }\n        if (maxBinLength === void 0) { maxBinLength = UINT32_MAX; }\n        if (maxArrayLength === void 0) { maxArrayLength = UINT32_MAX; }\n        if (maxMapLength === void 0) { maxMapLength = UINT32_MAX; }\n        if (maxExtLength === void 0) { maxExtLength = UINT32_MAX; }\n        if (keyDecoder === void 0) { keyDecoder = sharedCachedKeyDecoder; }\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxStrLength = maxStrLength;\n        this.maxBinLength = maxBinLength;\n        this.maxArrayLength = maxArrayLength;\n        this.maxMapLength = maxMapLength;\n        this.maxExtLength = maxExtLength;\n        this.keyDecoder = keyDecoder;\n        this.totalPos = 0;\n        this.pos = 0;\n        this.view = EMPTY_VIEW;\n        this.bytes = EMPTY_BYTES;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack = [];\n    }\n    Decoder.prototype.reinitializeState = function () {\n        this.totalPos = 0;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack.length = 0;\n        // view, bytes, and pos will be re-initialized in setBuffer()\n    };\n    Decoder.prototype.setBuffer = function (buffer) {\n        this.bytes = ensureUint8Array(buffer);\n        this.view = createDataView(this.bytes);\n        this.pos = 0;\n    };\n    Decoder.prototype.appendBuffer = function (buffer) {\n        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n            this.setBuffer(buffer);\n        }\n        else {\n            var remainingData = this.bytes.subarray(this.pos);\n            var newData = ensureUint8Array(buffer);\n            // concat remainingData + newData\n            var newBuffer = new Uint8Array(remainingData.length + newData.length);\n            newBuffer.set(remainingData);\n            newBuffer.set(newData, remainingData.length);\n            this.setBuffer(newBuffer);\n        }\n    };\n    Decoder.prototype.hasRemaining = function (size) {\n        return this.view.byteLength - this.pos >= size;\n    };\n    Decoder.prototype.createExtraByteError = function (posToShow) {\n        var _a = this, view = _a.view, pos = _a.pos;\n        return new RangeError(\"Extra \".concat(view.byteLength - pos, \" of \").concat(view.byteLength, \" byte(s) found at buffer[\").concat(posToShow, \"]\"));\n    };\n    /**\n     * @throws {@link DecodeError}\n     * @throws {@link RangeError}\n     */\n    Decoder.prototype.decode = function (buffer) {\n        this.reinitializeState();\n        this.setBuffer(buffer);\n        var object = this.doDecodeSync();\n        if (this.hasRemaining(1)) {\n            throw this.createExtraByteError(this.pos);\n        }\n        return object;\n    };\n    Decoder.prototype.decodeMulti = function (buffer) {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    this.reinitializeState();\n                    this.setBuffer(buffer);\n                    _a.label = 1;\n                case 1:\n                    if (!this.hasRemaining(1)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, this.doDecodeSync()];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/];\n            }\n        });\n    };\n    Decoder.prototype.decodeAsync = function (stream) {\n        var stream_1, stream_1_1;\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        decoded = false;\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([1, 6, 7, 12]);\n                        stream_1 = __asyncValues(stream);\n                        _c.label = 2;\n                    case 2: return [4 /*yield*/, stream_1.next()];\n                    case 3:\n                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done)) return [3 /*break*/, 5];\n                        buffer = stream_1_1.value;\n                        if (decoded) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        try {\n                            object = this.doDecodeSync();\n                            decoded = true;\n                        }\n                        catch (e) {\n                            if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                                throw e; // rethrow\n                            }\n                            // fallthrough\n                        }\n                        this.totalPos += this.pos;\n                        _c.label = 4;\n                    case 4: return [3 /*break*/, 2];\n                    case 5: return [3 /*break*/, 12];\n                    case 6:\n                        e_1_1 = _c.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 12];\n                    case 7:\n                        _c.trys.push([7, , 10, 11]);\n                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return))) return [3 /*break*/, 9];\n                        return [4 /*yield*/, _a.call(stream_1)];\n                    case 8:\n                        _c.sent();\n                        _c.label = 9;\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 11: return [7 /*endfinally*/];\n                    case 12:\n                        if (decoded) {\n                            if (this.hasRemaining(1)) {\n                                throw this.createExtraByteError(this.totalPos);\n                            }\n                            return [2 /*return*/, object];\n                        }\n                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \".concat(prettyByte(headByte), \" at \").concat(totalPos, \" (\").concat(pos, \" in the current buffer)\"));\n                }\n            });\n        });\n    };\n    Decoder.prototype.decodeArrayStream = function (stream) {\n        return this.decodeMultiAsync(stream, true);\n    };\n    Decoder.prototype.decodeStream = function (stream) {\n        return this.decodeMultiAsync(stream, false);\n    };\n    Decoder.prototype.decodeMultiAsync = function (stream, isArray) {\n        return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n            var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n            var e_3, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 13, 14, 19]);\n                        stream_2 = __asyncValues(stream);\n                        _b.label = 2;\n                    case 2: return [4 /*yield*/, __await(stream_2.next())];\n                    case 3:\n                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done)) return [3 /*break*/, 12];\n                        buffer = stream_2_1.value;\n                        if (isArray && arrayItemsLeft === 0) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                            arrayItemsLeft = this.readArraySize();\n                            isArrayHeaderRequired = false;\n                            this.complete();\n                        }\n                        _b.label = 4;\n                    case 4:\n                        _b.trys.push([4, 9, , 10]);\n                        _b.label = 5;\n                    case 5:\n                        if (!true) return [3 /*break*/, 8];\n                        return [4 /*yield*/, __await(this.doDecodeSync())];\n                    case 6: return [4 /*yield*/, _b.sent()];\n                    case 7:\n                        _b.sent();\n                        if (--arrayItemsLeft === 0) {\n                            return [3 /*break*/, 8];\n                        }\n                        return [3 /*break*/, 5];\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        e_2 = _b.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e_2; // rethrow\n                        }\n                        return [3 /*break*/, 10];\n                    case 10:\n                        this.totalPos += this.pos;\n                        _b.label = 11;\n                    case 11: return [3 /*break*/, 2];\n                    case 12: return [3 /*break*/, 19];\n                    case 13:\n                        e_3_1 = _b.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3 /*break*/, 19];\n                    case 14:\n                        _b.trys.push([14, , 17, 18]);\n                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return))) return [3 /*break*/, 16];\n                        return [4 /*yield*/, __await(_a.call(stream_2))];\n                    case 15:\n                        _b.sent();\n                        _b.label = 16;\n                    case 16: return [3 /*break*/, 18];\n                    case 17:\n                        if (e_3) throw e_3.error;\n                        return [7 /*endfinally*/];\n                    case 18: return [7 /*endfinally*/];\n                    case 19: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Decoder.prototype.doDecodeSync = function () {\n        DECODE: while (true) {\n            var headByte = this.readHeadByte();\n            var object = void 0;\n            if (headByte >= 0xe0) {\n                // negative fixint (111x xxxx) 0xe0 - 0xff\n                object = headByte - 0x100;\n            }\n            else if (headByte < 0xc0) {\n                if (headByte < 0x80) {\n                    // positive fixint (0xxx xxxx) 0x00 - 0x7f\n                    object = headByte;\n                }\n                else if (headByte < 0x90) {\n                    // fixmap (1000 xxxx) 0x80 - 0x8f\n                    var size = headByte - 0x80;\n                    if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = {};\n                    }\n                }\n                else if (headByte < 0xa0) {\n                    // fixarray (1001 xxxx) 0x90 - 0x9f\n                    var size = headByte - 0x90;\n                    if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = [];\n                    }\n                }\n                else {\n                    // fixstr (101x xxxx) 0xa0 - 0xbf\n                    var byteLength = headByte - 0xa0;\n                    object = this.decodeUtf8String(byteLength, 0);\n                }\n            }\n            else if (headByte === 0xc0) {\n                // nil\n                object = null;\n            }\n            else if (headByte === 0xc2) {\n                // false\n                object = false;\n            }\n            else if (headByte === 0xc3) {\n                // true\n                object = true;\n            }\n            else if (headByte === 0xca) {\n                // float 32\n                object = this.readF32();\n            }\n            else if (headByte === 0xcb) {\n                // float 64\n                object = this.readF64();\n            }\n            else if (headByte === 0xcc) {\n                // uint 8\n                object = this.readU8();\n            }\n            else if (headByte === 0xcd) {\n                // uint 16\n                object = this.readU16();\n            }\n            else if (headByte === 0xce) {\n                // uint 32\n                object = this.readU32();\n            }\n            else if (headByte === 0xcf) {\n                // uint 64\n                object = this.readU64();\n            }\n            else if (headByte === 0xd0) {\n                // int 8\n                object = this.readI8();\n            }\n            else if (headByte === 0xd1) {\n                // int 16\n                object = this.readI16();\n            }\n            else if (headByte === 0xd2) {\n                // int 32\n                object = this.readI32();\n            }\n            else if (headByte === 0xd3) {\n                // int 64\n                object = this.readI64();\n            }\n            else if (headByte === 0xd9) {\n                // str 8\n                var byteLength = this.lookU8();\n                object = this.decodeUtf8String(byteLength, 1);\n            }\n            else if (headByte === 0xda) {\n                // str 16\n                var byteLength = this.lookU16();\n                object = this.decodeUtf8String(byteLength, 2);\n            }\n            else if (headByte === 0xdb) {\n                // str 32\n                var byteLength = this.lookU32();\n                object = this.decodeUtf8String(byteLength, 4);\n            }\n            else if (headByte === 0xdc) {\n                // array 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xdd) {\n                // array 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xde) {\n                // map 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xdf) {\n                // map 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xc4) {\n                // bin 8\n                var size = this.lookU8();\n                object = this.decodeBinary(size, 1);\n            }\n            else if (headByte === 0xc5) {\n                // bin 16\n                var size = this.lookU16();\n                object = this.decodeBinary(size, 2);\n            }\n            else if (headByte === 0xc6) {\n                // bin 32\n                var size = this.lookU32();\n                object = this.decodeBinary(size, 4);\n            }\n            else if (headByte === 0xd4) {\n                // fixext 1\n                object = this.decodeExtension(1, 0);\n            }\n            else if (headByte === 0xd5) {\n                // fixext 2\n                object = this.decodeExtension(2, 0);\n            }\n            else if (headByte === 0xd6) {\n                // fixext 4\n                object = this.decodeExtension(4, 0);\n            }\n            else if (headByte === 0xd7) {\n                // fixext 8\n                object = this.decodeExtension(8, 0);\n            }\n            else if (headByte === 0xd8) {\n                // fixext 16\n                object = this.decodeExtension(16, 0);\n            }\n            else if (headByte === 0xc7) {\n                // ext 8\n                var size = this.lookU8();\n                object = this.decodeExtension(size, 1);\n            }\n            else if (headByte === 0xc8) {\n                // ext 16\n                var size = this.lookU16();\n                object = this.decodeExtension(size, 2);\n            }\n            else if (headByte === 0xc9) {\n                // ext 32\n                var size = this.lookU32();\n                object = this.decodeExtension(size, 4);\n            }\n            else {\n                throw new DecodeError(\"Unrecognized type byte: \".concat(prettyByte(headByte)));\n            }\n            this.complete();\n            var stack = this.stack;\n            while (stack.length > 0) {\n                // arrays and maps\n                var state = stack[stack.length - 1];\n                if (state.type === 0 /* State.ARRAY */) {\n                    state.array[state.position] = object;\n                    state.position++;\n                    if (state.position === state.size) {\n                        stack.pop();\n                        object = state.array;\n                    }\n                    else {\n                        continue DECODE;\n                    }\n                }\n                else if (state.type === 1 /* State.MAP_KEY */) {\n                    if (!isValidMapKeyType(object)) {\n                        throw new DecodeError(\"The type of key must be string or number but \" + typeof object);\n                    }\n                    if (object === \"__proto__\") {\n                        throw new DecodeError(\"The key __proto__ is not allowed\");\n                    }\n                    state.key = object;\n                    state.type = 2 /* State.MAP_VALUE */;\n                    continue DECODE;\n                }\n                else {\n                    // it must be `state.type === State.MAP_VALUE` here\n                    state.map[state.key] = object;\n                    state.readCount++;\n                    if (state.readCount === state.size) {\n                        stack.pop();\n                        object = state.map;\n                    }\n                    else {\n                        state.key = null;\n                        state.type = 1 /* State.MAP_KEY */;\n                        continue DECODE;\n                    }\n                }\n            }\n            return object;\n        }\n    };\n    Decoder.prototype.readHeadByte = function () {\n        if (this.headByte === HEAD_BYTE_REQUIRED) {\n            this.headByte = this.readU8();\n            // console.log(\"headByte\", prettyByte(this.headByte));\n        }\n        return this.headByte;\n    };\n    Decoder.prototype.complete = function () {\n        this.headByte = HEAD_BYTE_REQUIRED;\n    };\n    Decoder.prototype.readArraySize = function () {\n        var headByte = this.readHeadByte();\n        switch (headByte) {\n            case 0xdc:\n                return this.readU16();\n            case 0xdd:\n                return this.readU32();\n            default: {\n                if (headByte < 0xa0) {\n                    return headByte - 0x90;\n                }\n                else {\n                    throw new DecodeError(\"Unrecognized array type byte: \".concat(prettyByte(headByte)));\n                }\n            }\n        }\n    };\n    Decoder.prototype.pushMapState = function (size) {\n        if (size > this.maxMapLength) {\n            throw new DecodeError(\"Max length exceeded: map length (\".concat(size, \") > maxMapLengthLength (\").concat(this.maxMapLength, \")\"));\n        }\n        this.stack.push({\n            type: 1 /* State.MAP_KEY */,\n            size: size,\n            key: null,\n            readCount: 0,\n            map: {},\n        });\n    };\n    Decoder.prototype.pushArrayState = function (size) {\n        if (size > this.maxArrayLength) {\n            throw new DecodeError(\"Max length exceeded: array length (\".concat(size, \") > maxArrayLength (\").concat(this.maxArrayLength, \")\"));\n        }\n        this.stack.push({\n            type: 0 /* State.ARRAY */,\n            size: size,\n            array: new Array(size),\n            position: 0,\n        });\n    };\n    Decoder.prototype.decodeUtf8String = function (byteLength, headerOffset) {\n        var _a;\n        if (byteLength > this.maxStrLength) {\n            throw new DecodeError(\"Max length exceeded: UTF-8 byte length (\".concat(byteLength, \") > maxStrLength (\").concat(this.maxStrLength, \")\"));\n        }\n        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headerOffset;\n        var object;\n        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n            object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n        }\n        else if (byteLength > TEXT_DECODER_THRESHOLD) {\n            object = utf8DecodeTD(this.bytes, offset, byteLength);\n        }\n        else {\n            object = utf8DecodeJs(this.bytes, offset, byteLength);\n        }\n        this.pos += headerOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.stateIsMapKey = function () {\n        if (this.stack.length > 0) {\n            var state = this.stack[this.stack.length - 1];\n            return state.type === 1 /* State.MAP_KEY */;\n        }\n        return false;\n    };\n    Decoder.prototype.decodeBinary = function (byteLength, headOffset) {\n        if (byteLength > this.maxBinLength) {\n            throw new DecodeError(\"Max length exceeded: bin length (\".concat(byteLength, \") > maxBinLength (\").concat(this.maxBinLength, \")\"));\n        }\n        if (!this.hasRemaining(byteLength + headOffset)) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headOffset;\n        var object = this.bytes.subarray(offset, offset + byteLength);\n        this.pos += headOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.decodeExtension = function (size, headOffset) {\n        if (size > this.maxExtLength) {\n            throw new DecodeError(\"Max length exceeded: ext length (\".concat(size, \") > maxExtLength (\").concat(this.maxExtLength, \")\"));\n        }\n        var extType = this.view.getInt8(this.pos + headOffset);\n        var data = this.decodeBinary(size, headOffset + 1 /* extType */);\n        return this.extensionCodec.decode(data, extType, this.context);\n    };\n    Decoder.prototype.lookU8 = function () {\n        return this.view.getUint8(this.pos);\n    };\n    Decoder.prototype.lookU16 = function () {\n        return this.view.getUint16(this.pos);\n    };\n    Decoder.prototype.lookU32 = function () {\n        return this.view.getUint32(this.pos);\n    };\n    Decoder.prototype.readU8 = function () {\n        var value = this.view.getUint8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readI8 = function () {\n        var value = this.view.getInt8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readU16 = function () {\n        var value = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readI16 = function () {\n        var value = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readU32 = function () {\n        var value = this.view.getUint32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readI32 = function () {\n        var value = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readU64 = function () {\n        var value = getUint64(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readI64 = function () {\n        var value = getInt64(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readF32 = function () {\n        var value = this.view.getFloat32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readF64 = function () {\n        var value = this.view.getFloat64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    return Decoder;\n}());\nexport { Decoder };\n//# sourceMappingURL=Decoder.mjs.map","import { Decoder } from \"./Decoder.mjs\";\nexport var defaultDecodeOptions = {};\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync()}, {@link decodeStream()}, or {@link decodeArrayStream()}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decode(buffer, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var decoder = new Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decode(buffer);\n}\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream()}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMulti(buffer, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var decoder = new Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeMulti(buffer);\n}\n//# sourceMappingURL=decode.mjs.map","import { utf8EncodeJs, utf8Count, TEXT_ENCODER_THRESHOLD, utf8EncodeTE } from \"./utils/utf8.mjs\";\nimport { ExtensionCodec } from \"./ExtensionCodec.mjs\";\nimport { setInt64, setUint64 } from \"./utils/int.mjs\";\nimport { ensureUint8Array } from \"./utils/typedArrays.mjs\";\nexport var DEFAULT_MAX_DEPTH = 100;\nexport var DEFAULT_INITIAL_BUFFER_SIZE = 2048;\nvar Encoder = /** @class */ (function () {\n    function Encoder(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n        if (extensionCodec === void 0) { extensionCodec = ExtensionCodec.defaultCodec; }\n        if (context === void 0) { context = undefined; }\n        if (maxDepth === void 0) { maxDepth = DEFAULT_MAX_DEPTH; }\n        if (initialBufferSize === void 0) { initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE; }\n        if (sortKeys === void 0) { sortKeys = false; }\n        if (forceFloat32 === void 0) { forceFloat32 = false; }\n        if (ignoreUndefined === void 0) { ignoreUndefined = false; }\n        if (forceIntegerToFloat === void 0) { forceIntegerToFloat = false; }\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxDepth = maxDepth;\n        this.initialBufferSize = initialBufferSize;\n        this.sortKeys = sortKeys;\n        this.forceFloat32 = forceFloat32;\n        this.ignoreUndefined = ignoreUndefined;\n        this.forceIntegerToFloat = forceIntegerToFloat;\n        this.pos = 0;\n        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n        this.bytes = new Uint8Array(this.view.buffer);\n    }\n    Encoder.prototype.reinitializeState = function () {\n        this.pos = 0;\n    };\n    /**\n     * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n     *\n     * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n     */\n    Encoder.prototype.encodeSharedRef = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.bytes.subarray(0, this.pos);\n    };\n    /**\n     * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n     */\n    Encoder.prototype.encode = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.bytes.slice(0, this.pos);\n    };\n    Encoder.prototype.doEncode = function (object, depth) {\n        if (depth > this.maxDepth) {\n            throw new Error(\"Too deep objects in depth \".concat(depth));\n        }\n        if (object == null) {\n            this.encodeNil();\n        }\n        else if (typeof object === \"boolean\") {\n            this.encodeBoolean(object);\n        }\n        else if (typeof object === \"number\") {\n            this.encodeNumber(object);\n        }\n        else if (typeof object === \"string\") {\n            this.encodeString(object);\n        }\n        else {\n            this.encodeObject(object, depth);\n        }\n    };\n    Encoder.prototype.ensureBufferSizeToWrite = function (sizeToWrite) {\n        var requiredSize = this.pos + sizeToWrite;\n        if (this.view.byteLength < requiredSize) {\n            this.resizeBuffer(requiredSize * 2);\n        }\n    };\n    Encoder.prototype.resizeBuffer = function (newSize) {\n        var newBuffer = new ArrayBuffer(newSize);\n        var newBytes = new Uint8Array(newBuffer);\n        var newView = new DataView(newBuffer);\n        newBytes.set(this.bytes);\n        this.view = newView;\n        this.bytes = newBytes;\n    };\n    Encoder.prototype.encodeNil = function () {\n        this.writeU8(0xc0);\n    };\n    Encoder.prototype.encodeBoolean = function (object) {\n        if (object === false) {\n            this.writeU8(0xc2);\n        }\n        else {\n            this.writeU8(0xc3);\n        }\n    };\n    Encoder.prototype.encodeNumber = function (object) {\n        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n            if (object >= 0) {\n                if (object < 0x80) {\n                    // positive fixint\n                    this.writeU8(object);\n                }\n                else if (object < 0x100) {\n                    // uint 8\n                    this.writeU8(0xcc);\n                    this.writeU8(object);\n                }\n                else if (object < 0x10000) {\n                    // uint 16\n                    this.writeU8(0xcd);\n                    this.writeU16(object);\n                }\n                else if (object < 0x100000000) {\n                    // uint 32\n                    this.writeU8(0xce);\n                    this.writeU32(object);\n                }\n                else {\n                    // uint 64\n                    this.writeU8(0xcf);\n                    this.writeU64(object);\n                }\n            }\n            else {\n                if (object >= -0x20) {\n                    // negative fixint\n                    this.writeU8(0xe0 | (object + 0x20));\n                }\n                else if (object >= -0x80) {\n                    // int 8\n                    this.writeU8(0xd0);\n                    this.writeI8(object);\n                }\n                else if (object >= -0x8000) {\n                    // int 16\n                    this.writeU8(0xd1);\n                    this.writeI16(object);\n                }\n                else if (object >= -0x80000000) {\n                    // int 32\n                    this.writeU8(0xd2);\n                    this.writeI32(object);\n                }\n                else {\n                    // int 64\n                    this.writeU8(0xd3);\n                    this.writeI64(object);\n                }\n            }\n        }\n        else {\n            // non-integer numbers\n            if (this.forceFloat32) {\n                // float 32\n                this.writeU8(0xca);\n                this.writeF32(object);\n            }\n            else {\n                // float 64\n                this.writeU8(0xcb);\n                this.writeF64(object);\n            }\n        }\n    };\n    Encoder.prototype.writeStringHeader = function (byteLength) {\n        if (byteLength < 32) {\n            // fixstr\n            this.writeU8(0xa0 + byteLength);\n        }\n        else if (byteLength < 0x100) {\n            // str 8\n            this.writeU8(0xd9);\n            this.writeU8(byteLength);\n        }\n        else if (byteLength < 0x10000) {\n            // str 16\n            this.writeU8(0xda);\n            this.writeU16(byteLength);\n        }\n        else if (byteLength < 0x100000000) {\n            // str 32\n            this.writeU8(0xdb);\n            this.writeU32(byteLength);\n        }\n        else {\n            throw new Error(\"Too long string: \".concat(byteLength, \" bytes in UTF-8\"));\n        }\n    };\n    Encoder.prototype.encodeString = function (object) {\n        var maxHeaderSize = 1 + 4;\n        var strLength = object.length;\n        if (strLength > TEXT_ENCODER_THRESHOLD) {\n            var byteLength = utf8Count(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            utf8EncodeTE(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n        else {\n            var byteLength = utf8Count(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            utf8EncodeJs(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n    };\n    Encoder.prototype.encodeObject = function (object, depth) {\n        // try to encode objects with custom codec first of non-primitives\n        var ext = this.extensionCodec.tryToEncode(object, this.context);\n        if (ext != null) {\n            this.encodeExtension(ext);\n        }\n        else if (Array.isArray(object)) {\n            this.encodeArray(object, depth);\n        }\n        else if (ArrayBuffer.isView(object)) {\n            this.encodeBinary(object);\n        }\n        else if (typeof object === \"object\") {\n            this.encodeMap(object, depth);\n        }\n        else {\n            // symbol, function and other special object come here unless extensionCodec handles them.\n            throw new Error(\"Unrecognized object: \".concat(Object.prototype.toString.apply(object)));\n        }\n    };\n    Encoder.prototype.encodeBinary = function (object) {\n        var size = object.byteLength;\n        if (size < 0x100) {\n            // bin 8\n            this.writeU8(0xc4);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // bin 16\n            this.writeU8(0xc5);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // bin 32\n            this.writeU8(0xc6);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large binary: \".concat(size));\n        }\n        var bytes = ensureUint8Array(object);\n        this.writeU8a(bytes);\n    };\n    Encoder.prototype.encodeArray = function (object, depth) {\n        var size = object.length;\n        if (size < 16) {\n            // fixarray\n            this.writeU8(0x90 + size);\n        }\n        else if (size < 0x10000) {\n            // array 16\n            this.writeU8(0xdc);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // array 32\n            this.writeU8(0xdd);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large array: \".concat(size));\n        }\n        for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n            var item = object_1[_i];\n            this.doEncode(item, depth + 1);\n        }\n    };\n    Encoder.prototype.countWithoutUndefined = function (object, keys) {\n        var count = 0;\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            if (object[key] !== undefined) {\n                count++;\n            }\n        }\n        return count;\n    };\n    Encoder.prototype.encodeMap = function (object, depth) {\n        var keys = Object.keys(object);\n        if (this.sortKeys) {\n            keys.sort();\n        }\n        var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n        if (size < 16) {\n            // fixmap\n            this.writeU8(0x80 + size);\n        }\n        else if (size < 0x10000) {\n            // map 16\n            this.writeU8(0xde);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // map 32\n            this.writeU8(0xdf);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large map object: \".concat(size));\n        }\n        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n            var key = keys_2[_i];\n            var value = object[key];\n            if (!(this.ignoreUndefined && value === undefined)) {\n                this.encodeString(key);\n                this.doEncode(value, depth + 1);\n            }\n        }\n    };\n    Encoder.prototype.encodeExtension = function (ext) {\n        var size = ext.data.length;\n        if (size === 1) {\n            // fixext 1\n            this.writeU8(0xd4);\n        }\n        else if (size === 2) {\n            // fixext 2\n            this.writeU8(0xd5);\n        }\n        else if (size === 4) {\n            // fixext 4\n            this.writeU8(0xd6);\n        }\n        else if (size === 8) {\n            // fixext 8\n            this.writeU8(0xd7);\n        }\n        else if (size === 16) {\n            // fixext 16\n            this.writeU8(0xd8);\n        }\n        else if (size < 0x100) {\n            // ext 8\n            this.writeU8(0xc7);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // ext 16\n            this.writeU8(0xc8);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // ext 32\n            this.writeU8(0xc9);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large extension object: \".concat(size));\n        }\n        this.writeI8(ext.type);\n        this.writeU8a(ext.data);\n    };\n    Encoder.prototype.writeU8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setUint8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU8a = function (values) {\n        var size = values.length;\n        this.ensureBufferSizeToWrite(size);\n        this.bytes.set(values, this.pos);\n        this.pos += size;\n    };\n    Encoder.prototype.writeI8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setInt8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeI16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setInt16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeU32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setUint32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeI32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setInt32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setFloat32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setFloat64(this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeU64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        setUint64(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeI64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        setInt64(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    return Encoder;\n}());\nexport { Encoder };\n//# sourceMappingURL=Encoder.mjs.map","import { Encoder } from \"./Encoder.mjs\";\nvar defaultEncodeOptions = {};\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nexport function encode(value, options) {\n    if (options === void 0) { options = defaultEncodeOptions; }\n    var encoder = new Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);\n    return encoder.encodeSharedRef(value);\n}\n//# sourceMappingURL=encode.mjs.map","// Integer Utility\nexport var UINT32_MAX = 4294967295;\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\nexport function setUint64(view, offset, value) {\n    var high = value / 4294967296;\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nexport function setInt64(view, offset, value) {\n    var high = Math.floor(value / 4294967296);\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nexport function getInt64(view, offset) {\n    var high = view.getInt32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\nexport function getUint64(view, offset) {\n    var high = view.getUint32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\n//# sourceMappingURL=int.mjs.map","export function ensureUint8Array(buffer) {\n    if (buffer instanceof Uint8Array) {\n        return buffer;\n    }\n    else if (ArrayBuffer.isView(buffer)) {\n        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n    else if (buffer instanceof ArrayBuffer) {\n        return new Uint8Array(buffer);\n    }\n    else {\n        // ArrayLike<number>\n        return Uint8Array.from(buffer);\n    }\n}\nexport function createDataView(buffer) {\n    if (buffer instanceof ArrayBuffer) {\n        return new DataView(buffer);\n    }\n    var bufferView = ensureUint8Array(buffer);\n    return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n//# sourceMappingURL=typedArrays.mjs.map","var _a, _b, _c;\n/* eslint-disable @typescript-eslint/no-unnecessary-condition */\nimport { UINT32_MAX } from \"./int.mjs\";\nvar TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a[\"TEXT_ENCODING\"]) !== \"never\") &&\n    typeof TextEncoder !== \"undefined\" &&\n    typeof TextDecoder !== \"undefined\";\nexport function utf8Count(str) {\n    var strLength = str.length;\n    var byteLength = 0;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            byteLength++;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            byteLength += 2;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                byteLength += 3;\n            }\n            else {\n                // 4-byte\n                byteLength += 4;\n            }\n        }\n    }\n    return byteLength;\n}\nexport function utf8EncodeJs(str, output, outputOffset) {\n    var strLength = str.length;\n    var offset = outputOffset;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            output[offset++] = value;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // 4-byte\n                output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n                output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n        }\n        output[offset++] = (value & 0x3f) | 0x80;\n    }\n}\nvar sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;\nexport var TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n    ? UINT32_MAX\n    : typeof process !== \"undefined\" && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b[\"TEXT_ENCODING\"]) !== \"force\"\n        ? 200\n        : 0;\nfunction utf8EncodeTEencode(str, output, outputOffset) {\n    output.set(sharedTextEncoder.encode(str), outputOffset);\n}\nfunction utf8EncodeTEencodeInto(str, output, outputOffset) {\n    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\nexport var utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\nvar CHUNK_SIZE = 4096;\nexport function utf8DecodeJs(bytes, inputOffset, byteLength) {\n    var offset = inputOffset;\n    var end = offset + byteLength;\n    var units = [];\n    var result = \"\";\n    while (offset < end) {\n        var byte1 = bytes[offset++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            var byte4 = bytes[offset++] & 0x3f;\n            var unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= CHUNK_SIZE) {\n            result += String.fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += String.fromCharCode.apply(String, units);\n    }\n    return result;\n}\nvar sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\nexport var TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n    ? UINT32_MAX\n    : typeof process !== \"undefined\" && ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c[\"TEXT_DECODER\"]) !== \"force\"\n        ? 200\n        : 0;\nexport function utf8DecodeTD(bytes, inputOffset, byteLength) {\n    var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n    return sharedTextDecoder.decode(stringBytes);\n}\n//# sourceMappingURL=utf8.mjs.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { RPC, API_VERSION } from \"./rpc.js\";\nimport {\n  assert,\n  randId,\n  waitFor,\n  loadRequirements,\n  parseServiceUrl,\n} from \"./utils/index.js\";\nimport { schemaFunction } from \"./utils/schema.js\";\nimport { getRTCService, registerRTCService } from \"./webrtc-client.js\";\n\n// Import HTTP client for internal use and re-export\nimport {\n  HTTPStreamingRPCConnection,\n  connectToServerHTTP,\n  getRemoteServiceHTTP,\n  normalizeServerUrl as normalizeServerUrlHTTP,\n} from \"./http-client.js\";\n\n// Re-export HTTP client classes and functions\nexport {\n  HTTPStreamingRPCConnection,\n  connectToServerHTTP,\n  getRemoteServiceHTTP,\n  normalizeServerUrlHTTP,\n};\n\nexport { RPC, API_VERSION, schemaFunction };\nexport { loadRequirements };\nexport { getRTCService, registerRTCService };\n\nconst MAX_RETRY = 1000000;\n\nclass WebsocketRPCConnection {\n  constructor(\n    server_url,\n    client_id,\n    workspace,\n    token,\n    reconnection_token = null,\n    timeout = 60,\n    WebSocketClass = null,\n    token_refresh_interval = 2 * 60 * 60,\n    additional_headers = null,\n  ) {\n    assert(server_url && client_id, \"server_url and client_id are required\");\n    this._server_url = server_url;\n    this._client_id = client_id;\n    this._workspace = workspace;\n    this._token = token;\n    this._reconnection_token = reconnection_token;\n    this._websocket = null;\n    this._handle_message = null;\n    this._handle_connected = null; // Connection open event handler\n    this._handle_disconnected = null; // Disconnection event handler\n    this._timeout = timeout;\n    this._WebSocketClass = WebSocketClass || WebSocket; // Allow overriding the WebSocket class\n    this._closed = false;\n    this._legacy_auth = null;\n    this.connection_info = null;\n    this._enable_reconnect = false;\n    this._token_refresh_interval = token_refresh_interval;\n    this.manager_id = null;\n    this._refresh_token_task = null;\n    this._last_message = null; // Store the last sent message\n    this._reconnect_timeouts = new Set(); // Track reconnection timeouts\n    this._additional_headers = additional_headers;\n  }\n\n  /**\n   * Centralized cleanup method to clear all timers and prevent resource leaks\n   */\n  _cleanup() {\n    // Clear token refresh interval\n    if (this._refresh_token_task) {\n      clearInterval(this._refresh_token_task);\n      this._refresh_token_task = null;\n    }\n\n    // Clear all reconnection timeouts\n    for (const timeoutId of this._reconnect_timeouts) {\n      clearTimeout(timeoutId);\n    }\n    this._reconnect_timeouts.clear();\n  }\n\n  on_message(handler) {\n    assert(handler, \"handler is required\");\n    this._handle_message = handler;\n  }\n\n  on_connected(handler) {\n    this._handle_connected = handler;\n  }\n\n  on_disconnected(handler) {\n    this._handle_disconnected = handler;\n  }\n\n  async _attempt_connection(server_url, attempt_fallback = true) {\n    return new Promise((resolve, reject) => {\n      this._legacy_auth = false;\n      const websocket = new this._WebSocketClass(server_url);\n      websocket.binaryType = \"arraybuffer\";\n\n      websocket.onopen = () => {\n        console.info(\"WebSocket connection established\");\n        resolve(websocket);\n      };\n\n      websocket.onerror = (event) => {\n        console.error(\"WebSocket connection error:\", event);\n        reject(new Error(`WebSocket connection error: ${event}`));\n      };\n\n      websocket.onclose = (event) => {\n        if (event.code === 1003 && attempt_fallback) {\n          console.info(\n            \"Received 1003 error, attempting connection with query parameters.\",\n          );\n          this._legacy_auth = true;\n          this._attempt_connection_with_query_params(server_url)\n            .then(resolve)\n            .catch(reject);\n        } else if (this._handle_disconnected) {\n          this._handle_disconnected(event.reason);\n        }\n      };\n    });\n  }\n\n  async _attempt_connection_with_query_params(server_url) {\n    // Initialize an array to hold parts of the query string\n    const queryParamsParts = [];\n\n    // Conditionally add each parameter if it has a non-empty value\n    if (this._client_id)\n      queryParamsParts.push(`client_id=${encodeURIComponent(this._client_id)}`);\n    if (this._workspace)\n      queryParamsParts.push(`workspace=${encodeURIComponent(this._workspace)}`);\n    if (this._token)\n      queryParamsParts.push(`token=${encodeURIComponent(this._token)}`);\n    if (this._reconnection_token)\n      queryParamsParts.push(\n        `reconnection_token=${encodeURIComponent(this._reconnection_token)}`,\n      );\n\n    // Join the parts with '&' to form the final query string, prepend '?' if there are any parameters\n    const queryString =\n      queryParamsParts.length > 0 ? `?${queryParamsParts.join(\"&\")}` : \"\";\n\n    // Construct the full URL by appending the query string if it exists\n    const full_url = server_url + queryString;\n\n    return await this._attempt_connection(full_url, false);\n  }\n\n  _establish_connection() {\n    return new Promise((resolve, reject) => {\n      this._websocket.onmessage = (event) => {\n        const data = event.data;\n        const first_message = JSON.parse(data);\n        if (first_message.type == \"connection_info\") {\n          this.connection_info = first_message;\n          if (this._workspace) {\n            assert(\n              this.connection_info.workspace === this._workspace,\n              `Connected to the wrong workspace: ${this.connection_info.workspace}, expected: ${this._workspace}`,\n            );\n          }\n          if (this.connection_info.reconnection_token) {\n            this._reconnection_token = this.connection_info.reconnection_token;\n          }\n          if (this.connection_info.reconnection_token_life_time) {\n            // make sure the token refresh interval is less than the token life time\n            if (\n              this.token_refresh_interval >\n              this.connection_info.reconnection_token_life_time / 1.5\n            ) {\n              console.warn(\n                `Token refresh interval is too long (${this.token_refresh_interval}), setting it to 1.5 times of the token life time(${this.connection_info.reconnection_token_life_time}).`,\n              );\n              this.token_refresh_interval =\n                this.connection_info.reconnection_token_life_time / 1.5;\n            }\n          }\n          this.manager_id = this.connection_info.manager_id || null;\n          console.log(\n            `Successfully connected to the server, workspace: ${this.connection_info.workspace}, manager_id: ${this.manager_id}`,\n          );\n          if (this.connection_info.announcement) {\n            console.log(`${this.connection_info.announcement}`);\n          }\n          resolve(this.connection_info);\n        } else if (first_message.type == \"error\") {\n          const error = \"ConnectionAbortedError: \" + first_message.message;\n          console.error(\"Failed to connect, \" + error);\n          reject(new Error(error));\n          return;\n        } else {\n          console.error(\n            \"ConnectionAbortedError: Unexpected message received from the server:\",\n            data,\n          );\n          reject(\n            new Error(\n              \"ConnectionAbortedError: Unexpected message received from the server\",\n            ),\n          );\n          return;\n        }\n      };\n    });\n  }\n\n  async open() {\n    console.log(\n      \"Creating a new websocket connection to\",\n      this._server_url.split(\"?\")[0],\n    );\n    try {\n      this._websocket = await this._attempt_connection(this._server_url);\n      if (this._legacy_auth) {\n        throw new Error(\n          \"NotImplementedError: Legacy authentication is not supported\",\n        );\n      }\n      // Send authentication info as the first message if connected without query params\n      const authInfo = JSON.stringify({\n        client_id: this._client_id,\n        workspace: this._workspace,\n        token: this._token,\n        reconnection_token: this._reconnection_token,\n      });\n      this._websocket.send(authInfo);\n      // Wait for the first message from the server\n      await waitFor(\n        this._establish_connection(),\n        this._timeout,\n        \"Failed to receive the first message from the server\",\n      );\n      if (this._token_refresh_interval > 0) {\n        setTimeout(() => {\n          this._send_refresh_token();\n          this._refresh_token_task = setInterval(() => {\n            this._send_refresh_token();\n          }, this._token_refresh_interval * 1000);\n        }, 2000);\n      }\n      // Listen to messages from the server\n      this._enable_reconnect = true;\n      this._closed = false;\n      this._websocket.onmessage = (event) => {\n        if (typeof event.data === \"string\") {\n          const parsedData = JSON.parse(event.data);\n          // Check if the message is a reconnection token\n          if (parsedData.type === \"reconnection_token\") {\n            this._reconnection_token = parsedData.reconnection_token;\n            // console.log(\"Reconnection token received\");\n          } else {\n            console.log(\"Received message from the server:\", parsedData);\n          }\n        } else {\n          this._handle_message(event.data);\n        }\n      };\n\n      this._websocket.onerror = (event) => {\n        console.error(\"WebSocket connection error:\", event);\n        // Clean up timers on error\n        this._cleanup();\n      };\n\n      this._websocket.onclose = this._handle_close.bind(this);\n\n      if (this._handle_connected) {\n        this._handle_connected(this.connection_info);\n      }\n      return this.connection_info;\n    } catch (error) {\n      // Clean up any timers that might have been set up before the error\n      this._cleanup();\n      console.error(\n        \"Failed to connect to\",\n        this._server_url.split(\"?\")[0],\n        error,\n      );\n      throw error;\n    }\n  }\n\n  _send_refresh_token() {\n    if (this._websocket && this._websocket.readyState === WebSocket.OPEN) {\n      const refreshMessage = JSON.stringify({ type: \"refresh_token\" });\n      this._websocket.send(refreshMessage);\n      // console.log(\"Requested refresh token\");\n    }\n  }\n\n  _handle_close(event) {\n    if (\n      !this._closed &&\n      this._websocket &&\n      this._websocket.readyState === WebSocket.CLOSED\n    ) {\n      // Clean up timers when connection closes\n      this._cleanup();\n\n      // Even if it's a graceful closure (codes 1000, 1001), if it wasn't user-initiated,\n      // we should attempt to reconnect (e.g., server restart, k8s upgrade)\n      if (this._enable_reconnect) {\n        if ([1000, 1001].includes(event.code)) {\n          console.warn(\n            `Websocket connection closed gracefully by server (code: ${event.code}): ${event.reason} - attempting reconnect`,\n          );\n        } else {\n          console.warn(\n            \"Websocket connection closed unexpectedly (code: %s): %s\",\n            event.code,\n            event.reason,\n          );\n        }\n\n        let retry = 0;\n        const baseDelay = 1000; // Start with 1 second\n        const maxDelay = 60000; // Maximum delay of 60 seconds\n        const maxJitter = 0.1; // Maximum jitter factor\n\n        const reconnect = async () => {\n          // Check if we were explicitly closed\n          if (this._closed) {\n            console.info(\"Connection was closed, stopping reconnection\");\n            return;\n          }\n\n          try {\n            console.warn(\n              `Reconnecting to ${this._server_url.split(\"?\")[0]} (attempt #${retry})`,\n            );\n            // Open the connection, this will trigger the on_connected callback\n            await this.open();\n\n            // Wait a short time for services to be registered\n            // This gives time for the on_connected callback to complete\n            // which includes re-registering all services to the server\n            await new Promise((resolve) => setTimeout(resolve, 500));\n\n            // Resend last message if there was one\n            if (this._last_message) {\n              console.info(\"Resending last message after reconnection\");\n              this._websocket.send(this._last_message);\n              this._last_message = null;\n            }\n            console.warn(\n              `Successfully reconnected to server ${this._server_url} (services re-registered)`,\n            );\n            // Emit reconnection success event\n            if (this._handle_connected) {\n              this._handle_connected(this.connection_info);\n            }\n          } catch (e) {\n            if (`${e}`.includes(\"ConnectionAbortedError:\")) {\n              console.warn(\"Server refused to reconnect:\", e);\n              // Mark as closed and notify the application\n              this._closed = true;\n              if (this._handle_disconnected) {\n                this._handle_disconnected(`Server refused reconnection: ${e}`);\n              }\n              return;\n            } else if (`${e}`.includes(\"NotImplementedError:\")) {\n              console.error(\n                `${e}\\nIt appears that you are trying to connect to a hypha server that is older than 0.20.0, please upgrade the hypha server or use the websocket client in imjoy-rpc(https://www.npmjs.com/package/imjoy-rpc) instead`,\n              );\n              // Mark as closed to prevent further reconnection attempts\n              this._closed = true;\n              if (this._handle_disconnected) {\n                this._handle_disconnected(`Server too old: ${e}`);\n              }\n              return;\n            }\n\n            // Log specific error types for better debugging\n            if (e.name === \"NetworkError\" || e.message.includes(\"network\")) {\n              console.error(`Network error during reconnection: ${e.message}`);\n            } else if (\n              e.name === \"TimeoutError\" ||\n              e.message.includes(\"timeout\")\n            ) {\n              console.error(\n                `Connection timeout during reconnection: ${e.message}`,\n              );\n            } else {\n              console.error(\n                `Unexpected error during reconnection: ${e.message}`,\n              );\n            }\n\n            // Calculate exponential backoff with jitter\n            const delay = Math.min(baseDelay * Math.pow(2, retry), maxDelay);\n            // Add jitter to prevent thundering herd\n            const jitter = (Math.random() * 2 - 1) * maxJitter * delay;\n            const finalDelay = Math.max(100, delay + jitter);\n\n            console.debug(\n              `Waiting ${(finalDelay / 1000).toFixed(2)}s before next reconnection attempt`,\n            );\n\n            // Track the reconnection timeout to prevent leaks\n            const timeoutId = setTimeout(async () => {\n              this._reconnect_timeouts.delete(timeoutId);\n\n              // Check if connection was restored externally\n              if (\n                this._websocket &&\n                this._websocket.readyState === WebSocket.OPEN\n              ) {\n                console.info(\"Connection restored externally\");\n                return;\n              }\n\n              // Check if we were explicitly closed\n              if (this._closed) {\n                console.info(\"Connection was closed, stopping reconnection\");\n                return;\n              }\n\n              retry += 1;\n              if (retry < MAX_RETRY) {\n                await reconnect();\n              } else {\n                console.error(\n                  `Failed to reconnect after ${MAX_RETRY} attempts, giving up.`,\n                );\n                // Mark as closed to prevent further reconnection attempts\n                this._closed = true;\n                // Notify about max retry exceeded\n                if (this._handle_disconnected) {\n                  this._handle_disconnected(\n                    \"Max reconnection attempts exceeded\",\n                  );\n                }\n                // Note: We intentionally do NOT call process.exit() here.\n                // Instead, we mark the connection as closed and let the\n                // application handle the failure through the disconnected\n                // handler or by checking connection state.\n              }\n            }, finalDelay);\n            this._reconnect_timeouts.add(timeoutId);\n          }\n        };\n        reconnect();\n      }\n    } else {\n      // Clean up timers in all cases\n      this._cleanup();\n      if (this._handle_disconnected) {\n        this._handle_disconnected(event.reason);\n      }\n    }\n  }\n\n  async emit_message(data) {\n    if (this._closed) {\n      throw new Error(\"Connection is closed\");\n    }\n    if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {\n      await this.open();\n    }\n    try {\n      this._last_message = data; // Store the message before sending\n      this._websocket.send(data);\n      this._last_message = null; // Clear after successful send\n    } catch (exp) {\n      console.error(`Failed to send data, error: ${exp}`);\n      throw exp;\n    }\n  }\n\n  disconnect(reason) {\n    this._closed = true;\n    this._last_message = null; // Clear last message on disconnect\n    // Ensure websocket is closed if it exists and is not already closed or closing\n    if (\n      this._websocket &&\n      this._websocket.readyState !== WebSocket.CLOSED &&\n      this._websocket.readyState !== WebSocket.CLOSING\n    ) {\n      this._websocket.close(1000, reason);\n    }\n    // Use centralized cleanup to clear all timers\n    this._cleanup();\n    console.info(`WebSocket connection disconnected (${reason})`);\n  }\n}\n\nfunction normalizeServerUrl(server_url) {\n  if (!server_url) throw new Error(\"server_url is required\");\n  if (server_url.startsWith(\"http://\")) {\n    server_url =\n      server_url.replace(\"http://\", \"ws://\").replace(/\\/$/, \"\") + \"/ws\";\n  } else if (server_url.startsWith(\"https://\")) {\n    server_url =\n      server_url.replace(\"https://\", \"wss://\").replace(/\\/$/, \"\") + \"/ws\";\n  }\n  return server_url;\n}\n\n/**\n * Login to the hypha server.\n *\n * Configuration options:\n *   server_url: The server URL (required)\n *   workspace: Target workspace (optional)\n *   login_service_id: Login service ID (default: \"public/hypha-login\")\n *   expires_in: Token expiration time (optional)\n *   login_timeout: Timeout for login process (default: 60)\n *   login_callback: Callback function for login URL (optional)\n *   profile: Whether to return user profile (optional)\n *   additional_headers: Additional HTTP headers (optional)\n *   transport: Transport type - \"websocket\" (default) or \"http\"\n */\nexport async function login(config) {\n  const service_id = config.login_service_id || \"public/hypha-login\";\n  const workspace = config.workspace;\n  const expires_in = config.expires_in;\n  const timeout = config.login_timeout || 60;\n  const callback = config.login_callback;\n  const profile = config.profile;\n  const additional_headers = config.additional_headers;\n  const transport = config.transport || \"websocket\";\n\n  const server = await connectToServer({\n    name: \"initial login client\",\n    server_url: config.server_url,\n    additional_headers: additional_headers,\n    transport: transport,\n  });\n  try {\n    const svc = await server.getService(service_id);\n    assert(svc, `Failed to get the login service: ${service_id}`);\n    let context;\n    if (workspace) {\n      context = await svc.start({ workspace, expires_in, _rkwargs: true });\n    } else {\n      context = await svc.start();\n    }\n    if (callback) {\n      await callback(context);\n    } else {\n      console.log(`Please open your browser and login at ${context.login_url}`);\n    }\n    return await svc.check(context.key, { timeout, profile, _rkwargs: true });\n  } catch (error) {\n    throw error;\n  } finally {\n    await server.disconnect();\n  }\n}\n\n/**\n * Logout from the hypha server.\n *\n * Configuration options:\n *   server_url: The server URL (required)\n *   login_service_id: Login service ID (default: \"public/hypha-login\")\n *   logout_callback: Callback function for logout URL (optional)\n *   additional_headers: Additional HTTP headers (optional)\n *   transport: Transport type - \"websocket\" (default) or \"http\"\n */\nexport async function logout(config) {\n  const service_id = config.login_service_id || \"public/hypha-login\";\n  const callback = config.logout_callback;\n  const additional_headers = config.additional_headers;\n  const transport = config.transport || \"websocket\";\n\n  const server = await connectToServer({\n    name: \"initial logout client\",\n    server_url: config.server_url,\n    additional_headers: additional_headers,\n    transport: transport,\n  });\n  try {\n    const svc = await server.getService(service_id);\n    assert(svc, `Failed to get the login service: ${service_id}`);\n\n    // Check if logout function exists for backward compatibility\n    if (!svc.logout) {\n      throw new Error(\n        \"Logout is not supported by this server. \" +\n          \"Please upgrade the Hypha server to a version that supports logout.\",\n      );\n    }\n\n    const context = await svc.logout({});\n    if (callback) {\n      await callback(context);\n    } else {\n      console.log(\n        `Please open your browser to logout at ${context.logout_url}`,\n      );\n    }\n    return context;\n  } catch (error) {\n    throw error;\n  } finally {\n    await server.disconnect();\n  }\n}\n\nasync function webrtcGetService(wm, rtc_service_id, query, config) {\n  config = config || {};\n  const webrtc = config.webrtc;\n  const webrtc_config = config.webrtc_config;\n  if (config.webrtc !== undefined) delete config.webrtc;\n  if (config.webrtc_config !== undefined) delete config.webrtc_config;\n  assert(\n    [undefined, true, false, \"auto\"].includes(webrtc),\n    \"webrtc must be true, false or 'auto'\",\n  );\n\n  const svc = await wm.getService(query, config);\n  if (webrtc === true || webrtc === \"auto\") {\n    if (svc.id.includes(\":\") && svc.id.includes(\"/\")) {\n      try {\n        // Assuming that the client registered a webrtc service with the client_id + \"-rtc\"\n        const peer = await getRTCService(wm, rtc_service_id, webrtc_config);\n        const rtcSvc = await peer.getService(svc.id.split(\":\")[1], config);\n        rtcSvc._webrtc = true;\n        rtcSvc._peer = peer;\n        rtcSvc._service = svc;\n        return rtcSvc;\n      } catch (e) {\n        console.warn(\n          \"Failed to get webrtc service, using websocket connection\",\n          e,\n        );\n      }\n    }\n    if (webrtc === true) {\n      throw new Error(\"Failed to get the service via webrtc\");\n    }\n  }\n  return svc;\n}\n\nexport async function connectToServer(config) {\n  // Support HTTP transport via transport option\n  const transport = config.transport || \"websocket\";\n  if (transport === \"http\") {\n    return await connectToServerHTTP(config);\n  }\n\n  if (config.server) {\n    config.server_url = config.server_url || config.server.url;\n    config.WebSocketClass =\n      config.WebSocketClass || config.server.WebSocketClass;\n  }\n  let clientId = config.client_id;\n  if (!clientId) {\n    clientId = randId();\n    config.client_id = clientId;\n  }\n  if (Object.keys(config).length === 0) {\n    if (typeof process !== \"undefined\" && process.env) {\n      // Node.js\n      config.server_url = process.env.HYPHA_SERVER_URL;\n      config.token = process.env.HYPHA_TOKEN;\n      config.client_id = process.env.HYPHA_CLIENT_ID;\n      config.workspace = process.env.HYPHA_WORKSPACE;\n    } else if (typeof self !== \"undefined\" && self.env) {\n      // WebWorker (only if you inject self.env manually)\n      config.server_url = self.env.HYPHA_SERVER_URL;\n      config.token = self.env.HYPHA_TOKEN;\n      config.client_id = self.env.HYPHA_CLIENT_ID;\n      config.workspace = self.env.HYPHA_WORKSPACE;\n    } else if (typeof globalThis !== \"undefined\" && globalThis.env) {\n      // Browser (only if you define globalThis.env beforehand)\n      config.server_url = globalThis.env.HYPHA_SERVER_URL;\n      config.token = globalThis.env.HYPHA_TOKEN;\n      config.client_id = globalThis.env.HYPHA_CLIENT_ID;\n      config.workspace = globalThis.env.HYPHA_WORKSPACE;\n    }\n  }\n\n  let server_url = normalizeServerUrl(config.server_url);\n\n  let connection = new WebsocketRPCConnection(\n    server_url,\n    clientId,\n    config.workspace,\n    config.token,\n    config.reconnection_token,\n    config.method_timeout || 60,\n    config.WebSocketClass,\n    config.token_refresh_interval,\n    config.additional_headers,\n  );\n  const connection_info = await connection.open();\n  assert(\n    connection_info,\n    \"Failed to connect to the server, no connection info obtained. This issue is most likely due to an outdated Hypha server version. Please use `imjoy-rpc` for compatibility, or upgrade the Hypha server to the latest version.\",\n  );\n  // wait for 0.5 seconds\n  await new Promise((resolve) => setTimeout(resolve, 100));\n  // Ensure manager_id is set before proceeding\n  if (!connection.manager_id) {\n    console.warn(\"Manager ID not set immediately, waiting...\");\n\n    // Wait for manager_id to be set with timeout\n    const maxWaitTime = 5000; // 5 seconds\n    const checkInterval = 100; // 100ms\n    const startTime = Date.now();\n\n    while (!connection.manager_id && Date.now() - startTime < maxWaitTime) {\n      await new Promise((resolve) => setTimeout(resolve, checkInterval));\n    }\n\n    if (!connection.manager_id) {\n      console.error(\"Manager ID still not set after waiting\");\n      throw new Error(\"Failed to get manager ID from server\");\n    } else {\n      console.info(`Manager ID set after waiting: ${connection.manager_id}`);\n    }\n  }\n  if (config.workspace && connection_info.workspace !== config.workspace) {\n    throw new Error(\n      `Connected to the wrong workspace: ${connection_info.workspace}, expected: ${config.workspace}`,\n    );\n  }\n\n  const workspace = connection_info.workspace;\n  const rpc = new RPC(connection, {\n    client_id: clientId,\n    workspace,\n    default_context: { connection_type: \"websocket\" },\n    name: config.name,\n    method_timeout: config.method_timeout,\n    app_id: config.app_id,\n    server_base_url: connection_info.public_base_url,\n    long_message_chunk_size: config.long_message_chunk_size,\n  });\n  await rpc.waitFor(\"services_registered\", config.method_timeout || 120);\n  const wm = await rpc.get_manager_service({\n    timeout: config.method_timeout,\n    case_conversion: \"camel\",\n    kwargs_expansion: config.kwargs_expansion || false,\n  });\n  wm.rpc = rpc;\n\n  async function _export(api) {\n    api.id = \"default\";\n    api.name = api.name || config.name || api.id;\n    api.description = api.description || config.description;\n    await rpc.register_service(api, { overwrite: true });\n  }\n\n  async function getApp(clientId) {\n    clientId = clientId || \"*\";\n    assert(!clientId.includes(\":\"), \"clientId should not contain ':'\");\n    if (!clientId.includes(\"/\")) {\n      clientId = connection_info.workspace + \"/\" + clientId;\n    }\n    assert(\n      clientId.split(\"/\").length === 2,\n      \"clientId should match pattern workspace/clientId\",\n    );\n    return await wm.getService(`${clientId}:default`);\n  }\n\n  async function listApps(ws) {\n    ws = ws || workspace;\n    assert(!ws.includes(\":\"), \"workspace should not contain ':'\");\n    assert(!ws.includes(\"/\"), \"workspace should not contain '/'\");\n    const query = { workspace: ws, service_id: \"default\" };\n    return await wm.listServices(query);\n  }\n\n  if (connection_info) {\n    wm.config = Object.assign(wm.config, connection_info);\n  }\n  wm.export = schemaFunction(_export, {\n    name: \"export\",\n    description: \"Export the api.\",\n    parameters: {\n      properties: { api: { description: \"The api to export\", type: \"object\" } },\n      required: [\"api\"],\n      type: \"object\",\n    },\n  });\n  wm.getApp = schemaFunction(getApp, {\n    name: \"getApp\",\n    description: \"Get the app.\",\n    parameters: {\n      properties: {\n        clientId: { default: \"*\", description: \"The clientId\", type: \"string\" },\n      },\n      type: \"object\",\n    },\n  });\n  wm.listApps = schemaFunction(listApps, {\n    name: \"listApps\",\n    description: \"List the apps.\",\n    parameters: {\n      properties: {\n        workspace: {\n          default: workspace,\n          description: \"The workspace\",\n          type: \"string\",\n        },\n      },\n      type: \"object\",\n    },\n  });\n  wm.disconnect = schemaFunction(rpc.disconnect.bind(rpc), {\n    name: \"disconnect\",\n    description: \"Disconnect from the server.\",\n    parameters: { type: \"object\", properties: {}, required: [] },\n  });\n  wm.registerCodec = schemaFunction(rpc.register_codec.bind(rpc), {\n    name: \"registerCodec\",\n    description: \"Register a codec for the webrtc connection\",\n    parameters: {\n      type: \"object\",\n      properties: {\n        codec: {\n          type: \"object\",\n          description: \"Codec to register\",\n          properties: {\n            name: { type: \"string\" },\n            type: {},\n            encoder: { type: \"function\" },\n            decoder: { type: \"function\" },\n          },\n        },\n      },\n    },\n  });\n\n  wm.emit = schemaFunction(rpc.emit.bind(rpc), {\n    name: \"emit\",\n    description: \"Emit a message.\",\n    parameters: {\n      properties: { data: { description: \"The data to emit\", type: \"object\" } },\n      required: [\"data\"],\n      type: \"object\",\n    },\n  });\n\n  wm.on = schemaFunction(rpc.on.bind(rpc), {\n    name: \"on\",\n    description: \"Register a message handler.\",\n    parameters: {\n      properties: {\n        event: { description: \"The event to listen to\", type: \"string\" },\n        handler: { description: \"The handler function\", type: \"function\" },\n      },\n      required: [\"event\", \"handler\"],\n      type: \"object\",\n    },\n  });\n\n  wm.off = schemaFunction(rpc.off.bind(rpc), {\n    name: \"off\",\n    description: \"Remove a message handler.\",\n    parameters: {\n      properties: {\n        event: { description: \"The event to remove\", type: \"string\" },\n        handler: { description: \"The handler function\", type: \"function\" },\n      },\n      required: [\"event\", \"handler\"],\n      type: \"object\",\n    },\n  });\n\n  wm.once = schemaFunction(rpc.once.bind(rpc), {\n    name: \"once\",\n    description: \"Register a one-time message handler.\",\n    parameters: {\n      properties: {\n        event: { description: \"The event to listen to\", type: \"string\" },\n        handler: { description: \"The handler function\", type: \"function\" },\n      },\n      required: [\"event\", \"handler\"],\n      type: \"object\",\n    },\n  });\n\n  wm.getServiceSchema = schemaFunction(rpc.get_service_schema, {\n    name: \"getServiceSchema\",\n    description: \"Get the service schema.\",\n    parameters: {\n      properties: {\n        service: {\n          description: \"The service to extract schema\",\n          type: \"object\",\n        },\n      },\n      required: [\"service\"],\n      type: \"object\",\n    },\n  });\n\n  wm.registerService = schemaFunction(rpc.register_service.bind(rpc), {\n    name: \"registerService\",\n    description: \"Register a service.\",\n    parameters: {\n      properties: {\n        service: { description: \"The service to register\", type: \"object\" },\n        force: {\n          default: false,\n          description: \"Force to register the service\",\n          type: \"boolean\",\n        },\n      },\n      required: [\"service\"],\n      type: \"object\",\n    },\n  });\n  wm.unregisterService = schemaFunction(rpc.unregister_service.bind(rpc), {\n    name: \"unregisterService\",\n    description: \"Unregister a service.\",\n    parameters: {\n      properties: {\n        service: {\n          description: \"The service id to unregister\",\n          type: \"string\",\n        },\n        notify: {\n          default: true,\n          description: \"Notify the workspace manager\",\n          type: \"boolean\",\n        },\n      },\n      required: [\"service\"],\n      type: \"object\",\n    },\n  });\n  if (connection.manager_id) {\n    rpc.on(\"force-exit\", async (message) => {\n      if (message.from === \"*/\" + connection.manager_id) {\n        console.log(\"Disconnecting from server, reason:\", message.reason);\n        await rpc.disconnect();\n      }\n    });\n  }\n  if (config.webrtc) {\n    await registerRTCService(wm, `${clientId}-rtc`, config.webrtc_config);\n    // make a copy of wm, so webrtc can use the original wm.getService\n    const _wm = Object.assign({}, wm);\n    const description = _wm.getService.__schema__.description;\n    // TODO: Fix the schema for adding options for webrtc\n    const parameters = _wm.getService.__schema__.parameters;\n    wm.getService = schemaFunction(\n      webrtcGetService.bind(null, _wm, `${workspace}/${clientId}-rtc`),\n      {\n        name: \"getService\",\n        description,\n        parameters,\n      },\n    );\n\n    wm.getRTCService = schemaFunction(getRTCService.bind(null, wm), {\n      name: \"getRTCService\",\n      description: \"Get the webrtc connection, returns a peer connection.\",\n      parameters: {\n        properties: {\n          config: {\n            description: \"The config for the webrtc service\",\n            type: \"object\",\n          },\n        },\n        required: [\"config\"],\n        type: \"object\",\n      },\n    });\n  } else {\n    const _getService = wm.getService;\n    wm.getService = (query, config) => {\n      config = config || {};\n      return _getService(query, config);\n    };\n    wm.getService.__schema__ = _getService.__schema__;\n  }\n\n  async function registerProbes(probes) {\n    probes.id = \"probes\";\n    probes.name = \"Probes\";\n    probes.config = { visibility: \"public\" };\n    probes.type = \"probes\";\n    probes.description = `Probes Service, visit ${server_url}/${workspace}services/probes for the available probes.`;\n    return await wm.registerService(probes, { overwrite: true });\n  }\n\n  wm.registerProbes = schemaFunction(registerProbes, {\n    name: \"registerProbes\",\n    description: \"Register probes service\",\n    parameters: {\n      properties: {\n        probes: {\n          description:\n            \"The probes to register, e.g. {'liveness': {'type': 'function', 'description': 'Check the liveness of the service'}}\",\n          type: \"object\",\n        },\n      },\n      required: [\"probes\"],\n      type: \"object\",\n    },\n  });\n  return wm;\n}\n\nexport async function getRemoteService(serviceUri, config = {}) {\n  const { serverUrl, workspace, clientId, serviceId, appId } =\n    parseServiceUrl(serviceUri);\n  const fullServiceId = `${workspace}/${clientId}:${serviceId}@${appId}`;\n\n  if (config.serverUrl) {\n    if (config.serverUrl !== serverUrl) {\n      throw new Error(\n        \"server_url in config does not match the server_url in the url\",\n      );\n    }\n  }\n  config.serverUrl = serverUrl;\n  const server = await connectToServer(config);\n  return await server.getService(fullServiceId);\n}\n\nexport class LocalWebSocket {\n  constructor(url, client_id, workspace) {\n    this.url = url;\n    this.onopen = () => {};\n    this.onmessage = () => {};\n    this.onclose = () => {};\n    this.onerror = () => {};\n    this.client_id = client_id;\n    this.workspace = workspace;\n    const context = typeof window !== \"undefined\" ? window : self;\n    const isWindow = typeof window !== \"undefined\";\n    this.postMessage = (message) => {\n      if (isWindow) {\n        window.parent.postMessage(message, \"*\");\n      } else {\n        self.postMessage(message);\n      }\n    };\n\n    this.readyState = WebSocket.CONNECTING;\n    context.addEventListener(\n      \"message\",\n      (event) => {\n        const { type, data, to } = event.data;\n        if (to !== this.client_id) {\n          // console.debug(\"message not for me\", to, this.client_id);\n          return;\n        }\n        switch (type) {\n          case \"message\":\n            if (this.readyState === WebSocket.OPEN && this.onmessage) {\n              this.onmessage({ data: data });\n            }\n            break;\n          case \"connected\":\n            this.readyState = WebSocket.OPEN;\n            this.onopen(event);\n            break;\n          case \"closed\":\n            this.readyState = WebSocket.CLOSED;\n            this.onclose(event);\n            break;\n          default:\n            break;\n        }\n      },\n      false,\n    );\n\n    if (!this.client_id) throw new Error(\"client_id is required\");\n    if (!this.workspace) throw new Error(\"workspace is required\");\n    this.postMessage({\n      type: \"connect\",\n      url: this.url,\n      from: this.client_id,\n      workspace: this.workspace,\n    });\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this.postMessage({\n        type: \"message\",\n        data: data,\n        from: this.client_id,\n        workspace: this.workspace,\n      });\n    }\n  }\n\n  close() {\n    this.readyState = WebSocket.CLOSING;\n    this.postMessage({\n      type: \"close\",\n      from: this.client_id,\n      workspace: this.workspace,\n    });\n    this.onclose();\n  }\n\n  addEventListener(type, listener) {\n    if (type === \"message\") {\n      this.onmessage = listener;\n    }\n    if (type === \"open\") {\n      this.onopen = listener;\n    }\n    if (type === \"close\") {\n      this.onclose = listener;\n    }\n    if (type === \"error\") {\n      this.onerror = listener;\n    }\n  }\n}\n\nexport function setupLocalClient({\n  enable_execution = false,\n  on_ready = null,\n}) {\n  return new Promise((resolve, reject) => {\n    const context = typeof window !== \"undefined\" ? window : self;\n    const isWindow = typeof window !== \"undefined\";\n    context.addEventListener(\n      \"message\",\n      (event) => {\n        const {\n          type,\n          server_url,\n          workspace,\n          client_id,\n          token,\n          method_timeout,\n          name,\n          config,\n        } = event.data;\n\n        if (type === \"initializeHyphaClient\") {\n          if (!server_url || !workspace || !client_id) {\n            console.error(\"server_url, workspace, and client_id are required.\");\n            return;\n          }\n\n          if (!server_url.startsWith(\"https://local-hypha-server:\")) {\n            console.error(\n              \"server_url should start with https://local-hypha-server:\",\n            );\n            return;\n          }\n\n          class FixedLocalWebSocket extends LocalWebSocket {\n            constructor(url) {\n              // Call the parent class's constructor with fixed values\n              super(url, client_id, workspace);\n            }\n          }\n          connectToServer({\n            server_url,\n            workspace,\n            client_id,\n            token,\n            method_timeout,\n            name,\n            WebSocketClass: FixedLocalWebSocket,\n          }).then(async (server) => {\n            globalThis.api = server;\n            try {\n              // for iframe\n              if (isWindow && enable_execution) {\n                function loadScript(script) {\n                  return new Promise((resolve, reject) => {\n                    const scriptElement = document.createElement(\"script\");\n                    scriptElement.innerHTML = script.content;\n                    scriptElement.lang = script.lang;\n\n                    scriptElement.onload = () => resolve();\n                    scriptElement.onerror = (e) => reject(e);\n\n                    document.head.appendChild(scriptElement);\n                  });\n                }\n                if (config.styles && config.styles.length > 0) {\n                  for (const style of config.styles) {\n                    const styleElement = document.createElement(\"style\");\n                    styleElement.innerHTML = style.content;\n                    styleElement.lang = style.lang;\n                    document.head.appendChild(styleElement);\n                  }\n                }\n                if (config.links && config.links.length > 0) {\n                  for (const link of config.links) {\n                    const linkElement = document.createElement(\"a\");\n                    linkElement.href = link.url;\n                    linkElement.innerText = link.text;\n                    document.body.appendChild(linkElement);\n                  }\n                }\n                if (config.windows && config.windows.length > 0) {\n                  for (const w of config.windows) {\n                    document.body.innerHTML = w.content;\n                    break;\n                  }\n                }\n                if (config.scripts && config.scripts.length > 0) {\n                  for (const script of config.scripts) {\n                    if (script.lang !== \"javascript\")\n                      throw new Error(\"Only javascript scripts are supported\");\n                    await loadScript(script); // Await the loading of each script\n                  }\n                }\n              }\n              // for web worker\n              else if (\n                !isWindow &&\n                enable_execution &&\n                config.scripts &&\n                config.scripts.length > 0\n              ) {\n                for (const script of config.scripts) {\n                  if (script.lang !== \"javascript\")\n                    throw new Error(\"Only javascript scripts are supported\");\n                  eval(script.content);\n                }\n              }\n\n              if (on_ready) {\n                await on_ready(server, config);\n              }\n              resolve(server);\n            } catch (e) {\n              reject(e);\n            }\n          });\n        }\n      },\n      false,\n    );\n    if (isWindow) {\n      window.parent.postMessage({ type: \"hyphaClientReady\" }, \"*\");\n    } else {\n      self.postMessage({ type: \"hyphaClientReady\" });\n    }\n  });\n}\n"],"names":["HTTPStreamingRPCConnection","constructor","server_url","client_id","workspace","token","reconnection_token","timeout","token_refresh_interval","format","this","_server_url","replace","_client_id","_workspace","_token","_reconnection_token","_timeout","_token_refresh_interval","_format","_handle_message","_handle_disconnected","_handle_connected","_closed","_enable_reconnect","connection_info","manager_id","_stream_reader","_stream_controller","on_message","handler","on_disconnected","on_connected","_get_headers","for_stream","headers","open","console","info","stream_url","_startStreamLoop","start","Date","now","Promise","resolve","setTimeout","Error","actual_ws","url","retry","response","fetch","method","keepalive","ok","error_text","text","status","_processMsgpackStream","_processNdjsonStream","error","message","delay","Math","min","pow","toFixed","reader","body","getReader","decoder","TextDecoder","buffer","done","value","read","decode","stream","lines","split","pop","line","trim","JSON","parse","_handleStreamMessage","warn","_tryDecodeControlMessage","frame_data","length","decoded","type","includes","Uint8Array","newBuffer","set","slice","controlMsg","msg_type","data","emit_message","post_url","set_reconnection","disconnect","reason","normalizeServerUrl","startsWith","endsWith","async","connectToServerHTTP","config","clientId","serverUrl","connection","method_timeout","rpc","default_context","connection_type","name","app_id","server_base_url","public_base_url","waitFor","wm","get_manager_service","case_conversion","bind","description","parameters","properties","registerService","register_service","service","required","_getService","getService","query","__schema__","serve","Object","assign","on","from","_connectToServerHTTP","getRemoteServiceHTTP","serviceUri","serviceId","appId","fullServiceId","server","API_VERSION","ArrayBufferView","getPrototypeOf","_appendBuffer","buffer1","buffer2","tmp","byteLength","withTimeout","promise","timeoutMs","reject","timeoutId","then","result","clearTimeout","catch","indexObject","obj","is","_get_schema","skipContext","Array","isArray","map","v","i","schema","k","stringify","contextIndex","indexOf","splice","function","Timer","callback","args","label","_callback","_args","_label","_task","started","reset","apply","clear","RemoteService","RPC","codecs","max_message_buffer_size","debug","silent","long_message_chunk_size","super","_codecs","_name","_app_id","_local_workspace","_silent","_method_annotations","WeakMap","_max_message_buffer_size","_chunk_store","_method_timeout","_server_base_url","_long_message_chunk_size","_services","_object_store","services","_background_tasks","Set","handleUnhandledRejection","event","reasonStr","toString","preventDefault","window","_hypha_rejection_handler_set","process","addEventListener","add_service","id","require_context","visibility","api_version","ping","_ping","get_service","get_local_service","message_cache","create","_create_message","append","_append_message","_set_message","_process_message","remove","_remove_message","_handle_method","undefined","_emit_message","_on_message","_connection","onConnected","connectionInfo","manager","_get_manager_with_retry","values","servicesCount","registeredCount","failedServices","serviceRegistrationTimeout","serviceInfo","_extract_service_info","serviceError","push","join","_fire","total","registered","failed","subscribe","handleClientDisconnected","client","fullClientId","_handleClientDisconnected","_clientDisconnectedSubscription","subscribeError","managerError","total_services","keys","log","register_codec","msg","context","_generate_remote_method","_rserver","_rtarget","_rmethod","_rpromise","_rdoc","key","heartbeat","overwrite","cache","index","buffers","buffersLengths","totalBufferlength","unit8Arr","b","reduce","p","c","unpacker","next","main","to","ws","user","extra","ArrayBuffer","isView","_event_handlers","close","_cleanupOnDisconnect","session_id","hasOwnProperty","session","heartbeat_task","clearInterval","timer","get_remote_service","unsubscribe","e","off","task","cancel","sessionsCleaned","_cleanupSessionsForClient","sessions_cleaned","sessionKey","target_id","keysToDelete","maxRetries","lastError","attempt","get_all_local_services","service_id","authorized_workspaces","service_uri","kwargs_expansion","provider","svc","_annotate_service_methods","aObject","object_id","run_in_executor","method_name","method_id","val","__rpc_object__","api","normApi","props","getOwnPropertyNames","concat","ws_id","excludeKeys","filteredService","serviceSchema","docs","service_schema","get_service_schema","check_type","notify","serviceTypeInfo","validateKeys","serviceDict","schemaDict","path","annotateRecursive","newService","schemaInfo","forEach","newPath","_annotate_service","get_service_type","unregister_service","unregisterService","_ndarray","typedArray","shape","dtype","_dtype","_rtype","_rvalue","_rshape","_rdtype","_encode_callback","clear_after_called","local_workspace","encoded","self","wrapped_callback","prototype","call","arguments","_cleanup_session_if_needed","__name__","callback_name","store","_get_session_store","should_cleanup","_promise_manager","promise_manager","should_cleanup_on_callback","settle","_callbacks","_cleanup_session_completely","levels","current_store","level","final_key","_cleanup_empty_containers","path_levels","depth","container_key","container","get_session_stats","stats","total_sessions","promise_sessions","regular_sessions","sessions_with_timers","sessions_with_heartbeat","system_stores","session_ids","memory_usage","size","_timer","_heartbeat","_force_cleanup_all_sessions","cleaned_count","keys_to_delete","_is_promise_method_call","method_path","_create_promise_manager","_encode_promise","interval","_send_chunks","remote_services","message_id","total_size","start_time","chunk_num","ceil","semaphore","tasks","idx","startByte","chunk","taskFn","run","all","cleanupError","emit","main_message","extra_data","message_package","encoded_method","remote_parent","local_parent","remote_workspace","with_promise","remote_method","local_session_id","_encode","argLength","withKwargs","_rkwargs","from_client","timeoutCallback","error_msg","hasInterfaceObject","_rintf","some","item","promiseData","__no_chunk__","err","parts","_rname","__doc__","_rschema","get_client_info","ctx","remote_client_id","parent","_decode","_expand_promise","setInterval","session_store","method_parts","has","get","session_target_id","encode","last_index","aType","bObject","temp","isAsync","nextItemMethod","iterator","annotation","funcInfo","func","funcString","nameMatch","match","paramsMatch","params","filter","docMatch","docstringBlock","docstringLine","s","docstring","sig","doc","getFunctionInfo","isarray","tp","codec","encoder","encodedObj","tf","Tensor","v_buffer","dataSync","nj","NdArray","selection","_rtrace","stack","Boolean","String","RegExp","ImageData","FileList","FileSystemDirectoryHandle","FileSystemFileHandle","FileSystemHandle","FileSystemWritableFileStream","Blob","_current_pos","blob","ret","arrayBuffer","seek","pos","_rnative","_path","webkitRelativePath","DataView","Map","gen_method","asyncGeneratorProxy","next_item","array","Uint8","reshape","arraytype","tensor","byteOffset","bytes","t","randId","random","substr","getTime","toCamelCase","str","toUpperCase","toSnakeCase","toLowerCase","expandKwargs","newObj","lastArg","kwargs","_rkwarg","convertCase","caseType","camelKey","snakeKey","parseServiceUrl","pattern","groups","dtypeToTypedArray","int8","Int8Array","int16","Int16Array","int32","Int32Array","uint8","uint16","Uint16Array","uint32","Uint32Array","float32","Float32Array","float64","Float64Array","loadRequirementsInWindow","requirements","_importScript","scriptTag","document","createElement","src","onload","onreadystatechange","readyState","onerror","head","appendChild","importScripts","len","link_node","rel","href","import","loadRequirementsInWebworker","loadRequirements","WorkerGlobalScope","normalizeConfig","version","target_origin","allow_execution","typedArrayToDtypeMapping","typedArrayToDtypeKeys","arrType","eval","typedArrayToDtype","pt","cacheUrlInServiceWorker","command","navigator","serviceWorker","register","messageChannel","MessageChannel","port1","onmessage","controller","postMessage","port2","cacheRequirements","req","assert","condition","urlJoin","prom","time","race","_r","rej","finally","MessageEmitter","_once_handlers","_debug","once","___event_run_once","Semaphore","max","queue","current","shift","isGenerator","throw","return","isAsyncGenerator","Symbol","asyncIterator","toStringTag","z","object","_optional","string","number","integer","boolean","items","optional","schemaFunction","schema_type","funcName","processedParameters","entries","WebRTCConnection","channel","_data_channel","_last_message","onopen","send","onclose","exp","_setupRPC","getRTCService","peer_id","pc","RTCPeerConnection","iceServers","ice_servers","urls","sdpSemantics","resolved","connectionState","iceConnectionState","on_init","createDataChannel","ordered","binaryType","offer","createOffer","setLocalDescription","resolveIce","iceGatheringState","answer","sdp","localDescription","registerCodec","setRemoteDescription","RTCSessionDescription","registerRTCService","onInit","createAnswer","_createOffer","extendStatics","__extends","d","setPrototypeOf","__proto__","TypeError","__","DecodeError","_super","_this","proto","defineProperty","configurable","enumerable","ExtData","timestampExtension","msec","sec","nsec","nsecInSec","_a","view","rv","setUint32","secHigh","secLow","encodeTimeSpecToTimestamp","floor","timeSpec","getUint32","nsec30AndSecHigh2","decodeTimestampToTimeSpec","ExtensionCodec","builtInEncoders","builtInDecoders","encoders","decoders","tryToEncode","encodeExt","decodeExt","defaultCodec","prettyByte","byte","abs","padStart","CachedKeyDecoder","maxKeyLength","maxLengthPerKey","hit","miss","caches","canBeCached","find","inputOffset","FIND_CHUNK","_i","records_1","record","recordBytes","j","records","cachedValue","utf8","slicedCopyOfBytes","__generator","thisArg","f","y","g","_","sent","trys","ops","verb","n","op","step","__asyncValues","o","m","__values","__await","EMPTY_VIEW","EMPTY_BYTES","DataViewIndexOutOfBoundsError","getInt8","MORE_DATA","sharedCachedKeyDecoder","Decoder","extensionCodec","maxStrLength","maxBinLength","maxArrayLength","maxMapLength","maxExtLength","keyDecoder","totalPos","headByte","reinitializeState","setBuffer","appendBuffer","hasRemaining","remainingData","subarray","newData","createExtraByteError","posToShow","RangeError","doDecodeSync","decodeMulti","decodeAsync","stream_1","stream_1_1","e_1","_arguments","P","generator","e_1_1","_b","_c","fulfilled","rejected","decodeArrayStream","decodeMultiAsync","decodeStream","q","a","resume","r","fulfill","__asyncGenerator","isArrayHeaderRequired","arrayItemsLeft","stream_2","stream_2_1","e_2","e_3_1","e_3","readArraySize","complete","DECODE","readHeadByte","pushMapState","pushArrayState","decodeUtf8String","readF32","readF64","readU8","readU16","readU32","readU64","readI8","readI16","readI32","readI64","lookU8","lookU16","lookU32","decodeBinary","decodeExtension","state","position","keyType","readCount","headerOffset","offset","stateIsMapKey","headOffset","extType","getUint8","getUint16","getInt16","getInt32","getFloat32","getFloat64","defaultDecodeOptions","options","Encoder","maxDepth","initialBufferSize","sortKeys","forceFloat32","ignoreUndefined","forceIntegerToFloat","encodeSharedRef","doEncode","encodeNil","encodeBoolean","encodeNumber","encodeString","encodeObject","ensureBufferSizeToWrite","sizeToWrite","requiredSize","resizeBuffer","newSize","newBytes","newView","writeU8","Number","isSafeInteger","writeU16","writeU32","writeU64","writeI8","writeI16","writeI32","writeI64","writeF32","writeF64","writeStringHeader","ext","encodeExtension","encodeArray","encodeBinary","encodeMap","writeU8a","object_1","countWithoutUndefined","count","keys_1","sort","keys_2","setUint8","setInt8","setUint16","setInt16","setInt32","setFloat32","setFloat64","defaultEncodeOptions","UINT32_MAX","setUint64","high","low","setInt64","getInt64","getUint64","ensureUint8Array","createDataView","bufferView","TEXT_ENCODING_AVAILABLE","env","TextEncoder","utf8Count","strLength","charCodeAt","utf8EncodeJs","output","outputOffset","sharedTextEncoder","TEXT_ENCODER_THRESHOLD","utf8EncodeTE","encodeInto","CHUNK_SIZE","utf8DecodeJs","end","units","byte1","byte2","byte3","unit","fromCharCode","sharedTextDecoder","TEXT_DECODER_THRESHOLD","utf8DecodeTD","stringBytes","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","definition","prop","MAX_RETRY","WebsocketRPCConnection","WebSocketClass","additional_headers","_websocket","_WebSocketClass","WebSocket","_legacy_auth","_refresh_token_task","_reconnect_timeouts","_additional_headers","_cleanup","_attempt_connection","attempt_fallback","websocket","code","_attempt_connection_with_query_params","queryParamsParts","encodeURIComponent","full_url","_establish_connection","first_message","reconnection_token_life_time","announcement","authInfo","_send_refresh_token","parsedData","_handle_close","OPEN","refreshMessage","CLOSED","baseDelay","maxDelay","maxJitter","reconnect","jitter","finalDelay","delete","add","CLOSING","login","login_service_id","expires_in","login_timeout","login_callback","profile","transport","connectToServer","login_url","check","logout","logout_callback","logout_url","webrtcGetService","rtc_service_id","webrtc","webrtc_config","peer","rtcSvc","_webrtc","_peer","_service","HYPHA_SERVER_URL","HYPHA_TOKEN","HYPHA_CLIENT_ID","HYPHA_WORKSPACE","globalThis","maxWaitTime","checkInterval","startTime","export","getApp","default","listApps","listServices","getServiceSchema","force","_wm","registerProbes","probes","getRemoteService","LocalWebSocket","isWindow","CONNECTING","listener","setupLocalClient","FixedLocalWebSocket","enable_execution","loadScript","script","scriptElement","innerHTML","content","lang","styles","style","styleElement","links","link","linkElement","innerText","windows","w","scripts","on_ready"],"sourceRoot":""}